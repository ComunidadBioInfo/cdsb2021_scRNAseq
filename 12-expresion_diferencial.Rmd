# AnÃ¡lisis de expresiÃ³n diferencial

Instructor: [Leonardo Collado Torres](https://comunidadbioinfo.github.io/es/authors/lcollado/)

```{r cargar_paquetes, message = FALSE}
## Paquetes de este capÃ­tulo
library("MouseGastrulationData") ## para descargar datos de ejemplo
library("scater") ## para grÃ¡ficas y control de calidad
library("scran") ## para selecciÃ³n de genes, clustering, etc
library("batchelor") ## para mÃ©todos de correciÃ³n de batch (lote)
library("patchwork") ## para agrupar grÃ¡ficas
library("Polychrome") ## para muchos colores
library("bluster") ## mÃ©todos de clustering
library("edgeR") ## para expresiÃ³n diferencial
```

## Diapositivas de Peter Hickey

Ve las diapositivas [aquÃ­](https://docs.google.com/presentation/d/1CRTE_1m8YHf8p6GMl-rbBpyOx2KS4UxdTC1dpvVgKEs/edit?usp=sharing).

Esas diapositivas estÃ¡n basadas en este [capÃ­tulo de OSCA](https://bioconductor.org/books/release/OSCA/multi-sample-comparisons.html). El libro de OSCA tiene algunas partes mÃ¡s actualizadas de lo que vienen en las diapositivas.

## MotivaciÃ³n

* ğŸ‘‰ scRNA-seq nos puede ayudar a estudiar cambios en composiciÃ³n (cambios en proporciones de cÃ©lulas) o cambios en niveles de expresiÃ³n de genes entre varias condiciones biolÃ³gicas
  - El primero se llama cambios de abundancia,
  - Ejemplo: [despuÃ©s de un tratamiento con una droga](https://www.ncbi.nlm.nih.gov/pubmed/30013148)
  - Ejemplo: [despuÃ©s de modificaciones genÃ©ticas](https://www.ncbi.nlm.nih.gov/pubmed/27383781)
* ğŸ‘‰ Nos permite obtener mayor resoluciÃ³n biolÃ³gica que experimentos convencionales de RNA-seq, sobre todo si podemos asociar cambios en poblaciones celulares a manipulaciones experimentales

### Dos categorÃ­as de anÃ¡lisis

* ğŸ‘‰ AnÃ¡lisis de expresiÃ³n diferencial
  - Buscamos cambios en niveles de expresiÃ³n entre condiciones para cÃ©lulas del mismo tipo que estÃ¡n presentes en todas las condiciones
* ğŸ‘‰ AnÃ¡lisis de abundancia diferencial
  - Buscamos cambios en la composiciÃ³n de los tipos celulares entre condiciones
  - PodrÃ­a ser entre estados celulares en vez de tipos celulares
  
**Son dos lados de la misma moneda**

#### ExpresiÃ³n diferencial

```{r, echo = FALSE}
set.seed(20210811)
knitr::kable(data.frame(
    gene = paste0("gene", rep(rep(1:2, each = 2), 2)),
    condiciÃ³n = paste0("grupo", rep(rep(1:2, 2), 2)),
    celula = paste0("celula", rep(1:2, each = 4)),
    expresiÃ³n = round(rnorm(8, mean = 10, sd = 2), 2)
))
```

#### Abundancia diferencial

```{r, echo = FALSE}
set.seed(20210811)
knitr::kable(data.frame(
    condiciÃ³n = paste0("grupo", rep(1:2, 2)),
    celula = paste0("celula", rep(1:2, each = 2)),
    frecuencia = round(rnorm(4, mean = 40, sd = 4), 0)
))
```

## Datos de ejemplo

Embriones de ratÃ³n quimÃ©ricos. 

> * Chimeric E8.5 mouse embryos
>   - td-Tomato+ ESCs injected into WT blastocyst
>   - No genetic differences between the injected and background cells (except expression of td-Tomato in the former)
> * 3 replicate batches
>   - Each batch contains td-Tomato+ and td-Tomato- cells sorted from a single pool of dissociated cells from 6-7 chimeric embryos
>   - 2,000 - 7,000 cells/sample using 10X Genomics
> * Aim is to determine whether the injection procedure itself introduces differences in lineage commitment compared to the background cells

https://bioconductor.org/books/release/OSCA/pijuan-sala-chimeric-mouse-embryo-10x-genomics.html

_Pijuan-Sala, B. et al. A single-cell molecular map of mouse gastrulation and early organogenesis. Nature 566, 490â€“495 (2019)._

### Descarguemos los datos de ejemplo

```{r, message = FALSE}
#--- loading ---#
library("MouseGastrulationData")
sce.chimera <- WTChimeraData(samples = 5:10)
sce.chimera
```


```{r}
## Exploremos los datos
sapply(colData(sce.chimera)[, -(1:2)], function(x) {
    x <- if (is.character(x) || is.integer(x)) factor(x) else x
    summary(x)
})
```

BÃ¡sicamente:

* `sample`: 6 ratones diferentes
* `tomato`: inyectados o no con td-Tomato
* `pool`: lote de secuenciaciÃ³n, cada lote con 1 con y otro sin inyecciÃ³n
* `celltype.mappped`: 35 tipos de cÃ©lulas anotados

```{r}
## NÃºmero de cÃ©lulas en nuestras variables principales
with(colData(sce.chimera), table(sample, pool, tomato))

## NÃºmero de tipos celulares
length(unique(sce.chimera$celltype.mapped))
```


### Procesamiento

* Usaremos los mÃ©todos que ya vimos para procesar datos

* Usaremos `batchelor` porque tenemos muestras de 3 lotes de muestras y queremos eliminar diferencias entre los lotes

* Para mÃ¡s detalles, revisar https://bioconductor.org/books/release/OSCA/integrating-datasets.html

```{r}
#--- feature-annotation ---#
library("scater")
rownames(sce.chimera) <- uniquifyFeatureNames(
    rowData(sce.chimera)$ENSEMBL, rowData(sce.chimera)$SYMBOL
)

#--- quality-control ---#
drop <- sce.chimera$celltype.mapped %in% c("stripped", "Doublet")
sce.chimera <- sce.chimera[, !drop]

#--- normalization ---#
sce.chimera <- logNormCounts(sce.chimera)

#--- variance-modelling ---#
library("scran")
dec.chimera <- modelGeneVar(sce.chimera, block = sce.chimera$sample)
chosen.hvgs <- dec.chimera$bio > 0

#--- merging ---#
library("batchelor")
set.seed(01001001)
merged <- correctExperiments(sce.chimera,
    batch = sce.chimera$sample,
    subset.row = chosen.hvgs,
    PARAM = FastMnnParam(
        merge.order = list(
            list(1, 3, 5), # WT (3 replicates)
            list(2, 4, 6) # td-Tomato (3 replicates)
        )
    )
)

#--- clustering ---#
g <- buildSNNGraph(merged, use.dimred = "corrected")
clusters <- igraph::cluster_louvain(g)
colLabels(merged) <- factor(clusters$membership)

#--- dimensionality-reduction ---#
merged <- runTSNE(merged, dimred = "corrected", external_neighbors = TRUE)
merged <- runUMAP(merged, dimred = "corrected", external_neighbors = TRUE)
```

### Exploremos los datos de ejemplo

* Exploremos si tenemos clusters con una diferencia grande en el nÃºmero de celulas entre las muestras sin y con inyecciones de td-Tomato

* Exploremos el nÃºmero de cÃ©lulas en cada cluster a lo largo de los 3 lotes de secuenciaciÃ³n (batch)

```{r}
## Clusters vs DE por td-Tomato
table(colLabels(merged), merged$tomato)

## Clusters vs lotes de muestras (batch)
table(colLabels(merged), merged$pool)
```

* Visualizaremos nuestros clusters que son `r length(unique(merged$label))` en dimensiones reducidas de t-SNE
  - Queremos que todos los clusters tengan muestras de cada lote de secuenciaciÃ³n (batch). Detalles en [OSCA](https://bioconductor.org/books/release/OSCA/integrating-datasets.html)
  - Vemos que no parece que haya mucha seÃ±al en base a td-Tomato
  
```{r, fig.width=10}
library("patchwork")
plotTSNE(merged, colour_by = "tomato", text_by = "label") +
    plotTSNE(merged, colour_by = data.frame(pool = factor(merged$pool)))
```

* Podemos usar `facet_wrap()` para reducir el _over-plotting_ y ver mejor la informaciÃ³n.

```{r, fig.width=10}
plotTSNE(merged,
    colour_by = "tomato",
    other_fields = c("tomato")
) + facet_wrap(~tomato)
```

```{r, fig.width=15}
plotTSNE(merged,
    colour_by = data.frame(pool = factor(merged$pool)),
    other_fields = c("pool")
) + facet_wrap(~pool)
```

* TambiÃ©n podrÃ­amos usar [`Nebulosa`](https://bioconductor.org/packages/Nebulosa).

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This one is from a while back, but on 2020-11-20 I presented for <a href="https://twitter.com/LIBDrstats?ref_src=twsrc%5Etfw">@LIBDrstats</a> the <a href="https://twitter.com/hashtag/Nebulosa?src=hash&amp;ref_src=twsrc%5Etfw">#Nebulosa</a> <a href="https://twitter.com/Bioconductor?ref_src=twsrc%5Etfw">@Bioconductor</a> <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> package by <a href="https://twitter.com/josealquicirah?ref_src=twsrc%5Etfw">@josealquicirah</a> et al for visualizing sc/snRNA-seq data<br><br>ğŸ“” <a href="https://t.co/vWmT398lXG">https://t.co/vWmT398lXG</a><a href="https://t.co/D3TbpOKkwF">https://t.co/D3TbpOKkwF</a> <a href="https://t.co/KFihrSGVUy">https://t.co/KFihrSGVUy</a></p>&mdash; ğŸ‡²ğŸ‡½ Leonardo Collado-Torres (@lcolladotor) <a href="https://twitter.com/lcolladotor/status/1382675331614642177?ref_src=twsrc%5Etfw">April 15, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

### Nuestros clusters vs los originales

* Las siguientes grÃ¡ficas nos ayudan a comparar nuestros clusters vs los que encontraron en el estudio original

* Â¿Les parecen similares?

```{r, fig.width=10, warning = FALSE}
## Definir colores, si no scater nos los pone en una escala
## continua
cols_label <- Polychrome::palette36.colors(length(unique(merged$label)))
names(cols_label) <- unique(merged$label)
cols_celltype.mapped <- Polychrome::palette36.colors(length(unique(merged$celltype.mapped)))
names(cols_celltype.mapped) <- unique(merged$celltype.mapped)

## Nuestros clusters vs anotaciÃ³n de cÃ©lulas por los
## autores originales
plotTSNE(merged, colour_by = "label", text_by = "label") +
    theme(legend.position = "none") +
    scale_colour_manual(values = cols_label) +
    plotTSNE(merged, colour_by = "celltype.mapped") +
    theme(legend.position = "none") +
    scale_colour_manual(values = cols_celltype.mapped)
```

* Es difÃ­cil el proceso de comparar clusters

* Podemos usar `bluster` para evaluar nÃºmericamente que tanto se parecen los clusters. Entre mÃ¡s cerca de 1, mejor en `pairwiseRand()`

* TambiÃ©n podemos hacer un heatmap

```{r, fig.height = 8}
library("bluster")
pairwiseRand(colLabels(merged), merged$celltype.mapped, "index")

by.label <- table(colLabels(merged), merged$celltype.mapped)
pheatmap::pheatmap(log2(by.label + 1), color = viridis::viridis(101))
```

* Por eso es mÃ¡s fÃ¡cil combinar datos de varios lotes de secuenciaciÃ³n y hacer un solo clustering en vez de varios y tener que identificar que clusters de una muestra corresponden a los de otra

* âš ï¸ Nos saltaremos el proceso de anotaciÃ³n de cÃ©lulas y usaremos los clusters y etiquetas originales

## AnÃ¡lisis de expresiÃ³n diferencial

* En RNA-seq estamos acostumbrados a evaluar si hay diferencias en los niveles de expresiÃ³n de genes entre condiciones, asÃ­ que es natural que lo hagamos con scRNA-seq tambiÃ©n

* ğŸ¤” Pero los datos de scRNA-seq tienen muchos ceros 


### Pseudo-bulking

* El proceso de _pseudo-bulking_ es un truco que nos permite usar mÃ©todos de bulk RNA-seq para analizar nuestros datos de scRNA-seq

* CÃ³mo tenemos muchas cÃ©lulas de cada condiciÃ³n, para cada gene podemos sumar los niveles de expresiÃ³n entre todas las cÃ©lulas de esa condiciÃ³n

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">ğŸ”¥off the press! ğŸ‘€ our <a href="https://twitter.com/biorxivpreprint?ref_src=twsrc%5Etfw">@biorxivpreprint</a> on human ğŸ§ brain <a href="https://twitter.com/LieberInstitute?ref_src=twsrc%5Etfw">@LieberInstitute</a> spatial ğŸŒŒğŸ”¬transcriptomics data ğŸ§¬using Visium <a href="https://twitter.com/10xGenomics?ref_src=twsrc%5Etfw">@10xGenomics</a>ğŸ‰<a href="https://twitter.com/hashtag/spatialLIBD?src=hash&amp;ref_src=twsrc%5Etfw">#spatialLIBD</a><br><br>ğŸ”<a href="https://t.co/RTW0VscUKR">https://t.co/RTW0VscUKR</a> <br>ğŸ‘©ğŸ¾â€ğŸ’»<a href="https://t.co/bsg04XKONr">https://t.co/bsg04XKONr</a><br>ğŸ“š<a href="https://t.co/FJDOOzrAJ6">https://t.co/FJDOOzrAJ6</a><br>ğŸ“¦<a href="https://t.co/Au5jwADGhY">https://t.co/Au5jwADGhY</a><a href="https://t.co/PiWEDN9q2N">https://t.co/PiWEDN9q2N</a> <a href="https://t.co/aWy0yLlR50">pic.twitter.com/aWy0yLlR50</a></p>&mdash; ğŸ‡²ğŸ‡½ Leonardo Collado-Torres (@lcolladotor) <a href="https://twitter.com/lcolladotor/status/1233661576433061888?ref_src=twsrc%5Etfw">February 29, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

* Ejemplo de mi trabajo:
  - 12 muestras
  - 7 regiones
  - 47,681 _spots_ (digamos que cÃ©lulas)

<script async class="speakerdeck-embed" data-slide="10" data-id="dde92cd6dfc04f9589770e074915658f" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

* Podemos _comprimir_ la informaciÃ³n a una matriz de 12 * 7 = 84 columnas

* Nos quedamos con pocas _rÃ©plicas_ para nuestro anÃ¡lisis, pero justamente los mÃ©todos de bulk RNA-seq estÃ¡n diseÃ±ados para esos escenarios (claro, entre mÃ¡s datos mejor!!!)

* AcÃ¡ pueden explorar los datos si quieren http://spatial.libd.org/spatialLIBD/

Estas diapositivas son parte de un webinar que di con [Kristen R Maynard](https://twitter.com/kr_maynard) el 2021-04-27 para BioTuring que pueden ver [desde su sitio web](https://bioturing.com/sources/webinar/60752954a433e26dd8affcbd) o en YouTube.

<iframe width="560" height="315" src="https://www.youtube.com/embed/S8884Kde-1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


* Podemos hacerlo manualmente o de forma mÃ¡s sencilla con la funciÃ³n `aggregateAcrossCells()`


```{r}
# Using 'label' and 'sample' as our two factors; each column of the output
# corresponds to one unique combination of these two factors.
summed <- aggregateAcrossCells(merged,
    id = colData(merged)[, c("celltype.mapped", "sample")]
)
summed

dim(merged)
dim(summed)

with(colData(merged), length(unique(celltype.mapped)) * length(unique(sample)))
```

* En teorÃ­a podrÃ­amos tener mÃ¡s columnas, pero no las tenemos todas porque no tenemos datos para todas las combinaciones

* Esto puede afectar nuestro anÃ¡lisis, y pues afecta cuantas variables podremos usar para ajustar
  - Por ejemplo, si agregamos sexo con 2 opciones, duplicarÃ­amos el nÃºmero teÃ³rico de columnas pero tal vez no tengamos suficientes datos
  - Si lo llevas al extremo, terminas con los mismos datos de scRNA-seq que con los que empezamos


### Convertir a un objeto nuevo

* Hagamos nuestro anÃ¡lisis de expresiÃ³n diferencial

* Empezaremos con solo un tipo celular: `Mesenchyme`

```{r}
label <- "Mesenchyme"
current <- summed[, label == summed$celltype.mapped]
dim(current)
```

* Vemos que nos quedamos con solo 14,699 genes a lo largo de 6 muestras
  - Esto serÃ­a un experimento pequeÃ±o de bulk RNA-seq

* Usaremos `edgeR` de [Robinson, McCarthy e Smyth, _Bioinformatics_, 2010](https://pubmed.ncbi.nlm.nih.gov/19910308/) que es uno de los paquetes mÃ¡s usados para anÃ¡lisis de expresiÃ³n diferencial en bulk RNA-seq
  - Aaron Lun, autor de OSCA, se formÃ³ por el mismo grupo en Australia

```{r}
# Creating up a DGEList object for use in edgeR:
library("edgeR")
y <- DGEList(counts(current), samples = colData(current))
y
```

* Listo, ya convertimos nuestros datos al formato que le gusta a `edgeR`


### Pre-procesamiento

* Antes de poder continuar, vamos a eliminar _muestras_ que construimos con el proceso de _pseudo-bulking_ que no tengan al menos 10 cÃ©lulas 

```{r}
discarded <- current$ncells < 10
y <- y[, !discarded]
summary(discarded)
```

* A continuaciÃ³n eliminaremos genes que tengan bajos niveles de expresiÃ³n

```{r}
keep <- filterByExpr(y, group = current$tomato)
y <- y[keep, ]
summary(keep)
```

* DespuÃ©s normalizaremos los datos
  - Pero si ya habÃ­amos normalizado los datos de scRNA-seq, Â¿quÃ© pasÃ³? ^[Empezamos de nuevo con las cuentas originales en `y <- DGEList(counts(current), samples=colData(current))` y no las normalizadas.]

```{r}
y <- calcNormFactors(y)
y$samples
```

* `calcNormFactors()` asume que la mayorÃ­a de los genes no estÃ¡n diferencialmente expresados como describen [Robinson y Oshlack, _Genome Biol._, 2010](https://pubmed.ncbi.nlm.nih.gov/20196867/)

* Podemos visualizar los cambios de expresiÃ³n para todos los genes, una muestra a la vez

```{r}
par(mfrow = c(2, 3))
for (i in seq_len(ncol(y))) {
    plotMD(y, column = i)
}
```

* Podemos usar tÃ©cnicas de reducciÃ³n de dimensiones como `MDS` y `PCA` para explorar la variaciÃ³n entre nuestras muestras (ya no cÃ©lulas)

```{r}
par(mfrow = c(1, 1))
plotMDS(cpm(y, log = TRUE),
    col = ifelse(y$samples$tomato, "red", "blue")
)
```

* Podemos repetir el `plotMDS()` pero con colores por lote (batch) de `pool`.

```{r}
plotMDS(cpm(y, log = TRUE),
    col = c("3" = "darkorchid1", "4" = "darkblue", "5" = "tomato4")[factor(y$samples$pool)]
)
```

* AcÃ¡ vemos que si hay diferencias entre lotes, en particular entre el lote de las muestras 1 y 2 y el resto, ya que el eje X explica el 38% de la varianza.


### Modelo estadÃ­stico

* Si todo nos parece bien, podemos seguir con definir nuestro modelo estadÃ­stico

* Vamos a ajustar por lote (batch) y encontrar diferencias por la inyecciÃ³n de td-Tomato
  - Como empezamos con las cuentas desde cero, tenemos que tomar en cuenta la variaciÃ³n por lote de secuenciaciÃ³n

```{r}
design <- model.matrix(~ factor(pool) + factor(tomato), y$samples)
design
```

* Si queremos explorar nuestro modelo estadÃ­stico de forma interactiva, podemos usar [`ExploreModelMatrix`](https://bioconductor.org/packages/ExploreModelMatrix) por [Charlotte Soneson](https://twitter.com/CSoneson) y [Michael Love](https://twitter.com/mikelove). Charlotte es de las autoras de `iSEE`.

```{r}
if (interactive()) {
    ExploreModelMatrix::ExploreModelMatrix(y$samples[, c("pool", "tomato")], ~ factor(pool) + factor(tomato))
}
```

* Tal y como en bulk RNA-seq, podemos usar la informaciÃ³n de los genes para mejorar nuestros estimados de la varianza para cada gene, de tal forma que mejoramos los resultados estadÃ­sticos aunque tengamos pocas muestras

```{r}
y <- estimateDisp(y, design)
summary(y$trended.dispersion)

plotBCV(y)

fit <- glmQLFit(y, design, robust = TRUE)
summary(fit$var.prior)
summary(fit$df.prior)
plotQLDisp(fit)
```

* Ahora si podemos correr nuestro modelo estÃ¡distico

```{r}
res <- glmQLFTest(fit, coef = ncol(design))
de_n <- summary(decideTests(res))
de_n

topTags(res)
```

* Encontramos `r sum(de_n[c(1, 3), 1])` genes diferencialmente expresados por la inyecciÃ³n de td-Tomato.


### De forma sencilla

* Eso fue mucho trabajo, Â¿no?

* La funciÃ³n `pseudoBulkDGE()` corre todos esos pasos por nosotros

```{r}
# Removing all pseudo-bulk samples with 'insufficient' cells.
summed.filt <- summed[, summed$ncells >= 10]

library("scran")
de.results <- pseudoBulkDGE(summed.filt,
    label = summed.filt$celltype.mapped,
    design = ~ factor(pool) + tomato,
    coef = "tomatoTRUE",
    condition = summed.filt$tomato
)
class(de.results)
length(de.results)
```

* Nos regresa una lista con los resultados para cada uno de nuestros tipos celulares

* Podemos extraer los resultados para nuestro tipo celular de interÃ©s, por ejemplo _Allantois_.

```{r}
cur.results <- de.results[["Allantois"]]
cur.results[order(cur.results$PValue), ]

y.allantois <- metadata(cur.results)$y
plotBCV(y.allantois)
```

* TambiÃ©n nos dice que tipos celulares fallaron porque no tenÃ­amos suficiente informaciÃ³n para hacer el anÃ¡lisis

```{r}
metadata(de.results)$failed
```

* AquÃ­ podemos hacer la misma grÃ¡fica que hicimos de forma manual para _Mesenchyme_.

```{r}
cur.results.Mesenchyme <- de.results[["Mesenchyme"]]
y.Mesenchyme <- metadata(cur.results.Mesenchyme)$y
plotBCV(y.Mesenchyme)
```

### Ejercicios

#### Pseudo-bulking

Hagamos el cÃ¡lculo de pseudo-bulking de forma manual para la primera muestra de `summed` y el gene con los valores mÃ¡s altos de expresiÃ³n para esa muestra. Es decir, trabajaremos con el siguiente gene.

```{r}
colData(summed)[1, ]
which.max(counts(summed)[, 1])
```

Usa el objeto `merged` para volver a calcular el siguiente valor.

```{r}
counts(summed)[which.max(counts(summed)[, 1]), 1]
```

#### VisualizaciÃ³n de resultados de expresiÃ³n diferencial

Usando los resultados de expresiÃ³n diferencial para el tipo celular `Mesenchyme`, reproduce la siguiente visualizaciÃ³n.

```{r volcano, echo = FALSE}
library("ggplot2")
## class(cur.results.Mesenchyme)
# [1] "DFrame"
# attr(,"package")
# [1] "S4Vectors"
df <- as.data.frame(cur.results.Mesenchyme)
df$label <- rownames(df)
p <- ggplot(
    df,
    aes(
        x = logFC,
        y = -log10(PValue),
        color = FDR < 0.05,
        label = label
    )
) +
    geom_point()
p
```

* Explora la informaciÃ³n que tenemos en `cur.results.Mesenchyme`.
* Si usas el paquete `ggplot2`, tendrÃ¡s que usar `as.data.frame()` para convertir un objeto `DFrame` a un `data.frame`.
* Revisa que valores salen en cada eje y en los colores.
* Tal vez algunos valores tiene alguna transformaciÃ³n.
* Â¿Por quÃ© sale un _warning_ diciendo que eliminamos `r sum(is.na(df$logFC))` puntos? ^[Revisa cuÃ¡ntos genes no pasaron nuestro filtro de expresiÃ³n cuando lo hicimos de forma manual en nuestro objeto `keep`. Corre otra vez `table(keep)`.]

### Respuestas

#### Pseudo-bulking

```{r}
## Valor esperado
counts(summed)[which.max(counts(summed)[, 1]), 1]

## Respuesta
sum(counts(merged)[
    names(which.max(counts(summed)[, 1])),
    merged$celltype.mapped == "Allantois" & merged$sample == 5
])

## Otra versiÃ³n
sum(counts(merged)[
    "Ptma",
    with(colData(merged), celltype.mapped == "Allantois" & sample == 5)
])
```

#### VisualizaciÃ³n de resultados de expresiÃ³n diferencial

```{r}
<<volcano>>
```

* Este tipo de grÃ¡fica es un _volcano plot_ donde vemos en el eje X el cambio de expresiÃ³n y en el eje Y el valor p transformado con `-log10(p)`. Usamos colores para marcar los genes con un `FDR < 0.05`.

#### Con etiquetas

* Podemos agregarle etiquetas usando el paquete `ggrepel`.

```{r}
p + ggrepel::geom_text_repel(data = subset(df, FDR < 0.05))
```

#### VersiÃ³n interactiva

* O podemos hacer una versiÃ³n interactiva con `plotly`.

```{r}
plotly::ggplotly(p)
```

## AnÃ¡lisis de abundancia diferencial

```{r}
table(merged$sample)
```

* Si recuerdan, tenemos 6 muestras en total. 

* ğŸ‘‰ Otro tipo de anÃ¡lisis que podemos hacer es preguntarnos si cambiÃ³ la composiciÃ³n celular entre nuestras muestras con y sin la inyecciÃ³n de td-Tomato.

* ğŸ‘‰ Este tipo de anÃ¡lisis nos dirÃ¡ que tipos celulares cambiaron de acuerdo a nuestras condiciones de interÃ©s, que puede ser igual de interesante que encontrar genes diferencialmente expresados.

* ğŸ‘‰ Es como si scRNA-seq fuera un _super-FACS_ donde usamos todo el transcriptoma.

* Hagamos una tabla de la frecuencia de cada tipo celular a lo largo de nuestras muestras. Es decir, una tabla de abundancias

```{r}
abundances <- table(merged$celltype.mapped, merged$sample)
abundances <- unclass(abundances)
head(abundances)
```

* A esta tabla le podemos agregar algo de informaciÃ³n de nuestras muestras, y con eso construir un objeto del tipo que le gusta a `edgeR`

```{r}
# Attaching some column metadata.
extra.info <- colData(merged)[match(colnames(abundances), merged$sample), ]
y.ab <- DGEList(abundances, samples = extra.info)
y.ab
```

* A diferencia de los anÃ¡lisis de expresiÃ³n diferencial, no usaremos `calcNormFactors()` porque este tipo de anÃ¡lisis no cumple, generalmente, con las condiciones del mÃ©todo estadÃ­stico

* A continuaciÃ³n filtramos los tipos celulares para los cuales no tenemos suficiente informaciÃ³n, si es el caso

```{r}
keep <- filterByExpr(y.ab, group = y.ab$samples$tomato)
y.ab <- y.ab[keep, ]
summary(keep)
```

* Luego hacemos nuestro anÃ¡lisis de abundancia con `edgeR` el cual nos permite usar el modelo estadÃ­stico que estÃ¡ diseÃ±ado para valores enteros (cuentas) y pocas rÃ©plicas

* Es la misma formÃºla del modelo estadÃ­stico (`design`) que usamos anteriormente, pero para otros nÃºmeros

```{r}
design <- model.matrix(~ factor(pool) + factor(tomato), y.ab$samples)
design

y.ab <- estimateDisp(y.ab, design, trend = "none")
summary(y.ab$common.dispersion)

plotBCV(y.ab, cex = 1)
```

* A diferencia de antes, tenemos pocos puntos (antes eran genes, ahora son tipos celulares), asÃ­ que no estimaremos una curva, por eso usamos `abundance.trend = FALSE`

```{r}
fit.ab <- glmQLFit(y.ab, design, robust = TRUE, abundance.trend = FALSE)
summary(fit.ab$var.prior)

plotQLDisp(fit.ab, cex = 1)
```

* Corremos el anÃ¡lisis

```{r}
res <- glmQLFTest(fit.ab, coef = ncol(design))
summary(decideTests(res))

topTags(res)
```

* Entre los tipos celulares donde tenÃ­amos suficiente informaciÃ³n, solo 2 muestran diferencias en sus niveles de frecuencia entre las muestras con y sin inyecciones de td-Tomato.

## Comentarios sobre la interpretaciÃ³n


* ğŸ‘‰ La distinciÃ³n entre ambos tipos de anÃ¡lisis en scRNA-seq es articial
 
* Las etiquetas que usamos para el anÃ¡lisis de abundancia estÃ¡n definidas por los niveles de expresiÃ³n de los genes

* Este tema de cuantas veces usas los datos y como eso afecta las pruebas estadÃ­sticas que usamos es un tema de investigaciÃ³n actual

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In a talk that was as clear as her book &quot;intro to stat learning&quot;, today&#39;s <a href="https://twitter.com/hashtag/bioc2021?src=hash&amp;ref_src=twsrc%5Etfw">#bioc2021</a> keynote <a href="https://twitter.com/daniela_witten?ref_src=twsrc%5Etfw">@daniela_witten</a> showed how double dipping (e.g. using genes to cluster data and then testing for DE between clusters) leads to + type 1 error and an intuitive method to correct this prob.</p>&mdash; Alejandro Reyes (@areyesq) <a href="https://twitter.com/areyesq/status/1423006233968140292?ref_src=twsrc%5Etfw">August 4, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

* Les recomiendo que lean detenidamente esa parte en [OSCA](https://bioconductor.org/books/release/OSCA/multi-sample-comparisons.html#comments-on-interpretation)


## Detalles de la sesiÃ³n de R

```{r}
## InformaciÃ³n de la sesiÃ³n de R
Sys.time()
proc.time()
options(width = 120)
sessioninfo::session_info()
```

## Patrocinadores {-}

Agradecemos a nuestros patrocinadores:

<a href="https://comunidadbioinfo.github.io/es/post/cs_and_s_event_fund_award/#.YJH-wbVKj8A"><img src="https://comunidadbioinfo.github.io/post/2021-01-27-cs_and_s_event_fund_award/spanish_cs_and_s_award.jpeg" width="400px" align="center"/></a>

<a href="https://www.r-consortium.org/"><img src="https://www.r-consortium.org/wp-content/uploads/sites/13/2016/09/RConsortium_Horizontal_Pantone.png" width="400px" align="center"/></a>
