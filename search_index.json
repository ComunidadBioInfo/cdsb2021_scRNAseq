[["index.html", "Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Información del taller Formato del curso: en línea ¿Quién es nuestra audiencia? Formulario de registro Instructores Ponentes e instructores invitados Ayudantes Temario Código de Conducta Pre-requisitos Horario Música para ejercicios Materiales Fuentes Zoom Organizadores Patrocinadores Información sesión de R Licencia", " Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Leonardo Collado-Torres Lieber Institute for Brain Development, Johns Hopkins Medical Campus Información del taller 9-13 de agosto de 2021 ¡Bienvenidxs al taller Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor! En los últimos años, la generación y análisis de transcriptomas de célula única ha cobrado gran importancia para resolver preguntas biológicas. En este taller revisaremos los métodos más recientes para analizar datos de single cell RNA-seq (transcriptómica en células únicas), usando paquetes de R especializados que están disponibles libremente vía Bioconductor. Este taller estará basado en el libro Orchestrating Single Cell Analysis with Bioconductor que fue publicado en Nature Methods y es de los artículos con mayor publicidad en 2020 y 2021. Durante este taller aprenderás las herramientas estadísticas para analizar datos de transcriptómica en células únicas usando Bioconductor. Revisaremos qué es un análisis de datos de célula única, cuáles son las principales diferencias entre el análisis de transcriptomas de célula única y en bulk, cómo documentar tu análisis y algunas herramientas para interpretar tus resultados. Formato del curso: en línea Este es un curso digital. Las sesiones y material del curso serán presentados en línea. Esta modalidad incluirá grabaciones de video o audio del material, intercambio de archivos y sesiones de discusión temáticos, ejercicios de auto-evaluación y acceso a los instructores para comentarios durante el curso. ¿Quién es nuestra audiencia? Este curso está dirigido a personas que desean aprender cómo analizar datos transcriptómicos de célula única usando paquetes de R/Bioconductor. Revisa los videos de CDSB2020 en YouTube o la página web de cdsb2020, que es similar al taller de este año. Formulario de registro http://congresos.nnb.unam.mx/EBM2021/ Do you want to learn how to analyze #scRNAseq with @Bioconductor?Learn with @lcolladotor@yalbi_ibm @AnaBetty2304 @argininaa @naielisha @lawrah20 @roramirezf94 @jvelezmagic @KevsGenomic @mpadilla905Material adapted from OSCA @PeteHaitch et al#rstatshttps://t.co/MIfFmKt3Fq pic.twitter.com/nSPCmVEPAC — ComunidadBioInfo (@CDSBMexico) July 2, 2021 Instructores Leonardo Collado-Torres Yalbi Balderas https://comunidadbioinfo.github.io/es/#people Ponentes e instructores invitados Ana Beatriz Villaseñor Altamirano Citlali Gil Aguillon Elisa Márquez Zavala Laura Lucila Gómez Romero Ricardo Ramirez Flores Ayudantes Jesús Vélez Santiago Kevin Emmanuel Meza Landeros Mónica Padilla Gálvez Temario Día 1 Introducción a R y RStudio Ejercicio usando usethis, here y postcards Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Día 2 Estructura e importe de datos Comunidades RLadies Control de calidad Día 3 Normalización de datos Foto y actividades de la comunidad Selección de genes Día 4 Reducción de dimensiones Clustering Identificación de genes marcadores Día 5 Anotación de clusters de células Análisis de expresión diferencial Plática científica del ponente invitadx Código de Conducta Seguiremos el código de conducta de la CDSB México comunidadbioinfo.github.io/es/codigo-de-conducta/ además del código de conducta de Bioconductor bioconductor.org/about/code-of-conduct/. Pre-requisitos De forma general, Computadora con al menos 8Gb de memoria y permisos de administrador para instalar paqueterías de R. Tener instalado R y RStudio en su última versión. Conocimientos básicos de secuenciación de transcriptomas. Conocimientos básicos de RStudio (Creación de Rscripts, manejo de la consola de RStudio, manejo del espacio de visualización). Conocimiento intermedio de R (Manejo de variables, lectura de archivos, creación y manejo de data frames y listas, generación de gráficas básicas, conocimiento sobre cómo instalar paqueterías desde CRAN y Bioconductor). Más específicamente, computadora con al menos 8 GB de memoria RAM, aplicación Zoom https://zoom.us/download, R versión 4.1 instalada de CRAN https://cran.r-project.org/ (ver video de https://youtu.be/6knyHlUe1cM sobre como instalar R en macOS o winOS), RStudio versión 1.4 https://www.rstudio.com/products/rstudio/download/#download, y los siguientes paquetes de R y Bioconductor: ## Para instalar paquetes if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } ## Para instalar paquetes de Bioconductor remotes::install_cran(&quot;BiocManager&quot;) BiocManager::version() # El anterior comando debe mostrar que estás usando la versión 3.13 ## Instala los paquetes de R que necesitamos ## BiocManager::install(c(&quot;batchelor&quot;, &quot;BiocFileCache&quot;, &quot;BiocSingular&quot;, &quot;bluster&quot;, &quot;celldex&quot;, &quot;cowplot&quot;, &quot;dplyr&quot;, &quot;DropletUtils&quot;, &quot;edgeR&quot;, &quot;EnsDb.Hsapiens.v86&quot;, &quot;ExperimentHub&quot;, &quot;ExploreModelMatrix&quot;, &quot;fossil&quot;, &quot;gert&quot;, &quot;ggrepel&quot;, &quot;gh&quot;, &quot;here&quot;, &quot;iSEE&quot;, &quot;kableExtra&quot;, &quot;lobstr&quot;, &quot;MouseGastrulationData&quot;, &quot;org.Mm.eg.db&quot;, &quot;patchwork&quot;, &quot;PCAtools&quot;, &quot;pheatmap&quot;, &quot;plotly&quot;, &quot;Polychrome&quot;, &quot;postcards&quot;, &quot;pryr&quot;, &quot;RColorBrewer&quot;, &quot;Rtsne&quot;, &quot;scater&quot;, &quot;scPipe&quot;, &quot;scran&quot;, &quot;scRNAseq&quot;, &quot;sessioninfo&quot;, &quot;Seurat&quot;, &quot;SingleCellExperiment&quot;, &quot;SingleR&quot;, &quot;suncalc&quot;, &quot;TENxPBMCData&quot;, &quot;usethis&quot;, &quot;uwot&quot;)) Horario Consulta el calendario de este curso en: http://bit.ly/calendarcdsb2021. Horario Tema Instructores Día 1: Agosto 9, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-09:30 Inauguración EBM2021 Julio Collado Vides, Christian Sohlenkamp, Irma Martínez Flores, Shirley Alquicira Hernández 09:30-10:00 Bienvenida a la CDSB y revisión del código de conducta Leonardo Collado-Torres 10:00-11:00 Introducción a R y RStudio Leonardo Collado-Torres 11:00-11:30 Descanso 11:30-14:00 Ejercicio usando usethis, here y postcards Citlali Gil Aguillon y Elisa Márquez Zavala 14:00-15:30 Descanso: comida 15:30-17:00 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Citlali Gil Aguillon y Elisa Márquez Zavala 17:00-18:00 (Invitada) Principios FAIR para software de investigación Paula Andrea Día 2: Agosto 10, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Estructura e importe de datos Citlali Gil Aguillon y Elisa Márquez Zavala 11:00-11:30 Descanso 11:30-12:00 Keynote: La comunidad R-Ladies Ana Beatriz Villaseñor Altamirano 12:00-14:00 Control de calidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Control de calidad Leonardo Collado-Torres 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 3: Agosto 11, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Normalización de datos Ana Beatriz Villaseñor Altamirano 10:30-11:00 Foto 11:00-11:30 Descanso 11:30-12:30 Selección de genes Yalbi Balderas 12:30-14:00 Actividades para construir la comunidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Selección de genes Laura Lucila Gómez Romero 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 4: Agosto 12, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Reducción de dimensiones Laura Lucila Gómez Romero 11:00-11:30 Descanso 11:30-14:00 Clustering Laura Lucila Gómez Romero 14:00-15:30 Descanso: comida 15:30-17:30 Identificación de genes marcadores Yalbi Balderas 17:30-18:30 CDSB 2021: Evento social remoto Día 5: Agosto 13, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Anotación de clusters de células Yalbi Balderas 10:30-11:00 Evaluación del taller Irma Martínez Flores y Shirley Alquicira Hernández 11:00-11:30 Descanso 11:30-12:30 Análisis de expresión diferencial Leonardo Collado-Torres 12:30-14:00 Introducción a Seurat Kevin Emmanuel Meza Landeros 14:00-15:30 Descanso: comida 15:30-17:00 Plática científica y sesión de preguntas Ricardo Ramirez Flores 17:00-17:30 Clausura y recordatorio de la CDSB 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Música para ejercicios Aquí están las listas de canciones por si desean escuchar algo de música mientras realizan ejercicios iTunes Spotify Materiales Descarga los materiales con usethis::use_course('comunidadbioinfo/cdsb2021_scRNAseq') o revisalos en línea vía comunidadbioinfo.github.io/cdsb2021_scRNAseq. Durante el curso Durante el curso estaremos actualizando el material, así que les recomendamos que usen RStudio para crear un nuevo proyecto que esté configurado con git/GitHub, para que con un simple Pull puedan actualizar los archivos del curso en su computadora. Para que funcione bien esto, les recomendamos que no editen los archivos que descarguen. Eso mejor háganlo en sus notas. Primero, en RStudio seleccionen File y luego New Project .... Les saldrá la siguiente ventana donde tienen que escoger la opción de control de versiones. Figure 0.1: Al crear un nuevo proyecto, seleccionen la opción de Version Control (la tercera). A continuación, seleccionen la opción de Git. Figure 0.2: Selecciona la opción de Git (la primera). En la venta para especificar los detalles de git, Específica el siguiente URL del repositorio https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git El nombre del directorio se llenará de forma automática. No tienes que cambiarlo. Especifíca el subdirectorio de donde quieres que guarde este proyecto. Te conviene ponerlo en tu Desktop o algún lugar que no sea adentro de otro proyecto de RStudio. Selecciona la opción de Open in new session para que te abra una nueva ventana de RStudio si así lo prefieres. Figure 0.3: Especifica que el Repository URL es https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git. Fuentes El material de este curso está basado en el: libro Orchestrating Single Cell Analysis with Bioconductor de Aaron Lun, Robert Amezquita, Stephanie Hicks y Raphael Gottardo curso de scRNA-seq para WEHI creado por Peter Hickey curso de Leonardo Collado-Torres para LCG-UNAM-EJ de marzo 2020 https://github.com/lcolladotor/osca_LIIGH_UNAM_2020 taller de la CDSB 2020 https://github.com/ComunidadBioInfo/cdsb2020 curso de Leonardo Collado-Torres para la LCG-UNAM de febrero 2021 https://github.com/lcolladotor/rnaseq_LCG-UNAM_2021 Zoom Las ligas de Zoom están disponibles exclusivamente para lxs participantes de CDSB2021 vía Slack. Te enviaremos una invitación al correo electrónico que usaste para registrate. Organizadores Comunidad de Desarrolladores de Software en Bioinformática CDSB Red Mexicana de Bioinformática RMB Nodo Nacional de Bioinformática en la UNAM NNB-CCG Patrocinadores Agradecemos a nuestros patrocinadores: Información sesión de R Detalles de la sesión de R usada para crear este libro. El código fuente está disponible vía ComunidadBioInfo/cdsb2021_scRNAseq. options(width = 120) pkgs &lt;- installed.packages()[, &quot;Package&quot;] sessioninfo::session_info(pkgs, include_base = TRUE) ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## ade4 1.7-17 2021-06-17 [1] RSPM (R 4.1.0) ## annotate 1.70.0 2021-05-19 [1] Bioconductor ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## AnVIL 1.4.1 2021-06-22 [2] Bioconductor ## ape 5.5 2021-04-25 [1] RSPM (R 4.1.0) ## askpass 1.1 2019-01-13 [2] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## backports 1.2.1 2020-12-09 [1] RSPM (R 4.1.0) ## base * 4.1.0 2021-07-29 [3] local ## base64enc 0.1-3 2015-07-28 [1] RSPM (R 4.1.0) ## batchelor 1.8.1 2021-08-12 [1] Bioconductor ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## benchmarkme 1.0.7 2021-03-21 [1] RSPM (R 4.1.0) ## benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.1.0) ## BH 1.75.0-0 2021-01-11 [1] RSPM (R 4.1.0) ## Biobase 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocStyle 2.20.2 2021-06-17 [1] Bioconductor ## biocthis 1.2.0 2021-05-19 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## boot 1.3-28 2021-05-03 [3] CRAN (R 4.1.0) ## brew 1.0-6 2011-04-13 [2] RSPM (R 4.1.0) ## brio 1.1.2 2021-04-23 [2] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## BumpyMatrix 1.0.1 2021-07-04 [1] Bioconductor ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## callr 3.7.0 2021-04-20 [2] RSPM (R 4.1.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.1.0) ## cdsb2021scRNAseq 0.99.0 2021-08-19 [1] local ## celldex 1.2.0 2021-05-20 [1] Bioconductor ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## class 7.3-19 2021-05-03 [3] CRAN (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clipr 0.7.1 2020-10-08 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## clusterExperiment 2.12.0 2021-05-19 [1] Bioconductor ## ClusterR 1.2.5 2021-05-21 [1] RSPM (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## commonmark 1.7 2018-12-01 [2] RSPM (R 4.1.0) ## compiler 4.1.0 2021-07-29 [3] local ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## cpp11 0.3.1 2021-06-25 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## credentials 1.3.1 2021-07-25 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## datasets * 4.1.0 2021-07-29 [3] local ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## desc 1.3.0 2021-03-05 [2] RSPM (R 4.1.0) ## devtools 2.4.2 2021-06-07 [2] RSPM (R 4.1.0) ## diffobj 0.3.4 2021-03-22 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## docopt 0.7.1 2020-06-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## ExploreModelMatrix 1.4.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## forcats 0.5.1 2021-01-27 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## foreign 0.8-81 2020-12-22 [3] CRAN (R 4.1.0) ## formatR 1.11 2021-06-01 [1] RSPM (R 4.1.0) ## fossil 0.4.0 2020-03-23 [1] RSPM (R 4.1.0) ## fs 1.5.0 2020-07-31 [2] RSPM (R 4.1.0) ## futile.logger 1.4.3 2016-07-10 [1] RSPM (R 4.1.0) ## futile.options 1.0.1 2018-04-20 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## genefilter 1.74.0 2021-05-19 [1] Bioconductor ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges 1.44.0 2021-05-19 [1] Bioconductor ## gert 1.3.2 2021-08-16 [2] RSPM (R 4.1.0) ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## gh 1.3.0 2021-04-30 [2] RSPM (R 4.1.0) ## gitcreds 0.1.1 2020-12-04 [2] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gmp 0.6-2 2021-01-07 [1] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gplots 3.1.1 2020-11-28 [1] RSPM (R 4.1.0) ## graphics * 4.1.0 2021-07-29 [3] local ## grDevices * 4.1.0 2021-07-29 [3] local ## grid 4.1.0 2021-07-29 [3] local ## gridBase 0.4-7 2014-02-24 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## gtools 3.9.2 2021-06-06 [1] RSPM (R 4.1.0) ## hash 2.2.6.1 2019-03-04 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## howmany 0.3-1 2012-06-01 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## ini 0.3.1 2018-05-20 [2] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE 2.4.0 2021-05-19 [1] Bioconductor ## isoband 0.2.5 2021-07-13 [1] RSPM (R 4.1.0) ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## kernlab 0.9-29 2019-11-12 [1] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lambda.r 1.2.4 2019-09-18 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## littler 0.3.13 2021-07-24 [2] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfdr 1.1-8 2015-07-15 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## lubridate 1.7.10 2021-02-26 [1] RSPM (R 4.1.0) ## magick 2.7.2 2021-05-02 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## maps 3.3.0 2018-04-03 [1] RSPM (R 4.1.0) ## markdown 1.1 2019-08-07 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mbkmeans 1.8.0 2021-05-19 [1] Bioconductor ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## methods * 4.1.0 2021-07-29 [3] local ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## MouseGastrulationData 1.6.0 2021-05-20 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## NMF 0.23.0 2020-08-01 [1] RSPM (R 4.1.0) ## nnet 7.3-16 2021-05-03 [3] CRAN (R 4.1.0) ## openssl 1.4.4 2021-04-30 [2] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## parallel 4.1.0 2021-07-29 [3] local ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## PCAtools 2.4.0 2021-05-19 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## phylobase 0.8.10 2020-03-01 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pixmap 0.4-12 2021-01-29 [1] RSPM (R 4.1.0) ## pkgbuild 1.2.0 2020-12-15 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## pkgload 1.2.1 2021-04-06 [2] RSPM (R 4.1.0) ## pkgmaker 0.32.2 2020-10-20 [1] RSPM (R 4.1.0) ## plogr 0.2.0 2018-03-25 [1] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## Polychrome 1.3.1 2021-07-16 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## postcards 0.2.2 2021-07-31 [1] RSPM (R 4.1.0) ## pracma 2.3.3 2021-01-23 [1] RSPM (R 4.1.0) ## praise 1.0.0 2015-08-11 [2] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## processx 3.5.2 2021-04-30 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## pryr 0.1.5 2021-07-26 [1] RSPM (R 4.1.0) ## ps 1.6.0 2021-02-28 [2] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.cache 0.15.0 2021-04-30 [1] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rapiclient 0.1.3 2020-01-17 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## rcmdcheck 1.3.3 2019-05-07 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RcppArmadillo 0.10.6.0.0 2021-07-16 [1] RSPM (R 4.1.0) ## RcppEigen 0.3.3.9.1 2020-12-17 [1] RSPM (R 4.1.0) ## RcppHNSW 0.3.0 2020-09-06 [1] RSPM (R 4.1.0) ## RcppProgress 0.4.2 2020-02-06 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## registry 0.5-1 2019-03-05 [1] RSPM (R 4.1.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.1.0) ## remotes 2.4.0 2021-06-02 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## rncl 0.8.4 2020-02-10 [1] RSPM (R 4.1.0) ## RNeXML 2.4.5 2020-06-18 [1] RSPM (R 4.1.0) ## rngtools 1.5 2020-01-23 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## roxygen2 7.1.1 2020-06-27 [2] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rversions 2.1.1 2021-05-31 [2] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scatterplot3d 0.3-41 2018-03-14 [1] RSPM (R 4.1.0) ## scPipe 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle 1.2.1 2021-08-05 [1] Bioconductor ## selectr 0.4-2 2019-11-20 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shapefiles 0.7 2013-01-26 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment 1.14.1 2021-05-21 [1] Bioconductor ## SingleR 1.6.1 2021-05-20 [1] Bioconductor ## sitmo 2.0.1 2019-01-07 [1] RSPM (R 4.1.0) ## snow 0.4-3 2018-09-14 [1] RSPM (R 4.1.0) ## softImpute 1.4-1 2021-05-09 [1] RSPM (R 4.1.0) ## sourcetools 0.1.7 2018-04-25 [1] RSPM (R 4.1.0) ## sp 1.4-5 2021-01-10 [1] RSPM (R 4.1.0) ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatial 7.3-14 2021-05-03 [3] CRAN (R 4.1.0) ## SpatialExperiment 1.2.1 2021-06-10 [1] Bioconductor ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## splines 4.1.0 2021-07-29 [3] local ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stats * 4.1.0 2021-07-29 [3] local ## stats4 4.1.0 2021-07-29 [3] local ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## styler 1.5.1 2021-07-13 [1] RSPM (R 4.1.0) ## SummarizedExperiment 1.22.0 2021-05-19 [1] Bioconductor ## suncalc 0.5.0 2019-04-03 [1] RSPM (R 4.1.0) ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## sys 3.4 2020-07-23 [2] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tcltk 4.1.0 2021-07-29 [3] local ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## TENxPBMCData 1.10.0 2021-05-20 [1] Bioconductor ## testthat 3.0.4 2021-07-01 [2] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## tinytex 0.33 2021-08-05 [1] RSPM (R 4.1.0) ## tools 4.1.0 2021-07-29 [3] local ## usethis 2.0.1 2021-02-10 [2] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## utils * 4.1.0 2021-07-29 [3] local ## uuid 0.1-4 2020-02-26 [1] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## waldo 0.2.5 2021-03-08 [2] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## whisker 0.4 2019-08-28 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xopen 1.0.0 2018-09-17 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zinbwave 1.14.1 2021-05-25 [1] Bioconductor ## zip 2.2.0 2021-05-31 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Fecha de la última actualización de esta página: 2021-08-19 15:15:46. Licencia This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["inauguración-cdsb2021.html", "Inauguración CDSB2021", " Inauguración CDSB2021 "],["introducción-a-r-y-rstudio.html", "1 Introducción a R y RStudio 1.1 R 1.2 GitHub 1.3 RStudio 1.4 Material del curso 1.5 Detalles de la sesión de R Patrocinadores", " 1 Introducción a R y RStudio Instructor: Leonardo Collado Torres 1.1 R R: es gratis, de acceso libre, utilizado para muchos campos de trabajo, fuerte en la bioinformática a través de Bioconductor Instalación a través de CRAN: https://cran.r-project.org/ Para explorar que se puede hacer con R: R Weekly https://rweekly.org/ R Bloggers https://www.r-bloggers.com/ Twitter https://twitter.com/search?q=%23rstats&amp;src=typed_query Twitter en español https://twitter.com/search?q=%23rstatsES&amp;src=typed_query TidyTuesday https://twitter.com/search?q=%23TidyTuesday&amp;src=typed_query DatosDeMiercoles https://twitter.com/search?q=%23datosdemiercoles&amp;src=typed_query Para pedir ayuda hay muchas opciones https://lcolladotor.github.io/bioc_team_ds/how-to-ask-for-help.html Material en el que estoy involucrado: https://twitter.com/lcolladotor https://www.youtube.com/c/LeonardoColladoTorres/playlists LIBD rstats club https://docs.google.com/spreadsheets/d/1is8dZSd0FZ9Qi1Zvq1uRhm-P1McnJRd_zxdAfCRoMfA/edit?usp=sharing https://twitter.com/CDSBMexico, https://twitter.com/LIBDrstats, https://twitter.com/Bioconductor https://comunidadbioinfo.github.io/ YouTube CDSB: https://www.youtube.com/channel/UCHCdYfAXVzJIUkMoMSGiZMw Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor https://lmweber.org/OSTA-book/ Thank you @Bioconductor for welcoming me &amp; providing me a foundation &amp; platform for my careerGracias BioC por darme una oportunidad y plataforma para desarrollar mi carreraTime to pass it on/Toca enseñar y crecer la bola de nieve ❄️ @CDSBMexico 🇲🇽#BioC2021 #rstats #rstatsES https://t.co/8cDXP4Pf2W pic.twitter.com/rpQgH8UsWW — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 5, 2021 1.2 GitHub Permite compartir código Se complementa con Git que es para tener un control de versiones de tu código https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Introduccion-al-flujo-de-trabajo-orientado-a-proyectos.pdf Puedes tener páginas web estáticas https://pages.github.com/ https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/. En especial https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/tree/gh-pages se convierte en https://comunidadbioinfo.github.io/cdsb2021_scRNAseq/ Página personal: https://github.com/lcolladotor/lcolladotor.github.com se convierte en http://lcolladotor.github.io/. Está todo hecho con https://github.com/lcolladotor/lcolladotorsource Tip: usen el mismo nombre de usuario en GitHub, Twitter, Gmail, etc. How to be a Modern Scientist: https://lcolladotor.github.io/bioc_team_ds/how-to-be-a-modern-scientist.html 1.3 RStudio RStudio Desktop es gratis http://www.rstudio.com/products/rstudio/download/preview/ Nos ayuda a realizar muchas cosas con R de forma más rápida Demo rsthemes remotes::install_github(c( &quot;gadenbuie/rsthemes&quot; )) remotes::install_cran(&quot;suncalc&quot;) rsthemes::install_rsthemes(include_base16 = TRUE) usethis::edit_r_profile() ## From https://www.garrickadenbuie.com/project/rsthemes/ if (interactive() &amp;&amp; requireNamespace(&quot;rsthemes&quot;, quietly = TRUE)) { # Set preferred themes if not handled elsewhere.. rsthemes::set_theme_light(&quot;Solarized Light {rsthemes}&quot;) # light theme rsthemes::set_theme_dark(&quot;base16 Monokai {rsthemes}&quot;) # dark theme rsthemes::set_theme_favorite(c( &quot;Solarized Light {rsthemes}&quot;, &quot;base16 Monokai {rsthemes}&quot;, &quot;One Dark {rsthemes}&quot; )) # Whenever the R session restarts inside RStudio... setHook(&quot;rstudio.sessionInit&quot;, function(isNewSession) { # Automatically choose the correct theme based on time of day ## Used rsthemes::geolocate() once rsthemes::use_theme_auto(lat = 39.2891, lon = -76.5583) }, action = &quot;append&quot;) } ## https://blog.rstudio.com/2013/06/10/rstudio-cran-mirror/ options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) Es actualizado con bastante frecuencia RStudio cheatsheets https://www.rstudio.com/resources/cheatsheets/ https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf RStudio projects: usalos para organizar tu código https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Trabajando-con-proyectos.pdf usethis::create_project(&quot;~/Desktop/cdsb2021_scRNAseq_notas&quot;) ## Inicien un archivo para sus notas usethis::use_r(&quot;01-notas.R&quot;) O por ejemplo el archivo 01-visualizar-mtcars.R ## Creemos el archivo R/01-visualizar-mtcars.R usethis::use_r(&quot;01-visualizar-mtcars.R&quot;) con el siguiente contenido: ## Cargar paquetes que usaremos en este código library(&quot;sessioninfo&quot;) library(&quot;here&quot;) library(&quot;ggplot2&quot;) ## Hello world print(&quot;Soy Leo&quot;) ## Crear directorio para las figuras dir.create(here::here(&quot;figuras&quot;), showWarnings = FALSE) ## Hacer una imagen de ejemplo pdf(here::here(&quot;figuras&quot;, &quot;mtcars_gear_vs_mpg.pdf&quot;), useDingbats = FALSE ) ggplot(mtcars, aes(group = gear, y = mpg)) + geom_boxplot() dev.off() ## Para reproducir mi código options(width = 120) sessioninfo::session_info() Configura usethis con GitHub vía https://usethis.r-lib.org/articles/articles/git-credentials.html ## Para poder conectar tu compu con GitHub usethis::create_github_token() ## Abrirá una página web, escoje un nombre único ## y luego da click en el botón verde al final. Después copia el token ## (son 40 caracteres) gitcreds::gitcreds_set() ## Ojo, copia el token, no tu password de git! ## Si no, terminaras en la situación descrita en ## https://github.com/r-lib/usethis/issues/1347 ## Configura tu usuario de GitHub usethis::edit_git_config() # [user] # name = Leonardo Collado Torres # email = lcolladotor@gmail.com ## Para inicializar el repositorio de Git usethis::use_git() ## Para conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Resultado ejemplo: https://github.com/lcolladotor/cdsb2021_scRNAseq_notas. El que hice en vivo está disponible vía https://github.com/lcolladotor/cdsb2021_scRNAseq_notas_en_vivo (o https://github.com/lcolladotor/rnaseq_2021_notas_en_vivo para un ejemplo de febrero 2021). Una vez que termines, agrega la liga al repositorio con tus notas del curso en el Google Sheet del curso. (De ser necesario, pide permisos para editar el archivo.) 1.4 Material del curso Pueden descargar la versión estática con usethis::use_course('ComunidadBioInfo/cdsb2021_scRNAseq') Pueden verlo en línea a través de ComunidadBioInfo.github.io/cdsb2021_scRNAseq Pueden clonarlo desde GitHub de tal forma que podrán actualizarlo fácilmente usando git pull git clone https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git ## Si tienen su SSH key configurarda pueden usar ## Info sobre SSH keys de GitHub: ## https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent git clone git@github.com:ComunidadBioInfo/cdsb2021_scRNAseq.git O desde R con: ## Opción más nueva: library(&quot;gert&quot;) repo &lt;- git_clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) setwd(repo) ## Otra opción: git2r::clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) 1.5 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:15:47 UTC&quot; proc.time() ## user system elapsed ## 0.407 0.145 0.438 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["ejercicio-usando-usethis-here-y-postcards.html", "2 Ejercicio usando usethis, here y postcards 2.1 here 2.2 usethis 2.3 Vinculando RStudio con Git y GitHub 2.4 Ejercicio postcards 2.5 Detalles de la sesión de R Patrocinadores", " 2 Ejercicio usando usethis, here y postcards Instructoras: Elisa Márquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres 2.1 here Este paquete es bastante útil El directorio que toma como base será en el que nos encontremos al momento de cargar el paquete here, heuristicamente busca la raíz del proyecto y se posiciona en él. # se descargó previamente, así que solo se carga library(&quot;here&quot;) # busca la raiz del proyecto en el que se encuentre En ciertas ocasiones puede haber algun error, ya que puede chocar con otros paquetes (como plyr). para evitar esto podemos usar here::here (que básicamente aclara que la función solicitada es del paquete here) here::here() Podemos checar en qué directorio nos encontramos con getwd(), si no es el que deseamos podemos cambiarlo con setwd() getwd() # regresa la path en donde nos encontramos setwd(&quot;direccion/deseada&quot;) # nos lleva a la path indicada Pero con here podemos no especificar la path getwd() # para checar en donde nos encontramos here::here() # para checar dónde te encuentras # nos movemos al subdirectorio R setwd(here::here(&quot;R&quot;)) # podemos cambiar de directorio, aun así `here está en la raíz A continuación ofrecemos algunos ejemplos de cómo podría emplearse here::here # como ejemplo: vamos a guardar datos en archivo y cargarlos a &lt;- 1 c &lt;- 23 save(a, c, file = here::here(&quot;datos-prueba.RData&quot;)) # rm(a,c) load(here::here(&quot;datos-prueba.RData&quot;)) # creamos un directorio dir.create(here::here(&quot;subdirectorio&quot;), showWarnings = FALSE) # podemos crear un archivo, indicando el subdirectorio, (en este caso el primer argumento) file.create(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # abrimos el nuevo archivo creado file.show(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # podemos editarlo!! # por ejemplo si quisieramos ver nuestros archivos del directorio list.files(here::here(), recursive = TRUE) 2.2 usethis manual de usuario usethis puede ser más amigable, por ejemplo para la creación de nuevos archivos .R es capaz de agruparlos en la carpeta R (dando un orden al proyecto) usethis::use_r(&quot;notas-prueba.R&quot;) # no importando en qué path estemos En el siguiente ejercicio veremos algunos usos de usethis 2.3 Vinculando RStudio con Git y GitHub Ahora vamos a vincular nuestro proyecto de Rstudio con Github, esto es muy util para tener un control de nuestros archivos, poder compartirlos o usar el de otrxs 2.3.1 Prerrequisitos Debemos tener una cuenta de Github. Si no tienes este es el momento para crear una cuenta! https://docs.github.com/es/github/getting-started-with-github/signing-up-for-github/signing-up-for-a-new-github-account También debemos instalar git en nuestras computadoras ya que el paquete gitcreds lo requiere https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Despues de instalar git debemor reiniciar nuestro RStudio para que pueda anexarse Y la instalación de los siguientes paquetes: # paquetes que vamos a requerir install.packages(c(&quot;gitcreds&quot;, &quot;gert&quot;, &quot;gh&quot;)) # cargarlos de manera separada library(&quot;gitcreds&quot;) library(&quot;gert&quot;) library(&quot;gh&quot;) 2.3.2 Creando token de acceso personal (PAT) Para conectar nuestro repositorio de Rstudio con Github solicitamos un token, esto para que github otorgue permiso a nuestra computadora Emplearemos el siguiente bloque de código para solicitar dicho token (elige un nombre significativo) Otra manera de solicitar el token es ingresando a https://github.com/settings/tokens, esta opción no dará una recomendación de los parámetros a seleccionar El parámetro de expiración del token puede cambiarse para que no expire (por seguridad no lo recomienda Github), de otra manera considera su tiempo de vigencia Una vez generado el token debes guardarlo, pues no volverá a aparecer. Siempre puedes volver a generar uno nuevo (no olvides borrar el token anterior) # Para iniciar conexión con GitHub usethis::create_github_token() # redirige a github donde eligiras nombre especifico del token # copia el token para después ingresarlo con gitcreds_set() gitcreds::gitcreds_set() # aquí colocas el token (NO tu contraseña de github!!!) NOTA: en el comando gitcreds::gitcreds_set() NO debemos poner nuestro token entre parentesis, sino que al ejecutar el comando la misma función nos pedirá ingresar el token El siguiente paso será configurar nuestro usuario de github en el archivo .gitconfig # Configurar usuario de gitHub usethis::edit_git_config() # que abre el archivo .gitconfig # colocaremos nombre y correo de cuenta de github. SOLO borrar los # y respetar los demas espacios # [user] # name = N O M B R E # email = correodeGithub 2.3.3 Inicializar repositorio de Git y Github Ahora vamos a inicializar el repositorio en Git (de manera local en tu computadora) y enseguida solicitamos que se conecte con los servidores de Github # inicializar el repositorio de Git usethis::use_git() # # conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Git es el software mientras que GitHub es la plataforma web (basada en Git) que permite la colaboración LISTO!! Comando útil para checar configuración gh::gh_whoami() # para checar cómo quedó la configuración 2.3.4 Probar otros comandos de gert Una vez que ya vinculamos nuestro repositorio con github podemos seguir actualizandolo. Vamos a checar brevemente algunos de los comandos que son útiles para ello: Checaremos git_add, git_commit, git_log y git_push # escribimos un nuevo archivo, volvemos a usar here::here para especificar path writeLines(&quot;hola&quot;, here::here(&quot;R&quot;, &quot;prueba-here.R&quot;)) # otra manera es usar use_r usethis::use_r(&quot;archivo-prueba-github.R&quot;) # añade archivo al directorio R del proyecto actual # Por ejemplo podríamos probar añadir algo nuevo gert::git_add(&quot;R/archivo-prueba-github.R&quot;) # añadimos commit de lo que se hizo gert::git_commit(&quot;se subio archivo prueba&quot;) # nos da info de los commits gert::git_log() # sube tus cambios del repo local a los de github gert::git_push() # COMANDO IMPORTANTE Puede ser más amigable usar el recuadro de Git que aparece en RStudio para hacer todo lo anterior! Recuerden subir sus repositorios al Google Sheet 2.4 Ejercicio postcards Similar a https://pages.github.com/ postcards tiene 4 templados de páginas web https://github.com/seankross/postcards Tu página web debe describir decir algo sobre ti, tus intereses, y tus proyectos además de cómo contactarte Ejemplo https://amy-peterson.github.io/ vía https://github.com/amy-peterson/amy-peterson.github.com http://jtleek.com/ vía https://github.com/jtleek/jtleek.github.io http://aejaffe.com/ vía https://github.com/andrewejaffe/andrewejaffe.github.io 2.4.1 Crear el repositorio Podemos crearlo desde RStudio o desde github.com (opción 1) Desde RStudio ¡Cuidado!: Antes de crear un proyecto, revisen dónde están parados (getwd()) en su directorio y dónde quieren que se cree ## Creen el RStudio project. Es MUY importante que el usuario debe sea igual que en github usethis::create_project(&quot;Su_Usuario.github.io&quot;) Nuevo proyecto : git user ## Configura Git y GitHub # Con use_git() preguntará si desean hacer un commit, y después pedirá reiniciar Rstudio para que obtengan un nuevo botón llamado &quot;git()&quot; usethis::use_git() Nuevo botón button_git usethis::use_github() Creen su templado usando postcards corriendo una de las 4 líneas (la que tenga el templado que más les gustó). Va a crear un archivo index.Rmd ## Solo uno de estos, de acuerdo al templado que más les gustó postcards::create_postcard(template = &quot;jolla&quot;) postcards::create_postcard(template = &quot;jolla-blue&quot;) postcards::create_postcard(template = &quot;trestles&quot;) postcards::create_postcard(template = &quot;onofre&quot;) (opción 2) Desde github Creen un nuevo repositorio, público y sin archivo README en https://github.com/new llamado “usuario.github.io” con su nombre exacto en github ¡Cuidado! El repositorio debe ser público y sin README Creen un nuevo proyecto en RStudio: File &gt; New_project &gt; New directory &gt; Postcards Website Elijan el templado que más les gustó Ya con el proyecto creado, hay que configurar git y github ## Configura Git y GitHub # Con use_git() preguntará si desean hacer un commit, y después pedirá reiniciar Rstudio para que obtengan un nuevo botón llamado &quot;git()&quot; usethis::use_git() Nuevo botón: button_git Ahora que tienen el botón Git, hagan click y en la esquina derecha habrá un símbolo con dos rectángulos morados y un rombo blanco, denle click. button_branch Ahora el botón Add Remote y ahí podrán nombrar este acceso remoto como gusten, y agregar la URL de su repositorio en github. Da click en Add y después asignen el nombre de rama master Ahora pueden crear la rama, y sobreescribir el acceso cuando se los pregunte. 2.4.2 Modificar y subir a github nuestro postcard Ya que hayan creado con cualquiera de las 2 opciones anteriores pueden continuar: Llenen su información usando el formato Markdown. Por ejemplo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L17-L31. Agreguen sus perfiles estilo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L7-L12 Den click en el botón azul de knit en RStudio. Es equivalente a rmarkdown::render(\"index.Rmd\"). Esto creará el archivo index.html. Hagan un commit para guardar los archivos nuevos incluyendo index.html y luego un push para subir los archivos a GitHub con alguna de las siguientes dos maneras: (opción 1) Botón de Git * Para guardar los archivos nuevos, incluyendo index.html, debemos hacer un commit. Podemos hacerlo con el nuevo botón de git, primero seleccionando los archivos: add_file Cuando hayamos seleccionado todos los archivos, veremos que la columna Status cambia a una “A” de agregado o added y podemos darle al botón Commit justo arriba de Status. Esto abrirá una nueva pestaña donde podremos poner un mensaje sobre nuestro commit y después darle al botón Commit. button_git Una vez terminado, en esa misma pantalla podemos darle un push para subir los archivos a GitHub con el botón de Push con una flecha verde arriba de Commit message. (opcion 2) Línea de comandos Otra manera de hacer es vía línea de comandos, primero pueden agregar los archivos con gert::git_add() o hacer directamente un commit de todos los archivos y luego un pull: ## Guardamos los archivos nuevos con el commit gert::git_commit_all(&quot;mensaje sobre el commit&quot;) ## Subimos los archivos a github gert::git_push() (extra) . Pueden copiar y pegar emojis en sus páginas o utilizar fontawesome para agregar diferentes símbolos (como github o twitter): En código YAML # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en código YAML y_fawesome Se ve así: fawesome En el texto # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en el texto tfawesome (opcional). Anuncien su nueva página web en Twitter usando el hashtag #rstats y/o etiquen al autor de postcards https://twitter.com/seankross. Pueden después incluir su página web en su introducción en el canal #bienvenida del Slack de la CDSB ^^. Recuerden subir sus repositorios al Google Sheet Acá podemos ver varias de las páginas web que hicieron lxs participantes del taller. En el taller de #scRNAseq aprendimos a usar #postcards de @seankross y #usethis de @JennyBryan @jimhester_ et al para hacer páginas web✨El objetivo: aumentar la presencia de Latinxs en la red 🌐Instructoras 🦆: Elisa @naielisha y @argininaa #rstatsEShttps://t.co/O6AoxRqp6o pic.twitter.com/rGWb1l38hk — ComunidadBioInfo (@CDSBMexico) August 13, 2021 2.5 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:15:47 UTC&quot; proc.time() ## user system elapsed ## 0.544 0.141 0.570 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducción-a-rna-seq-de-célula-única-scrna-seq-con-bioconductor-y-al-libro-de-osca.html", "3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA 3.1 Bioconductor 3.2 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA 3.3 Detalles de la sesión de R Patrocinadores", " 3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Instructoras: Elisa Márquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres y de Original Notes in English 3.1 Bioconductor CRAN, the R package repository: https://cran.r-project.org/ CRAN task views: https://cran.r-project.org/web/views/ “Bioconductor proporciona herramientas para el análisis y la comprensión de datos genómicos de alto rendimiento. Bioconductor utiliza el lenguaje de programación estadístico R y es de código abierto y desarrollo abierto. Tiene dos lanzamientos cada año y una comunidad de usuarios activa. Bioconductor también está disponible como AMI (Imagen de máquina de Amazon) e imágenes de Docker.” https://www.bioconductor.org/ Where do I start using Bioconductor? http://lcolladotor.github.io/2014/10/16/startbioc/#.XqxNGRNKiuo Básicamente es un repositorio con reglas o estándares para el análisis y la comprensión de datos genómicos de alto rendimiento. Para conocer sobre Bioconductor podemos ir a: https://www.bioconductor.org/ y dar click en About 3.1.1 Equipos y consejos Es conformado por diversos equipos y consejos (Asesores científicos, técnicos y de la comunidad). Por ejemplo Leonardo Collado. Científicos : Proporciona orientación externa y supervisión de la dirección científica del proyecto y está compuesto por líderes en el análisis estadístico de datos genómicos. Técnicos: Desarrollar estrategias para asegurar que la parte técnica de la infraestructura sea apropiada a largo plazo (manejo de paquetes, sitio web, slack, etc) Comunidad : Empoderar a las comunidades de usuarios y desarrolladores mediante la coordinación de actividades de capacitación y divulgación. Dentro del equipo core que mantiene a Bioconductor y apoya con las dudas (https://www.bioconductor.org/about/core-team/) hay gente a la que Bioconductor le paga por mantener los repositorios, lo cual lo hace diferente de CRAN. El tener gente que oficialmente sabe cómo ayudarte y tiene el tiempo para hacerlo crea una mejor experiencia para los usuarios y los desarrolladores. 3.1.2 Encontrando paquetes de Bioconductor Tipos de paquetes Hay 4 tipos de paquetes que aceptan Software: tipo principal de paquete BioC, en su mayoría aportado por el usuario. Es un paquete con un tipo de análisis específico. Algunos los hacen gente pagada directamente por Bioconductor Annotation: facilita la interacción con bases de datos genómicas muy utilizadas Experiment: contienen datos para algún artículo o datos que se usan en ejemplos más exhaustivos, en su mayoría aportados por el usuario. ~&lt;5 Mb Workflows: demuestran como puedes usar varios paquetes de Bioconductor para ciertos tipos de análisis Para descubrir paquetes: Software: http://bioconductor.org/packages/release/bioc/ Annotation: http://bioconductor.org/packages/release/data/annotation/ Experiment Data: http://bioconductor.org/packages/release/data/experiment/ Workflows: http://bioconductor.org/packages/release/workflows/ Las listas de cada tipo de paquete se ven algo así: Package Maintainer Title Nombre del paquete Quién lo mantiene Título completo recount3 Leonardo Collado-Torres Explore and download data from the recount3 project Paquetes de R de Leo: https://lcolladotor.github.io/pkgs/ Sin embargo, estas listas no son muy amigables si queremos explorar por lo que podemos usar biocViews Encontrando paquetes a través de biocViews: http://bioconductor.org/packages/release/BiocViews.html#___Software Estructura tipo árbol Son 4 árboles principales: software, annotation, experiment, workflow Dentro de cada árbol, un paquete puede ser parte de varias ramas, por ejemplo, recount3 está dentro de todas estas ramas: Software AssayDomain GeneExpression BiologicalQuestion DifferentialExpression Coverage Infrastructure DataImport Technology Sequencing RNASeq Tiene una búsqueda de texto simple Ejemplo: Software → WorkflowStep → Visualization → http://bioconductor.org/packages/release/BiocViews.html#___Visualization (486 paquetes en BioC 3.11 abril-octubre 2020, 506 en BioC 3.12 octubre 2020-abril 2021, 529 en BioC 3.13 agosto 2021) 3.1.3 Estructura de un paquete de BioC Usa https://bioconductor.org/packages/&lt;pkg_name&gt; Ejemplo: https://bioconductor.org/packages/recount Otro ejemplo: https://bioconductor.org/packages/SummarizedExperiment Badges (etiquetas): rápidamente podemos evaluar como está : ¿En qué plataformas funciona? : ¿Qué tan descargado es? : ¿Se han hecho preguntas del paquete en los últimos 6 meses? (respondidas/hechas) : ¿Cuánto tiempo lleva en Bioconductor? : ¿Funciona en las máquinas de bioconductor? : ¿Cuándo fue la última vez que lo actualizaron? : Número de dependencias recursivas necesarias para instalar el paquete Parráfo de descripción del paquete Cómo citar al paquete de Bioconductor Cómo instalarlo. Más detalles en http://bioconductor.org/install/ Documentación Una líga por cada vignette en formato PDF o HTML. Es la documentación principal! Una vignette es donde lxs autores del paquete explican cómo usar las diferentes funciones del paquete y en qué orden Detalles Términos de biocViews Cómo se relaciona a otros paquetes (depends, imports, linking to, suggests, depends on me, …) URL: donde puedes encontrar el código fuente (nos puede dar más infor) BugReports: donde puedes pedir ayuda Más detalles sobre el paquete Estadísticas de descargas 3.1.4 Las dos ramas de Bioconductor: release y devel Dos ramas release, actualmente 3.13 devel, actualmente 3.14 Bioconductor version 3.14 (Development) https://bioconductor.org/packages/devel/BiocViews.html#___Software Ejemplo: http://bioconductor.org/packages/devel/bioc/html/recount.html Bioconductor tiene es actualizado cada 6 meses (abril y octubre). R lo actualizan 1 vez al año (abril). Todo el software lo prueban en macOS, Windows y linux Ejemplo: http://bioconductor.org/checkResults/release/bioc-LATEST/recount/ y http://bioconductor.org/checkResults/devel/bioc-LATEST/recount/ Resumen BioC 3.13 http://bioconductor.org/news/bioc_3_13_release/ Blog post en LIBD rstats club: Quick overview on the new Bioconductor 3.8 release http://research.libd.org/rstatsclub/2018/11/02/quick-overview-on-the-new-bioconductor-3-8-release/ 3.1.5 Cursos y eventos http://bioconductor.org/help/events/ http://bioconductor.org/help/course-materials/ BioC2021: conferencia principal anual https://bioc2021.bioconductor.org/ Talleres del BioC2019: https://rebrand.ly/biocworkshops2019 Teach online data science, bioinformatics, or other computational skills interactively using the Orchestra platform:https://t.co/r4aJ2xAZbh Nearly 50 workshop environments preloaded with #jupyter, #rstudio, #shell. #rstats, or #python.@NIHSTRIDES @NIHDataScience @Bioconductor pic.twitter.com/HyWVLBJxGU — Sean Davis (@seandavis12) January 10, 2021 Talleres de la CDSB, como los talleres de CDSB 2020: https://comunidadbioinfo.github.io/post/cdsb2020-building-workflows-with-rstudio-and-scrnaseq-with-bioconductor/#.XmJT-Z-YU1I 3.1.6 Comunidad Slack: https://bioc-community.herokuapp.com/ Sitio web de ayuda: https://support.bioconductor.org/ Usa la(s) etiqueta(s) adecuada(s) para que lxs autores de los paquetes reciban email de forma automática Pueden revisar ese sitio web y usarlo para aprender cómo en https://lcolladotor.github.io/bioc_team_ds/helping-others.html#bioconductor-support-practice-grounds Twitter: https://twitter.com/bioconductor 3.2 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA link a diapositivas 3.3 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:15:48 UTC&quot; proc.time() ## user system elapsed ## 0.395 0.118 0.399 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["estructura-e-importe-de-datos.html", "4 Estructura e importe de datos 4.1 Preprocesamiento de datos 4.2 Estructura de SingleCellExperiment 4.3 Ejercicio 1 4.4 Breve repaso de R 4.5 Ejercicio 2 4.6 Import data 4.7 Detalles de la sesión de R Patrocinadores", " 4 Estructura e importe de datos Instructoras: Elisa Márquez Zavala, Citlali Gil Aguillon. Contenido adaptado de CDSB2020: Introducción a scRNA-seq, estructura e importe de datos de Leonardo Collado Torres. 4.1 Preprocesamiento de datos 4.1.1 Cell Ranger cellranger es un pipeline que provee 10x Genomics para procesar datos de scRNA-seq generados con la tecnología de Chromium de 10x Genomics cellranger count procesa los datos crudos de FASTQ y genera los archivos que podemos leer en R usando DropletUtils::read10xCounts(). 4.1.2 scPipe scPipe es otro pipeline para procesar datos crudos (en formato FASTQ) de tecnologías de scRNA-seq. Funciona para varias tecnologías y usa Rsubread para el paso de alineamiento. we developed scPipe, an R/Bioconductor package that integrates barcode demultiplexing, read alignment, UMI-aware gene-level quantification and quality control of raw sequencing data generated by multiple protocols that include CEL-seq, MARS-seq, Chromium 10X, Drop-seq and Smart-seq. Fuente: Tian et al, PLoS Comput Biol., 2018. 4.1.3 Etc Hay muchos pipelines para procesar datos de scRNA-seq, porque a diferencia de bulk RNA-seq, en scRNA-seq hay muchas tecnologías en el mercado. Aunque tal vez la más común es la de 10x Genomics Chromium. 4.2 Estructura de SingleCellExperiment Dentro del curso -y más ampliamente dentro de los análisis de scRNA-seq en R- emplearemos la clase SingleCellExperiment . Además recordemos que la interoperabilidad dentro de los paquetes de Bioconductor hará que facilmente puedas ajustarte más facilmente a otros paquetes que vayamos encontrando útiles (la infraestructura de los dato nos seguirá sirviendo!). Podríamos dividir esta clase en cuatro categorias: datos primarios y transformados (donde estaran lo) metadata de datos (información de los genes o features, de las células y del experimento) reduccion de dimensiones experimentos alternativos Todo lo anterior está ligado, por lo que hace más sencillo el manejo de subsets de interés por ejemplo si nos interesa los genes x,y,z podríamos solicitarlos y con ello traer la información de las demás tablas Examinaremos cada una de estas partes a detalle Usaremos las diapositivas de Peter Hickey para explicar la clase SingleCellExperiment en las siguientes diapositivas. A la par se demostrará el siguiente código. 4.3 Ejercicio 1 The A. T. L. Lun et al. (2017) dataset contains two 96-well plates of 416B cells (an immortalized mouse myeloid progenitor cell line), processed using the Smart-seq2 protocol (Picelli et al. 2014). A constant amount of spike-in RNA from the External RNA Controls Consortium (ERCC) was also added to each cell’s lysate prior to library preparation. High-throughput sequencing was performed and the expression of each gene was quantified by counting the total number of reads mapped to its exonic regions. Similarly, the quantity of each spike-in transcript was measured by counting the number of reads mapped to the spike-in reference sequences. Fragmento obtenido de https://bioconductor.org/books/release/OSCA/lun-416b-cell-line-smart-seq2.html library(&quot;scRNAseq&quot;) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) # Carga el paquete SingleCellExperiment library(&quot;SingleCellExperiment&quot;) &quot;Primera parte aquí checamos el slot assays&quot; ## [1] &quot;Primera parte\\naquí checamos el slot assays&quot; # Extrae la matriz de cuentas del set de datos de 416b counts.416b &lt;- counts(sce.416b) # CHEQUEMOS clase y dimensiones class(counts.416b) # es matriz ## [1] &quot;matrix&quot; &quot;array&quot; dim(counts.416b) # indicará genes y células ## [1] 46604 192 # CONSTRUIR un nuevo objeto SCE de la matriz de cuentas !!!!!! sce &lt;- SingleCellExperiment(assays = list(counts = counts.416b)) # Revisa el objeto que acabamos de crear sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(1): counts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(0): ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 38.26031 B # Accesa la matriz de cuenta del compartimento (slot) &quot;assays&quot; # assays(sce, &quot;counts&quot;) # OJO: ¡esto puede inundar tu sesión de R! # 1. El método general assay(sce, &quot;counts&quot;)[110:115, 1:3] # gene, cell ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 8 ## ENSMUSG00000046334 2 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 63 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 0 ## ENSMUSG00000046334 3 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 21 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 19 ## ENSMUSG00000025915 1 ## ENSMUSG00000046334 15 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 17 # 2. El método específico para accesar la matriz de cuentas &quot;counts&quot; counts(sce)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 8 ## ENSMUSG00000046334 2 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 63 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 0 ## ENSMUSG00000046334 3 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 21 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 19 ## ENSMUSG00000025915 1 ## ENSMUSG00000046334 15 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 17 # AGREGAR MAS ASSAYS sce &lt;- scater::logNormCounts(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(1): sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 106.5302 B # 1. El método general assay(sce, &quot;logcounts&quot;)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 3.557154 ## ENSMUSG00000046334 1.884687 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 6.423258 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 0.000000 ## ENSMUSG00000046334 2.087367 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 4.569735 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 4.3052563 ## ENSMUSG00000025915 0.9912494 ## ENSMUSG00000046334 3.9835488 ## ENSMUSG00000088916 0.0000000 ## ENSMUSG00000046101 0.0000000 ## ENSMUSG00000098234 4.1533513 # 2. El método específico para accesar la matriz de cuentas # transformadas &quot;logcounts&quot; logcounts(sce)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 3.557154 ## ENSMUSG00000046334 1.884687 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 6.423258 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 0.000000 ## ENSMUSG00000046334 2.087367 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 4.569735 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 4.3052563 ## ENSMUSG00000025915 0.9912494 ## ENSMUSG00000046334 3.9835488 ## ENSMUSG00000088916 0.0000000 ## ENSMUSG00000046101 0.0000000 ## ENSMUSG00000098234 4.1533513 # agregemos un assay mas, esta vez de manera manual assay(sce, &quot;counts_100&quot;) &lt;- assay(sce, &quot;counts&quot;) + 100 # suma 100 a counts assay # Enumera los &quot;assays&quot; en el objeto assays(sce) # indica num y nombre de assays ## List of length 3 ## names(3): counts logcounts counts_100 assayNames(sce) # solo nos dará los nombres de los assays ## [1] &quot;counts&quot; &quot;logcounts&quot; &quot;counts_100&quot; # assay(sce, &quot;counts_100&quot;)[110:115, 1:3] ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 174.7981 B &quot;segunda parte: aquí checaremos metadata de las células&quot; ## [1] &quot;segunda parte:\\naquí checaremos metadata de las células&quot; # Extrae la información de las muestras (metadata) del set de datos de 416b colData.416b &lt;- colData(sce.416b) # podemos checar objeto en la cajita de environment de RStudio!! # explorar datooos table(colData.416b$phenotype) ## ## induced CBFB-MYH11 oncogene expression wild type phenotype ## 96 96 table(colData.416b$block) # fue en varios dias? ## ## 20160113 20160325 ## 96 96 # Agrega algo de esa información a nuestro objeto de SCE colData(sce) &lt;- colData.416b[, c(&quot;phenotype&quot;, &quot;block&quot;)] # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(3): counts logcounts counts_100 ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(2): phenotype block ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): # Accesa a la información de las muestras (metadata) en nuestro SCE colData(sce) # usar head? ## DataFrame with 192 rows and 2 columns ## phenotype block ## &lt;character&gt; &lt;integer&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. 20160113 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. 20160113 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 wild type phenotype 20160325 # Accesa una columna específica de la información de las muestras (metadata) table(sce$block) ## ## 20160113 20160325 ## 96 96 table(colData(sce)$block) # otra manera ## ## 20160113 20160325 ## 96 96 # Ejemplo de una función que agrega columnas nuevas al colData sce &lt;- scater::addPerCellQC(sce.416b) # añade datos de control de calidad # Accesa a la información de las muestras (metadata) en nuestro SCE actualizado colData(sce) ## DataFrame with 192 rows and 18 columns ## Source Name cell line ## &lt;character&gt; &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S502.C.. 416B ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C.. 416B ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S504.C.. 416B ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C.. 416B ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S506.C.. 416B ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S505... 416B ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S506... 416B ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S507... 416B ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S508... 416B ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S517... 416B ## cell type ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 embryonic stem cell ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 embryonic stem cell ## single cell well quality ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 OK ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 OK ## genotype ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## phenotype strain ## &lt;character&gt; &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 wild type phenotype B6D2F1-J ## spike-in addition block sum ## &lt;character&gt; &lt;integer&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 865936 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1076277 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1180138 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1342593 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1668311 ## ... ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 Premixed 20160325 776622 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 Premixed 20160325 1299950 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 Premixed 20160325 1800696 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 Premixed 20160325 46731 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 Premixed 20160325 1866692 ## detected altexps_ERCC_sum ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 7618 65278 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 7521 74748 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 8306 60878 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 8143 60073 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7154 136810 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 8174 61575 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 8956 94982 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 9530 113707 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 6649 7580 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 10964 48664 ## altexps_ERCC_detected ## &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 39 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 40 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 42 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 42 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 44 ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 39 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 41 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 40 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 44 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 39 ## altexps_ERCC_percent altexps_SIRV_sum ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 6.80658 27828 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 6.28030 39173 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 4.78949 30058 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 4.18567 32542 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7.28887 71850 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 7.17620 19848 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 6.65764 31729 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 5.81467 41116 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 13.48898 1883 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 2.51930 16289 ## altexps_SIRV_detected ## &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7 ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 7 ## altexps_SIRV_percent total ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 2.90165 959042 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 3.29130 1190198 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 2.36477 1271074 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 2.26741 1435208 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 3.82798 1876971 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 2.313165 858045 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 2.224004 1426661 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 2.102562 1955519 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 3.350892 56194 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 0.843271 1931645 # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(1): counts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(18): Source Name cell line ... altexps_SIRV_percent total ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 39.47633 B ## Agrega las cuentas normalizadas (lognorm) de nuevo sce &lt;- scater::logNormCounts(sce) ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 107.7463 B # Ejemplo: obtén el subconjunto de células de fenotipo &quot;wild type&quot; # Acuérdate que las células son columnas del SCE !!!! sce[, sce$phenotype == &quot;wild type phenotype&quot;] ## class: SingleCellExperiment ## dim: 46604 96 ## metadata(0): ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(96): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S504.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV &quot;Tercera parte: examinaremos metadata de features (rowData)&quot; ## [1] &quot;Tercera parte:\\nexaminaremos metadata de features (rowData)&quot; # Accesa la información de los genes de nuestro SCE # ¡Está vació actualmente! rowData(sce) ## DataFrame with 46604 rows and 1 column ## Length ## &lt;integer&gt; ## ENSMUSG00000102693 1070 ## ENSMUSG00000064842 110 ## ENSMUSG00000051951 6094 ## ENSMUSG00000102851 480 ## ENSMUSG00000103377 2819 ## ... ... ## ENSMUSG00000094621 121 ## ENSMUSG00000098647 99 ## ENSMUSG00000096730 3077 ## ENSMUSG00000095742 243 ## CBFB-MYH11-mcherry 2998 # Ejemplo de una función que agrega campos nuevos en el rowData sce &lt;- scater::addPerFeatureQC(sce) # Accesa a la información de las muestras (metadata) en nuestro SCE actualizado rowData(sce) ## DataFrame with 46604 rows and 3 columns ## Length mean detected ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000102693 1070 0.0000000 0.000000 ## ENSMUSG00000064842 110 0.0000000 0.000000 ## ENSMUSG00000051951 6094 0.0000000 0.000000 ## ENSMUSG00000102851 480 0.0000000 0.000000 ## ENSMUSG00000103377 2819 0.0104167 0.520833 ## ... ... ... ... ## ENSMUSG00000094621 121 0.0 0 ## ENSMUSG00000098647 99 0.0 0 ## ENSMUSG00000096730 3077 0.0 0 ## ENSMUSG00000095742 243 0.0 0 ## CBFB-MYH11-mcherry 2998 50375.7 100 ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.4578 B # Descarga los archivos de anotación de la base de datos de Ensembl # correspondientes usando los recursos disponibles vía AnnotationHub library(&quot;AnnotationHub&quot;) ah &lt;- AnnotationHub() query(ah, c(&quot;Mus musculus&quot;, &quot;Ensembl&quot;, &quot;v97&quot;)) ## AnnotationHub with 1 record ## # snapshotDate(): 2021-05-18 ## # names(): AH73905 ## # $dataprovider: Ensembl ## # $species: Mus musculus ## # $rdataclass: EnsDb ## # $rdatadateadded: 2019-05-02 ## # $title: Ensembl 97 EnsDb for Mus musculus ## # $description: Gene and protein annotations for Mus musculus based on Ensem... ## # $taxonomyid: 10090 ## # $genome: GRCm38 ## # $sourcetype: ensembl ## # $sourceurl: http://www.ensembl.org ## # $sourcesize: NA ## # $tags: c(&quot;97&quot;, &quot;AHEnsDbs&quot;, &quot;Annotation&quot;, &quot;EnsDb&quot;, &quot;Ensembl&quot;, &quot;Gene&quot;, ## # &quot;Protein&quot;, &quot;Transcript&quot;) ## # retrieve record with &#39;object[[&quot;AH73905&quot;]]&#39; # Obtén la posición del cromosoma para cada gen ensdb &lt;- ah[[&quot;AH73905&quot;]] chromosome &lt;- mapIds(ensdb, keys = rownames(sce), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) rowData(sce)$chromosome &lt;- chromosome # Accesa a la información de las muestras (metadata) en nuestro SCE actualizado rowData(sce) ## DataFrame with 46604 rows and 4 columns ## Length mean detected chromosome ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;character&gt; ## ENSMUSG00000102693 1070 0.0000000 0.000000 1 ## ENSMUSG00000064842 110 0.0000000 0.000000 1 ## ENSMUSG00000051951 6094 0.0000000 0.000000 1 ## ENSMUSG00000102851 480 0.0000000 0.000000 1 ## ENSMUSG00000103377 2819 0.0104167 0.520833 1 ## ... ... ... ... ... ## ENSMUSG00000094621 121 0.0 0 GL456372.1 ## ENSMUSG00000098647 99 0.0 0 GL456381.1 ## ENSMUSG00000096730 3077 0.0 0 JH584292.1 ## ENSMUSG00000095742 243 0.0 0 JH584295.1 ## CBFB-MYH11-mcherry 2998 50375.7 100 NA ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.8135 B # Ejemplo: obtén el subconjunto de datos donde los genes están en el # cromosoma 3 # NOTA: which() fue necesario para lidear con los nombres de cromosoma # que son NA sce[which(rowData(sce)$chromosome == &quot;3&quot;), ] ## class: SingleCellExperiment ## dim: 2876 192 ## metadata(0): ## assays(2): counts logcounts ## rownames(2876): ENSMUSG00000098982 ENSMUSG00000098307 ... ## ENSMUSG00000105990 ENSMUSG00000075903 ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV &quot;Cuarta parte: examinamos slot metadata&quot; ## [1] &quot;Cuarta parte:\\nexaminamos slot metadata&quot; # Accesa la información de nuestro experimento usando metadata() # ¡Está vació actualmente! metadata(sce) ## list() # La información en el metadata() es como Vegas - todo se vale metadata(sce) &lt;- list( favourite_genes = c(&quot;Shh&quot;, &quot;Nck1&quot;, &quot;Diablo&quot;), analyst = c(&quot;Pete&quot;) ) # Accesa la información de nuestro experimento usando metadata() de # nuestro objeto actualizado metadata(sce) ## $favourite_genes ## [1] &quot;Shh&quot; &quot;Nck1&quot; &quot;Diablo&quot; ## ## $analyst ## [1] &quot;Pete&quot; &quot;Quinta parte: examinamos slot de reducción de dimensiones&quot; ## [1] &quot;Quinta parte:\\nexaminamos slot de reducción de dimensiones&quot; # Ejemplo: agrega los componentes principales (PCs) de las logcounts # NOTA: aprenderemos más sobre análisis de componentes principales (PCA) después sce &lt;- scater::runPCA(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(1): PCA ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV # Accesa la matriz de PCA del componente (slot) reducedDims reducedDim(sce, &quot;PCA&quot;)[1:6, 1:3] ## PC1 PC2 PC3 ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -18.717668 27.598132 -5.939654 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -2.480705 27.564583 -4.916567 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -42.034018 7.552435 -12.126964 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 8.494303 -31.833727 -15.760853 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 49.737390 -4.226795 -6.123169 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 44.528081 3.215503 -10.384939 # Ejemplo, agrega una representación de los logcounts en t-SNE # NOTA: aprenderemos más sobre t-SNE después sce &lt;- scater::runTSNE(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(2): PCA TSNE ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV # Accesa a la matriz de t-SNE en el componente (slot) de reducedDims head(reducedDim(sce, &quot;TSNE&quot;)) ## [,1] [,2] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -7.3181642 2.2840490 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -3.6464118 -0.8207964 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -7.6479076 4.6719923 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 0.7775377 4.4127326 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 8.0179911 -6.4277429 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 7.8965473 -7.8963465 # Ejemplo: agrega una representación &#39;manual&#39; de los logcounts en UMAP # NOTA: aprenderemos más sobre UMAP después y de una forma más sencilla de # calcularla u &lt;- uwot::umap(t(logcounts(sce)), n_components = 2) # Agrega la matriz de UMAP al componente (slot) reducedDims reducedDim(sce, &quot;UMAP&quot;) &lt;- u # Accesa a la matriz de UMAP desde el componente (slot) reducedDims head(reducedDim(sce, &quot;UMAP&quot;)) ## [,1] [,2] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -2.9007656 -1.724959 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -1.9364034 -1.711854 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -3.2449543 -1.109732 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 -0.3859376 -1.198746 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 0.2112636 -1.497831 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 -0.1741835 -1.455346 # Enumera los resultados de reducción de dimensiones en nuestro objeto SCE reducedDims(sce) ## List of length 3 ## names(3): PCA TSNE UMAP &quot;Sexta parte: experimentos alternativos&quot; ## [1] &quot;Sexta parte:\\nexperimentos alternativos&quot; # Extrae la información de ERCC de nuestro SCE para el set de datos de 416b ercc.sce.416b &lt;- altExp(sce.416b, &quot;ERCC&quot;) # Inspecciona el SCE para los datos de ERCC ercc.sce.416b ## class: SingleCellExperiment ## dim: 92 192 ## metadata(0): ## assays(1): counts ## rownames(92): ERCC-00002 ERCC-00003 ... ERCC-00170 ERCC-00171 ## rowData names(7): Length subgroup ... log2(Mix 1/Mix 2) molecules ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(0): ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): # Agrega el SCE de ERCC como un experimento alternativo a nuestro SCE altExp(sce, &quot;ERCC&quot;) &lt;- ercc.sce.416b # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(3): PCA TSNE UMAP ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.8965 B # Enumera los experimentos alternativos almacenados en nuestro objeto altExps(sce) ## List of length 2 ## names(2): ERCC SIRV # El crear un subconjunto del SCE por muestra (célula) automáticamente # obtiene el subconjunto de los experimentos alternativos sce.subset &lt;- sce[, 1:10] ncol(sce.subset) ## [1] 10 ncol(altExp(sce.subset)) ## [1] 10 ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce.subset) / 1024^2 ## En MB ## 11.99544 B &quot;Septima parte: sizefactores&quot; ## [1] &quot;Septima parte:\\nsizefactores&quot; # Extrae los factores de tamaño (size factors) # Estos fueron añadidos a nuestro objeto cuando corrimos # scater::logNormCounts(sce) head(sizeFactors(sce)) ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## 0.7427411 0.9231573 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ## 1.0122422 1.1515851 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 ## 1.4309639 0.8713409 # &quot;Automáticamente&quot; reemplaza los factores de tamaño sce &lt;- scran::computeSumFactors(sce) head(sizeFactors(sce)) ## [1] 0.6961756 0.8834223 0.9704247 0.9804890 1.2446699 0.7922620 # &quot;Manualmente&quot; reemplaza los factores de tamaño sizeFactors(sce) &lt;- scater::librarySizeFactors(sce) head(sizeFactors(sce)) ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## 0.7427411 0.9231573 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ## 1.0122422 1.1515851 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 ## 1.4309639 0.8713409 NOTA: La clase SingleCellExperimentestá basada en SummarizedExperiment, por lo que ya estamos un poco familiarizados con esta nueva clase. Una de las diferencias es que no contiene ranuras para análisis de reducción de dimensiones. (será solo datos y metadata de ellos) 4.3.1 Preguntas: ¿Cuáles son los tipos de tablas que debe siempre contenter el objeto sce? ¿Donde usamos los colnames(sce)? ¿donde usamos los rownames(sce)? 4.4 Breve repaso de R # Creamos un data.frame df &lt;- data.frame(x = c(TRUE, FALSE, NA, NA), y = c(12, 34, 56, 78)) row.names(df) &lt;- letters[1:4] df ## x y ## a TRUE 12 ## b FALSE 34 ## c NA 56 ## d NA 78 # Para acceder a los nombres de las columnas colnames(df) ## [1] &quot;x&quot; &quot;y&quot; # Para acceder a los nombres de las filas rownames(df) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; # Podemos sacar información booleana df$y &lt; 20 ## [1] TRUE FALSE FALSE FALSE # Y podemos acceder al mismo data.frame con la información booleana df[df$y &lt; 40, ] ## x y ## a TRUE 12 ## b FALSE 34 ## %in% (dentro de) bool_info &lt;- rownames(df) %in% c(&quot;a&quot;, &quot;c&quot;, &quot;z&quot;) df[bool_info, ] ## x y ## a TRUE 12 ## c NA 56 ## &amp; (y) bool_info &lt;- df$y &lt; 50 &amp; df$y &gt; 20 df[bool_info, ] ## x y ## b FALSE 34 ## | (o) bool_info &lt;- df$y &lt; 20 | df$y &gt; 60 df[bool_info, ] ## x y ## a TRUE 12 ## d NA 78 4.5 Ejercicio 2 library(&quot;SingleCellExperiment&quot;) library(&quot;scRNAseq&quot;) # Mini muestreo del set de datos usado en: https://bioconductor.org/books/release/OSCA/zeisel-mouse-brain-strt-seq.html#introduction-5 archivo_cuentas &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/min_sce.csv&quot; archivo_rowData &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/rowD.csv&quot; archivo_colData &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/colD.csv&quot; counts &lt;- read.csv(archivo_cuentas, row.names = 1, header = TRUE, check.names = F) col.data &lt;- DataFrame(read.csv(archivo_colData, row.names = 1, header = TRUE, check.names = F)) row.data &lt;- read.csv(archivo_rowData, row.names = 1, header = TRUE, check.names = F) Crea un objeto SingleCellExperiment ¿Cuántos genes tenemos? ¿Qué información tenemos en el rowData()? Extraigan los datos de los genes que nos interesan (objeto int_gen) Pasen el mouse sobre los siguientes textos para ver recomendaciones: Recomendación 1 Recomendación 2 Recomendación 3 int_gen &lt;- c(&quot;Angpt1&quot;, &quot;Chic2&quot;, &quot;Mir503&quot;, &quot;Magee2&quot;, &quot;Nenf&quot;, &quot;Eps15l1&quot;, &quot;Hsf2bp&quot;, &quot;Gnptg&quot;, &quot;Vegfb&quot;, &quot;Atmin&quot;, &quot;Gad1&quot;, &quot;Gad2&quot;, &quot;Slc32a1&quot;, &quot;Dner&quot;, &quot;Slc2a13&quot;, &quot;Slc6a1&quot;, &quot;Nrxn3&quot;) Creen un objeto llamado min_sce con los datos de solo esos genes ¿Cuáles son parte del tejido interneurons o del tejido pyramidal CA1 ? (del objeto min_sce) Recomendación 1 Recomendación 2 Recomendación 3 Con este subconjunto, crea el objeto tej_min_sce Una vez que tengan el objeto ´SingleCellExperiment´ llamado ´tej_min_sce´, corran el siguiente código. library(&quot;scater&quot;) plotHeatmap(object = tej_min_sce, features = rownames(tej_min_sce), order_columns_by = &quot;level1class&quot;) 4.5.1 Respuestas sce &lt;- SingleCellExperiment( assays = list(counts = counts), colData = col.data, rowData = row.data ) sce &lt;- scater::logNormCounts(sce) sce ## class: SingleCellExperiment ## dim: 100 30 ## metadata(0): ## assays(2): counts logcounts ## rownames(100): Olfr1219 Angpt1 ... Slc6a1 Nrxn3 ## rowData names(2): featureType Ensembl ## colnames(30): 1772066102_E02 1772067073_F10 ... 1772066096_G11 ## 1772066101_E11 ## colData names(11): tissue group.. ... level2class sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): bool_data &lt;- rownames(rowData(sce)) min_sce &lt;- sce[bool_data %in% int_gen, ] tej_int &lt;- min_sce$level1class == &quot;interneurons&quot; tej_pyr &lt;- min_sce$level1class == &quot;pyramidal CA1&quot; tej_min_sce &lt;- min_sce[, tej_int | tej_pyr] library(&quot;scater&quot;) ## Loading required package: scuttle ## Loading required package: ggplot2 plotHeatmap(object = tej_min_sce, features = rownames(tej_min_sce), order_columns_by = &quot;level1class&quot;) 4.5.2 Extra Realiza los mismos pasos, pero ahora los genes que buscamos no tienen el nombre usual de gen (Gad1), sino su Ensembl gene IDs int_gen &lt;- c(&quot;ENSMUSG00000071076&quot;, &quot;ENSMUSG00000002076&quot;, &quot;ENSMUSG00000024962&quot;, &quot;ENSMUSG00000031224&quot;, &quot;ENSMSG00000036560&quot;, &quot;ENSMUSG00000037499&quot;, &quot;ENSMUSG00000006276&quot;, &quot;ENSMUSG00000035521&quot;, &quot;ENSMUSG00000047388&quot;, &quot;ENSMUSG0000051079&quot;, &quot;ENSMUSG00000076122&quot;, &quot;ENSMUSG00000029229&quot;, &quot;ENSMUSG00000022309&quot;, &quot;ENSMUSG00000036766&quot;, &quot;ENSMUSG00000070880&quot;, &quot;ENSMUSG00000026787&quot;, &quot;ENSMUSG00000066392&quot;, &quot;ENSMUSG00000036298&quot;, &quot;ENSMUSG00000037771&quot;, &quot;ENSMUSG00000030310&quot;) 4.6 Import data Diapositivas de Peter Hickey Ve las diapositivas aquí. # Descarga datos de ejemplo procesados con CellRanger # Paréntesis: al usar BiocFileCache solo tenemos que descargar # los datos una vez. library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() pbmc.url &lt;- paste0( &quot;http://cf.10xgenomics.com/samples/cell-vdj/&quot;, &quot;3.1.0/vdj_v1_hs_pbmc3/&quot;, &quot;vdj_v1_hs_pbmc3_filtered_feature_bc_matrix.tar.gz&quot; ) pbmc.data &lt;- bfcrpath(bfc, pbmc.url) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell-vdj/3.1.0/vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_filtered_feature_bc_matrix.tar.gz&#39; # Extrae los archivos en un directorio temporal untar(pbmc.data, exdir = tempdir()) # Enumera los archivos que descargamos y que extrajimos # Estos son los archivos típicos de CellRanger pbmc.dir &lt;- file.path( tempdir(), &quot;filtered_feature_bc_matrix&quot; ) list.files(pbmc.dir) ## [1] &quot;barcodes.tsv.gz&quot; &quot;features.tsv.gz&quot; &quot;matrix.mtx.gz&quot; # Importa los datos como un objeto de tipo SingleCellExperiment library(&quot;DropletUtils&quot;) sce.pbmc &lt;- read10xCounts(pbmc.dir) # Revisa el objeto que acabamos de construir sce.pbmc ## class: SingleCellExperiment ## dim: 33555 7231 ## metadata(1): Samples ## assays(1): counts ## rownames(33555): ENSG00000243485 ENSG00000237613 ... CD127 CD15 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce.pbmc) / 1024^2 ## En MB ## 124.191 B # Almacena la información de CITE-seq como un experimento alternativo sce.pbmc &lt;- splitAltExps(sce.pbmc, rowData(sce.pbmc)$Type) # Revisa el objeto que acabamos de actualizar sce.pbmc ## class: SingleCellExperiment ## dim: 33538 7231 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: Gene Expression ## altExpNames(1): Antibody Capture ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce.pbmc) / 1024^2 ## En MB ## 124.4871 B # Descarga datos de ejemplo procesados con scPipe library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() sis_seq.url &lt;- &quot;https://github.com/LuyiTian/SIS-seq_script/archive/master.zip&quot; sis_seq.data &lt;- bfcrpath(bfc, sis_seq.url) ## adding rname &#39;https://github.com/LuyiTian/SIS-seq_script/archive/master.zip&#39; # Extrae los archivos en un directorio temporal unzip(sis_seq.data, exdir = tempdir()) # Enumera (algunos de) los archivos que descargamos y extrajimos # Estos son los archivos típicos de scPipe sis_seq.dir &lt;- file.path( tempdir(), &quot;SIS-seq_script-master&quot;, &quot;data&quot;, &quot;BcorKO_scRNAseq&quot;, &quot;RPI10&quot; ) list.files(sis_seq.dir) ## [1] &quot;gene_count.csv&quot; &quot;stat&quot; # Importa los datos como un objeto de tipo SingleCellExperiment library(&quot;scPipe&quot;) ## ## ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 sce.sis_seq &lt;- create_sce_by_dir(sis_seq.dir) ## organism/gene_id_type not provided. Make a guess: mmusculus_gene_ensembl / ensembl_gene_id # Revisa el objeto que acabamos de construir sce.sis_seq ## class: SingleCellExperiment ## dim: 19232 383 ## metadata(2): scPipe Biomart ## assays(1): counts ## rownames(19232): ENSMUSG00000079140 ENSMUSG00000081587 ... ## ENSMUSG00000036880 ENSMUSG00000106872 ## rowData names(0): ## colnames(383): A1 A10 ... P8 P9 ## colData names(7): unaligned aligned_unmapped ... mapped_to_ERCC ## mapped_to_MT ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(sce.sis_seq) / 1024^2 ## En MB ## 29.84988 B # Descarga un ejemplo de un montón de archivos library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() lun_counts.url &lt;- paste0( &quot;https://www.ebi.ac.uk/arrayexpress/files/&quot;, &quot;E-MTAB-5522/E-MTAB-5522.processed.1.zip&quot; ) lun_counts.data &lt;- bfcrpath(bfc, lun_counts.url) ## adding rname &#39;https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-5522/E-MTAB-5522.processed.1.zip&#39; lun_coldata.url &lt;- paste0( &quot;https://www.ebi.ac.uk/arrayexpress/files/&quot;, &quot;E-MTAB-5522/E-MTAB-5522.sdrf.txt&quot; ) lun_coldata.data &lt;- bfcrpath(bfc, lun_coldata.url) ## adding rname &#39;https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-5522/E-MTAB-5522.sdrf.txt&#39; # Extrae los archivos en un directorio temporal lun_counts.dir &lt;- tempfile(&quot;lun_counts.&quot;) unzip(lun_counts.data, exdir = lun_counts.dir) # Enumera los archivos que descargamos y extrajimos list.files(lun_counts.dir) ## [1] &quot;counts_Calero_20160113.tsv&quot; &quot;counts_Calero_20160325.tsv&quot; ## [3] &quot;counts_Liora_20160906.tsv&quot; &quot;counts_Liora_20170201.tsv&quot; # Lee la matriz de cuentas (para una placa) lun.counts &lt;- read.delim( file.path(lun_counts.dir, &quot;counts_Calero_20160113.tsv&quot;), header = TRUE, row.names = 1, check.names = FALSE ) # Almacena la información de la longitud de los genes para después gene.lengths &lt;- lun.counts$Length # Convierte los datos de cuentas de genez a una matriz (quitamos las longitudes) lun.counts &lt;- as.matrix(lun.counts[, -1]) # Lee la información de las muestras (células) lun.coldata &lt;- read.delim(lun_coldata.data, check.names = FALSE, stringsAsFactors = FALSE ) library(&quot;S4Vectors&quot;) lun.coldata &lt;- as(lun.coldata, &quot;DataFrame&quot;) # Pon en orden la información de las muestras para que # sea idéntico al orden en la matriz de cuentas m &lt;- match( colnames(lun.counts), lun.coldata$`Source Name` ) lun.coldata &lt;- lun.coldata[m, ] # Construye la tabla de información de los genes lun.rowdata &lt;- DataFrame(Length = gene.lengths) # Construye el objeto de SingleCellExperiment lun.sce &lt;- SingleCellExperiment( assays = list(assays = lun.counts), colData = lun.coldata, rowData = lun.rowdata ) # Revisa el objeto que acabamos de construir lun.sce ## class: SingleCellExperiment ## dim: 46703 96 ## metadata(0): ## assays(1): assays ## rownames(46703): ENSMUSG00000102693 ENSMUSG00000064842 ... SIRV7 ## CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(96): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-9555.N712_S508.C89V9ANXX.s_1.r_1 ## SLX-9555.N712_S517.C89V9ANXX.s_1.r_1 ## colData names(50): Source Name Comment[ENA_SAMPLE] ... Factor ## Value[phenotype] Factor Value[block] ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¿Qué tan grande es el objeto de R? lobstr::obj_size(lun.sce) / 1024^2 ## En MB ## 21.49744 B 4.7 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:17:33 UTC&quot; proc.time() ## user system elapsed ## 75.942 4.503 105.138 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scPipe * 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["control-de-calidad.html", "5 Control de calidad 5.1 Diapositivas de Peter Hickey 5.2 Ejercicio: entendiendo addPerCellQC 5.3 Gráficas sobre medidas de control de calidad (QC) 5.4 Eliminar células de baja calidad 5.5 Ejercicio: filtrado de células 5.6 Datos de Grun et al 5.7 Gráficas de QC extra 5.8 Ejercicio: ERCC Grun et al 5.9 Identificando droplets vacíos con datos de PBMC 5.10 Ejercicio: detección de droplets vacíos 5.11 Filtrado de expresión mitocondrial adicional 5.12 Ejercicio avanzado 5.13 Discusión ¿Conviene eliminar datos? 5.14 Explorando datos de forma interactiva con iSEE 5.15 Detalles de la sesión de R Patrocinadores", " 5 Control de calidad Instructor: Leonardo Collado Torres ## Paquetes de este capítulo library(&quot;scRNAseq&quot;) ## para descargar datos de ejemplo library(&quot;AnnotationHub&quot;) ## para obtener información de genes library(&quot;scater&quot;) ## para gráficas y control de calidad library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;DropletUtils&quot;) ## para detectar droplets library(&quot;Matrix&quot;) ## para leer datos en formatos comprimidos 5.1 Diapositivas de Peter Hickey Ve las diapositivas aquí 5.2 Ejercicio: entendiendo addPerCellQC ## Datos library(&quot;scRNAseq&quot;) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## snapshotDate(): 2021-05-18 ## loading from cache ## require(&quot;ensembldb&quot;) sce.416b$block &lt;- factor(sce.416b$block) # Descarga los archivos de anotación de la base de datos de Ensembl # correspondientes usando los recursos disponibles vía AnnotationHub library(&quot;AnnotationHub&quot;) ah &lt;- AnnotationHub() ## snapshotDate(): 2021-05-18 query(ah, c(&quot;Mus musculus&quot;, &quot;Ensembl&quot;, &quot;v97&quot;)) ## AnnotationHub with 1 record ## # snapshotDate(): 2021-05-18 ## # names(): AH73905 ## # $dataprovider: Ensembl ## # $species: Mus musculus ## # $rdataclass: EnsDb ## # $rdatadateadded: 2019-05-02 ## # $title: Ensembl 97 EnsDb for Mus musculus ## # $description: Gene and protein annotations for Mus musculus based on Ensem... ## # $taxonomyid: 10090 ## # $genome: GRCm38 ## # $sourcetype: ensembl ## # $sourceurl: http://www.ensembl.org ## # $sourcesize: NA ## # $tags: c(&quot;97&quot;, &quot;AHEnsDbs&quot;, &quot;Annotation&quot;, &quot;EnsDb&quot;, &quot;Ensembl&quot;, &quot;Gene&quot;, ## # &quot;Protein&quot;, &quot;Transcript&quot;) ## # retrieve record with &#39;object[[&quot;AH73905&quot;]]&#39; # Obtén la posición del cromosoma para cada gen ens.mm.v97 &lt;- ah[[&quot;AH73905&quot;]] ## loading from cache location &lt;- mapIds( ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) ## Warning: Unable to map 563 of 46604 requested IDs. # Identifica los genes mitocondriales is.mito &lt;- which(location == &quot;MT&quot;) library(&quot;scater&quot;) sce.416b &lt;- addPerCellQC(sce.416b, subsets = list(Mito = is.mito) ) ## Si quieres guarda los resultados de addPerCellQC() para responder ## las preguntas del ejercicio. Eventualmente si necesitaremos los ## resultados de addPerCellQC() para las secciones posteriores a este ## ejercicio. ¿Qué cambió en nuestro objeto sce después de addPerCellQC? 1 Haz una gráfica de boxplots del número de genes por bloque (block) de células. 2 5.3 Gráficas sobre medidas de control de calidad (QC) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) + scale_y_log10() plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) 5.3.1 Ejercicio: gráficas QC ERCC Adapta el código de las gráficas anteriores para otra variable de control de calidad. Por ejemplo, escribe el código para reproducir las siguientes gráficas. Basado en las gráficas encuentra la variable de colData(sce.416b) que contiene la información que queremos gráficar. ¡No hay que reemplazar todo lo que diga phenotype Tengo cuidado con las transformaciones de valores en el eje Y. No aplican para todo tipo de datos. 5.4 Eliminar células de baja calidad # Valores de límite ejemplo qc.lib &lt;- sce.416b$sum &lt; 100000 qc.nexprs &lt;- sce.416b$detected &lt; 5000 qc.spike &lt;- sce.416b$altexps_ERCC_percent &gt; 10 qc.mito &lt;- sce.416b$subsets_Mito_percent &gt; 10 discard &lt;- qc.lib | qc.nexprs | qc.spike | qc.mito # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib), NExprs = sum(qc.nexprs), SpikeProp = sum(qc.spike), MitoProp = sum(qc.mito), Total = sum(discard) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 3 0 19 14 33 ## Usando isOutlier() para determinar los valores de corte qc.lib2 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;) qc.nexprs2 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot; ) qc.spike2 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot; ) qc.mito2 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot; ) discard2 &lt;- qc.lib2 | qc.nexprs2 | qc.spike2 | qc.mito2 # Extraemos los límites de valores (thresholds) attr(qc.lib2, &quot;thresholds&quot;) ## lower higher ## 434082.9 Inf attr(qc.nexprs2, &quot;thresholds&quot;) ## lower higher ## 5231.468 Inf # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib2), NExprs = sum(qc.nexprs2), SpikeProp = sum(qc.spike2), MitoProp = sum(qc.mito2), Total = sum(discard2) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 4 0 1 2 6 ## Más pruebas plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) ## Determino el bloque (batch) de muestras batch &lt;- paste0(sce.416b$phenotype, &quot;-&quot;, sce.416b$block) ## Versión de isOutlier() que toma en cuenta los bloques de muestras qc.lib3 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.nexprs3 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.spike3 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot;, batch = batch ) qc.mito3 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot;, batch = batch ) discard3 &lt;- qc.lib3 | qc.nexprs3 | qc.spike3 | qc.mito3 # Extraemos los límites de valores (thresholds) attr(qc.lib3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 461073.1 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 399133.7 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 599794.9 370316.5 ## higher Inf Inf attr(qc.nexprs3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 5399.24 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 6519.74 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 7215.887 7586.402 ## higher Inf Inf # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib3), NExprs = sum(qc.nexprs3), SpikeProp = sum(qc.spike3), MitoProp = sum(qc.mito3), Total = sum(discard3) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 5 4 6 2 9 5.5 Ejercicio: filtrado de células ¿Fue necesario qc.lib para crear discard? 3 ¿Cúal filtro fue más estricto? ¿discard o discard2? 4 Al considerar el grupo de cada muestra (batch), ¿descartamos más células usando un valor de límite automático? 5 5.6 Datos de Grun et al ¿Qué patrón revela esta gráfica? sce.grun &lt;- GrunPancreasData() ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache sce.grun &lt;- addPerCellQC(sce.grun) ## ¿Qué patrón revela esta gráfica? plotColData(sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ¿Cúal de las siguientes gráficas identifica mejor las células de baja calidad? ## isOutlier() puede ayudarnos cuando un grupo de muestras ## tuvo más problemas que el resto discard.ercc &lt;- isOutlier(sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection discard.ercc2 &lt;- isOutlier( sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor, subset = sce.grun$donor %in% c(&quot;D17&quot;, &quot;D2&quot;, &quot;D7&quot;) ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection ## isOutlier() tomando en cuenta el batch plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ## isOutlier() tomando en cuenta batch y muestras que fallaron plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc2) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). 5.7 Gráficas de QC extra Otras gráficas que podemos hacer. # Agregamos información sobre que células # tienen valores extremos sce.416b$discard &lt;- discard2 # Haz esta gráfica para cada medida de # control de calidad (QC) plotColData( sce.416b, x = &quot;block&quot;, y = &quot;sum&quot;, colour_by = &quot;discard&quot;, other_fields = &quot;phenotype&quot; ) + facet_wrap(~phenotype) + scale_y_log10() # Otra gráfica de diagnóstico útil plotColData( sce.416b, x = &quot;sum&quot;, y = &quot;subsets_Mito_percent&quot;, colour_by = &quot;discard&quot;, other_fields = c(&quot;block&quot;, &quot;phenotype&quot;) ) + facet_grid(block ~ phenotype) 5.8 Ejercicio: ERCC Grun et al Adapta el código de sce.416b para los datos de Grun et al y reproduce la imagen siguiente. Fíjate en que variables de colData() estamos graficando. ¿Existe la variable discard en colData()? ¿Qué variable tiene valores de D10, D17, D2, D3 y D7? 5.9 Identificando droplets vacíos con datos de PBMC Descripción gráfica la tecnología Next GEM de 10x Genomics. Fuente: 10x Genomics. Opciones algorítmicas para detecar los droplets vacíos. Fuente: Lun et al, Genome Biology, 2019. ## Descarguemos los datos library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath( bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; ) ) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) ## Leamos los datos en R library(&quot;DropletUtils&quot;) library(&quot;Matrix&quot;) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) bcrank &lt;- barcodeRanks(counts(sce.pbmc)) # Mostremos solo los puntos únicos para acelerar # el proceso de hacer esta gráfica uniq &lt;- !duplicated(bcrank$rank) plot( bcrank$rank[uniq], bcrank$total[uniq], log = &quot;xy&quot;, xlab = &quot;Rank&quot;, ylab = &quot;Total UMI count&quot;, cex.lab = 1.2 ) ## Warning in xy.coords(x, y, xlabel, ylabel, log): 1 y value &lt;= 0 omitted from ## logarithmic plot abline( h = metadata(bcrank)$inflection, col = &quot;darkgreen&quot;, lty = 2 ) abline( h = metadata(bcrank)$knee, col = &quot;dodgerblue&quot;, lty = 2 ) legend( &quot;bottomleft&quot;, legend = c(&quot;Inflection&quot;, &quot;Knee&quot;), col = c(&quot;darkgreen&quot;, &quot;dodgerblue&quot;), lty = 2, cex = 1.2 ) Encontremos los droplets vacíos usando emptyDrops(). ## Usemos DropletUtils para encontrar los droplets set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) # Revisa ?emptyDrops para una explicación de porque hay valores NA summary(e.out$FDR &lt;= 0.001) ## Mode FALSE TRUE NA&#39;s ## logical 989 4300 731991 set.seed(100) limit &lt;- 100 all.out &lt;- emptyDrops(counts(sce.pbmc), lower = limit, test.ambient = TRUE) # Idealmente, este histograma debería verse uniforme. # Picos grandes cerca de cero indican que los _barcodes_ # con un número total de cuentas menor a &quot;lower&quot; no son # de origen ambiental. hist(all.out$PValue[all.out$Total &lt;= limit &amp; all.out$Total &gt; 0], xlab = &quot;P-value&quot;, main = &quot;&quot;, col = &quot;grey80&quot; ) 5.10 Ejercicio: detección de droplets vacíos ¿Por qué emptyDrops() regresa valores NA? 6 ¿Los valores p son iguales entre e.out y all.out? 7 ¿Son iguales si obtienes el subconjunto de valores que no son NA? 8 5.11 Filtrado de expresión mitocondrial adicional Después de filtar los droplets, el filtrado por expresión mitocondrial nos va a ayudar a eliminar células de baja calidad. sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] is.mito &lt;- grep(&quot;^MT-&quot;, rowData(sce.pbmc)$Symbol) sce.pmbc &lt;- addPerCellQC(sce.pbmc, subsets = list(MT = is.mito)) discard.mito &lt;- isOutlier(sce.pmbc$subsets_MT_percent, type = &quot;higher&quot;) plot( sce.pmbc$sum, sce.pmbc$subsets_MT_percent, log = &quot;x&quot;, xlab = &quot;Total count&quot;, ylab = &quot;Mitochondrial %&quot; ) abline(h = attr(discard.mito, &quot;thresholds&quot;)[&quot;higher&quot;], col = &quot;red&quot;) 5.12 Ejercicio avanzado Volvamos a crear sce.pbmc para poder usar plotColData() y visualizar la relación entre total y los niveles de expresión mitocondrial (en porcentaje) separando lo que pensamos que son droplets vacíos y las células de acuerdo a los resultados que ya calculamos de emptyDrops(). El resultado final se verá como en la siguiente imagen. No podemos usar nuestro objeto sce.pbmc porque ya eliminamos los droplets vacíos al correr sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)]. Por eso tendremos que volver a usar sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE). Una vez que hayamos vuelto a hacer sce.pbmc, tenemos que guardar en ese objeto los resultados de emptyDrops(). Por ejemplo, con sce.pbmc$is_cell &lt;- e.out$FDR &lt;= 0.001. Como e.out$FDR tiene muchos NA, nos conviene filtrar esos datos. Tendremos que volver a correr addPerCellQC() y guardar los resultados en nuestro objeto sce.pbmc. Al final usaremos plotColData() junto con facet_grid(~ sce.pbmc$is_cell). 5.13 Discusión ¿Conviene eliminar datos? # Eliminemos las células de calidad baja # al quedarnos con las columnas del objeto sce que NO # queremos descartar (eso hace el !) filtered &lt;- sce.416b[, !discard2] # Alternativamente, podemos marcar # las células de baja calidad marked &lt;- sce.416b marked$discard &lt;- discard2 ¿Cúal de estos objetos es más grande? 9 ¿Cúal prefieres usar? 10 5.13.1 Un nuevo paquete: ExperimentSubset En BioC2021 presentaron ExperimentSubset que provee otro camino para resolver este dilema. Descripción gráfica de ExperimentSubset. Fuente: vignette ExperimentSubset. 5.14 Explorando datos de forma interactiva con iSEE #rstats / @Bioconductor congrats winners of the 1st Shiny Contest: iSEE https://t.co/oHgGkWqRsJ https://t.co/vZLFvcMBIS ! — Bioconductor (@Bioconductor) April 7, 2019 http://bioconductor.org/packages/release/bioc/html/iSEE.html http://bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html ## Hagamos un objeto sencillo de tipo RangedSummarizedExperiment library(&quot;SummarizedExperiment&quot;) ## ?SummarizedExperiment ## De los ejemplos en la ayuda oficial ## Creamos los datos para nuestro objeto de tipo SummarizedExperiment ## para 200 genes a lo largo de 6 muestras nrows &lt;- 200 ncols &lt;- 6 ## Números al azar de cuentas set.seed(20210223) counts &lt;- matrix(runif(nrows * ncols, 1, 1e4), nrows) ## Información de nuestros genes rowRanges &lt;- GRanges( rep(c(&quot;chr1&quot;, &quot;chr2&quot;), c(50, 150)), IRanges(floor(runif(200, 1e5, 1e6)), width = 100), strand = sample(c(&quot;+&quot;, &quot;-&quot;), 200, TRUE), feature_id = sprintf(&quot;ID%03d&quot;, 1:200) ) names(rowRanges) &lt;- paste0(&quot;gene_&quot;, seq_len(length(rowRanges))) ## Información de nuestras muestras colData &lt;- DataFrame( Treatment = rep(c(&quot;ChIP&quot;, &quot;Input&quot;), 3), row.names = LETTERS[1:6] ) ## Juntamos ahora toda la información en un solo objeto de R rse &lt;- SummarizedExperiment( assays = SimpleList(counts = counts), rowRanges = rowRanges, colData = colData ) ## Exploremos el objeto resultante rse ## class: RangedSummarizedExperiment ## dim: 200 6 ## metadata(0): ## assays(1): counts ## rownames(200): gene_1 gene_2 ... gene_199 gene_200 ## rowData names(1): feature_id ## colnames(6): A B ... E F ## colData names(1): Treatment ## Explora el objeto rse de forma interactiva library(&quot;iSEE&quot;) if (interactive()) { iSEE::iSEE(rse) } 5.14.1 Ejercicio iSEE con sce.416b Repitamos la imagen que hicimos anteriormente. ## Explora el objeto sce.416b de forma interactiva if (interactive()) { iSEE::iSEE(sce.416b, appTitle = &quot;sce.416b&quot;) } 5.14.2 Datos de LIBD de Tran et al Datos de Tran et al, bioRxiv, 2020. Código de R para el sitio web: https://github.com/LieberInstitute/10xPilot_snRNAseq-human/tree/master/shiny_apps/tran2021_AMY. 5.14.3 Más detalles de iSEE Notas en inglés. 5.15 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:20:48 UTC&quot; proc.time() ## user system elapsed ## 187.698 4.011 194.295 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE * 2.4.0 2021-05-19 [1] Bioconductor ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Ahora tenemos más información en colData(sce.416b)↩︎ with(colData(sce.416b), boxplot(detected ~ block))↩︎ Sí, usando table(qc.lib , qc.spike) y table(qc.lib , qc.mito).↩︎ discard de table(discard, discard2)↩︎ Sí, usando table(discard, discard2, discard3)↩︎ Debajo de lower son considerados droplets vacíos. Solo se usan para la correción estadística de pruebas múltiples.↩︎ No, debido a los NAs.↩︎ Sí: identical(e.out$PValue[!is.na(e.out$FDR)], all.out$PValue[!is.na(e.out$FDR)]).↩︎ marked es más grande que filtered↩︎ Yo prefiero usar marked si tengo suficiente memoria para usarlo.↩︎ "],["normalización-de-datos.html", "6 Normalización de datos 6.1 Material 6.2 Motivación 6.3 Datos 6.4 Normalización por escalamiento (scaling normalization) 6.5 Normalización por decircunvolución (deconvolution) 6.6 Transformación logarítmica 6.7 Otras normalizaciones 6.8 Notas finales 6.9 Adicionales 6.10 Agradecimientos 6.11 Detalles de la sesión de R Patrocinadores", " 6 Normalización de datos Instructora: Ana Beatriz Villaseñor Altamirano 6.1 Material Diapositivas de Peter Hickey: Ve las diapositivas aquí Capítulo de OSCA: Ve el capítulo del libro OSCA aquí 6.2 Motivación Al igual que otras tecnologías, single-cell RNA-seq (scRNA-seq) tiene errores sistemáticos y es importante conocerlos. Dentro de los más comunes se encuentran la captura de cDNA y la amplificación de PCR que se lleva acabo por célula. Tener poco material de inicio dificulta lograr una preparación de libreria consistente dando lugar a errores sistemáticos. Figura tomada de [1] La normalización tiene como objetivo remover estás diferencias sistemáticas para que no interfieran cuando comparamos los perfiles de expresión entre células. Al normalizar los datos, las diferencias observadas entre poblaciones célulares o condiciones son debido a la biología y no por factores técnicos. 6.2.1 Ejercicio: Conceptos básicos Da ejemplos de sesgos técnicos (TIP: ¿Qué es RPKM?). ¿Qué es correción por lote (batch effect correction)? Da un ejemplo. ¿Cuáles son las diferencias entre correción por lote y normalización? 6.3 Datos Usaremos el dataset de Zeisel. Tipos celulares en cerebro de ratón (oligodendrocitos, microglias, neuronas, etc.) Procesado con STRT-seq (similar a CEL-seq), un sistema de microfluio. 3005 células y 18441 genes Contiene UMIs library(&quot;scRNAseq&quot;) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) sce.zeisel ## class: SingleCellExperiment ## dim: 18441 3005 ## metadata(0): ## assays(1): counts ## rownames(18441): ENSMUSG00000029669 ENSMUSG00000046982 ... ## ENSMUSG00000064337 ENSMUSG00000065947 ## rowData names(2): featureType originalName ## colnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12 ## 1772058148_F03 ## colData names(10): tissue group # ... level1class level2class ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC repeat 6.3.1 Ejercicio: QC ¿Cuántos genes son mitocondriales? (TIP: is.mito) ¿Cuántos genes tienen: bajas cuentas de librería, bajos features, alto porcentaje de expresión de ERCC, alto porcentaje de genes MT? ¿Cuántas células descartamos? (TIP: perCellQCMetrics y quickPerCellQC) Gráfica los resultados 6.4 Normalización por escalamiento (scaling normalization) La normalización por escalamiento es la estrategia más simple y usada. Representa el estimado del sesgo relativo en cada célula. Se realiza dividiendo todas las cuentas de cada célula por un factor de escalamiento específico para cada una. Este factor de escalamiento se le conoce como Library Size factor. \\[ CuentasNormalizadas = Cuentas / Library Size factor\\] Suposición: Cualquier sesgo específico en cada célula (e.j. eficiencia en la captura o en la amplificación) afecta a todos los genes de igual manera a través de escalar por el promedio esperado de cuentas para dicha célula. Los valores de expresión normalizados pueden ser usados por análisis posteriores como clustering o reducción de dimenciones. 6.4.1 Tamaño de biblioteca (Library Size) Tamaño de biblioteca (Library Size): La suma total de las cuentas a tráves de todos los genes en una célula. \\[Library Size_{cell} = \\sum_{n=1}^{j} gene\\] Donde \\(j\\) es el número total de genes y \\(gene\\) es el número de cuentas por gen para cada célula. El valor de library size es el que asumimos que escala con cualquier sesgo específico en cada célula. Para escalar los datos ocuparemos un factor de escalamiento llamado Library Size factor. \\[ Library Size \\propto Library Size factor \\] Se calcula usando library size: \\[ Library Size factor = {Library Size} / {mean(Library Size)}\\] Y se define de tal manera que el promedio de Library Size factor en todas las células es igual a 1. \\[ mean(Library Size factor) = 1 \\] Lo que nos permite que los valores normalizados están en la misma escala y pueden ser útiles para la interpretación. # Estimar tamaños de librerías lib.sf.zeisel &lt;- librarySizeFactors(sce.zeisel) # Examina la distribución de los tamaños de librerías # que acabamos de estimar summary(lib.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 hist(log10(lib.sf.zeisel), xlab = &quot;Log10[Library Size factor]&quot;, col = &quot;grey80&quot;) 6.4.2 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library Size ls.zeisel ¿Son idénticos ls.zeisel y lib.sf.zeisel? ¿Son proporcionales? Calcula lib.sf.zeisel de forma manual. TIP: Checa el código fuente 6.4.3 Puntos finales Normalizar por Library Size factor asume que no hay desigualdad en la cantidad de genes differencialmente expresados (DE) entre dos células. Es decir, que para cada grupo de genes sobre-expresados, debe existir un grupo de genes sub-expresados en la misma magnitud, cuando esto no pasa se le conoce como sesgo de composición (Veáse a continuación). Para análisis exploratorios, la precisión de la normalización no es un punto mayor a considerar. El sesgo por composición normalmente no afecta la separación de los clusters, solo la magnitud. La normalización por Library Size factor suele ser suficiente en algunas ocasiones donde se busca identificar clusters y los marcadores de los clusters. 6.5 Normalización por decircunvolución (deconvolution) Un sesgo técnico que es importante considerar es el sesgo de composición de RNA (transcriptoma). Supongamos que un gen X (o grupo de genes) se expresa en mayor cantidad en la célula A comparado a la célula B. Esto significa que más recursos fueron tomados por el gen X, disminuyendo la covertura de los demás. ¿Qué pasa si escalamos por tamaño de biblioteca? Figura tomada de [2] Este problema ha sido estudiado en bulk RNA-seq, DESeq2::estimateSizeFactorsFromMatrix() y edgeR::calcNormFactors(), contemplan este sesgo. Se assume que la mayoría de genes no estarán DE entre las muestras (en nuestro caso células) y cualquier diferencia entre los genes non-DE representa un sesgo el cual se remueve (calculando un factor de normalización). Sin embargo, single-cell RNA-seq tiene muchas cuentas bajas y ceros debido a limitaciones en la tecnología y no necesariamente indica ausencia de expresión. El método de scran resuelve este problema juntando las cuentas de varias células (pool) para incrementar el tamaño de las cuentas y obtener un factor de estimación que remueva el sesgo de composición de manera más precisa. Este factor calculado con las cuentas pool se les regresa individualmente a cada célula mediante decircunvolución (deconvolution). Utilizando este factor se normalizan los datos con scran::calculateSumFactors(). # Normalización por decircunvolución (deconvolution) library(&quot;scran&quot;) # Pre-clustering set.seed(100) clust.zeisel &lt;- quickCluster(sce.zeisel) # Calcula factores de tamaño para la decircunvolución (deconvolution) deconv.sf.zeisel &lt;- calculateSumFactors(sce.zeisel, clusters = clust.zeisel, min.mean = 0.1) # Examina la distribución de los factores de tamaño summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 hist(log10(deconv.sf.zeisel), xlab = &quot;Log10[Deconvolution size factor]&quot;, col = &quot;grey80&quot; ) plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16 ) abline(a = 0, b = 1, col = &quot;red&quot;) 6.5.1 Ejercicios: deconvolution ¿Cúantos clusters rápidos obtuvimos? ¿Cúantas células por cluster obtuvimos? ¿Cúantos clusters rápidos obtendríamos si cambiamos el tamaño mínimo a 200? Usa 100 como la semilla (seed). ¿Cúantas líneas ves en la gráfica? 6.5.2 Puntos finales La normalización por decircunvolución (deconvolution) mejora los resultados para análisis posteriores de una manera más precisa que los métodos para bulk RNA-seq. scran algunas veces alcula factores negativos o ceros lo cual altera la matrix de expresión normalizada. ¡Checa los factores que calculas! summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 Si obtienes factores negativos intenta variar el número de clusters, checa si incrementar el número de células por cluster te dan factores positivos. 6.6 Transformación logarítmica 6.6.1 Motivación ¿Qué gen es más interesante? Gen X: el promedio de expresión en el tipo celular A: 50 y B: 10 Gen Y: el promedio de expresión en el tipo celular A: 1100 y B: 1000 50 - 10 ## [1] 40 1100 - 1000 ## [1] 100 log(50) - log(10) ## [1] 1.609438 log(1100) - log(1000) ## [1] 0.09531018 Una vez calculados los factores de normalización con computeSumFactors(), podemos calular las cuentas en escala logaritmica usando logNormCounts(). Estos valores resultantes son valores de expresión normalizados transformados en escala logarítmica. # Normalization # set.seed(100) # clust.zeisel &lt;- quickCluster(sce.zeisel) # sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster=clust.zeisel, min.mean=0.1) # Log transformation sce.zeisel &lt;- scater::logNormCounts(sce.zeisel) assayNames(sce.zeisel) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.6.2 Ejercicio: Transformación logarítmica ¿Qué es una pseudo-cuenta? ¿Porqué se usa? ¿Qué valor de pseudo-cuenta usa logNormCounts()? ¿Qué es la opción downsample=TRUE? 6.7 Otras normalizaciones Te invitamos a leer más sobre otras formas de normalizar, un lugar para empezar lo puedes encontrar en el curso del Sanger Institute. Si estas interesad@ en diferencias en el contenido total de RNA en cada célula checa la normalización por spike-ins. La cual asume que los spike-ins fueron añadidos en un nivel constante en cada célula. Si tienes resultados donde el library size está asociado a tus datos a pesar de haber normalizado checa la opción de downsample=TRUE dentro de la función de logNormCounts(). 6.7.1 Seurat La normalización de Seurat con NormalizeData() (tomado de aquí): Dividir cada célula por el número total de moléculas medidas en la célula. - ¿Será library size? Multiplicar ese número por un scaling factor (e.j. 10000) Sumar 1 y tomar el logaritmo natural. library(&quot;Seurat&quot;) # Create a Seurat obj sce &lt;- sce.zeisel sce &lt;- removeAltExps(sce) seurat.zeisel &lt;- as.Seurat(sce, counts = &quot;counts&quot;, data = NULL) seurat.zeisel ## An object of class Seurat ## 18441 features across 2815 samples within 1 assay ## Active assay: endogenous (18441 features, 0 variable features) # Normalize using Seurat function seurat.zeisel &lt;- NormalizeData(seurat.zeisel, normalization.method = &quot;LogNormalize&quot;) # Compare Total counts per cell after normalization ls.seurat &lt;- colSums(seurat.zeisel[[SingleCellExperiment::mainExpName(x = sce)]]@data) ## Relacionado a ## https://github.com/satijalab/seurat/blob/9b3892961c9e1bf418af3bbb1bc79950adb481d7/R/objects.R#L1041-L1046 ## donde podemos ver como Seurat convierte el objeto de SingleCellExperiment ## a un objeto de Seurat summary(ls.seurat) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 hist(ls.seurat) # Trying to replicate it ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 step1 &lt;- t(counts(sce.zeisel)) / ls.zeisel # matrix(2,2,2,2) /c(1,2) step2 &lt;- step1 * 10000 step3 &lt;- t(log1p(step2)) ls.steps &lt;- colSums(step3) summary(ls.steps) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 plot(ls.seurat, ls.steps) # Compare with deconv normalization ls.log &lt;- colSums(logcounts(sce.zeisel)) plot(ls.seurat, ls.log) Nota: scanpy ocupa un factor de normalización igual que Seurat. 6.8 Notas finales 6.8.1 Ejercicio: Conceptos básicos Da ejemplos de sesgos técnicos (TIP: ¿Qué es RPKM?). “Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content)” - hbctraining Algunos ejemplos de los sesgos técnicos que se contemplan son la profundidad de secuenciación y la longitud del gen. Profundidad de secuenciación: Es necesario contemplarlo para comparar entre muestras, en este caso células. Figura tomada de [2] Longitud del gen: Es necesario contemplarlo para comparar entre genes. Figura tomada de [2] ¿Qué es correción por lote (batch effect correction)? Da un ejemplo. “Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints. However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality. This results in systematic differences in the observed expression in cells from different batches, which we refer to as “batch effects”. Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results\" -OSCA ¿Cuáles son las diferencias entre correción por lote y normalización? “Normalization occurs regardless of the batch structure and only considers technical biases, while batch correction - as the name suggests - only occurs across batches and must consider both technical biases and biological differences. Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content), while biological differences between batches can be highly unpredictable” -OSCA 6.8.2 Ejercicio: QC ¿Cuántos genes son mitocondriales? (recuerdas is.mito) length(is.mito) ## [1] 34 ¿Cuántos genes tienen: bajas cuentas de librería, bajos features, alto porcentaje de expresión de ERCC, alto porcentaje de genes MT? ¿Cuántas células descartamos? (TIP: perCellQCMetrics y quickPerCellQC) colSums(as.data.frame(qc)) ## low_lib_size low_n_features high_altexps_ERCC_percent ## 0 3 66 ## high_subsets_Mt_percent discard ## 128 190 Gráfica los resultados # Plots colData(unfiltered) &lt;- cbind(colData(unfiltered), stats) unfiltered$discard &lt;- qc$discard gridExtra::grid.arrange( plotColData(unfiltered, y = &quot;sum&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Cuentas Totales&quot;), plotColData(unfiltered, y = &quot;detected&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Features (genes) detectados&quot;), plotColData(unfiltered, y = &quot;altexps_ERCC_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;ERCC %&quot;), plotColData(unfiltered, y = &quot;subsets_Mt_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;Mito %&quot;), ncol = 2 ) 6.8.3 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library size ls.zeisel ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 hist(log10(ls.zeisel), xlab = &quot;Log10[Library size]&quot;, col = &quot;grey80&quot;) ¿Son idénticos ls.zeisel y lib.sf.zeisel? identical(lib.sf.zeisel, ls.zeisel) ## [1] FALSE ¿Son proporcionales? # Checamos proporcionalidad plot( ls.zeisel, lib.sf.zeisel, log = &quot;xy&quot;, main = &quot;Proporcionalidad&quot;, xlab = &quot;Library size&quot;, ylab = &quot; Library size factor&quot; ) Calcula lib.sf.zeisel de forma manual. TIP: Checa el código fuente ## Ahora asegurate que su media sea 1 (unity mean) lib_size_factors &lt;- ls.zeisel / mean(ls.zeisel) summary(lib_size_factors) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 identical(lib_size_factors, lib.sf.zeisel) ## [1] TRUE 6.8.4 Ejercicios: deconvolution ¿Cúantos clusters rápidos obtuvimos? levels(clust.zeisel) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ¿Cúantas células por cluster obtuvimos? cells_cluster &lt;- sort(table(clust.zeisel)) cells_cluster ## clust.zeisel ## 12 7 4 6 10 1 3 11 2 8 5 9 ## 113 123 140 224 231 243 252 259 281 300 324 325 barplot(cells_cluster) ¿Cúantos clusters rápidos obtendríamos si cambiamos el tamaño mínimo a 200? Usa 100 como la semilla (seed). set.seed(100) sort(table(quickCluster(sce.zeisel, min.size = 200))) ## ## 5 9 6 1 3 10 2 4 8 7 ## 224 231 236 243 252 259 281 324 325 440 ¿Cúantas líneas ves en la gráfica? plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16, col = as.integer(factor(sce.zeisel$level1class)) ) abline(a = 0, b = 1, col = &quot;red&quot;) abline(a = -.2, b = 0.95, col = &quot;red&quot;) abline(a = 0.08, b = 1, col = &quot;red&quot;) 6.8.5 Ejercicio: Transformación logarítmica ¿Qué es una pseudo-cuenta? Un número que se agrega para poder sacar el logarítmo ¿Porqué se usa? Por que log(0) = -Inf y produce error más adelante. ¿Qué valor de pseudo-cuenta usa logNormCounts()? pseudo.count = 1 ¿Qué es la opción downsample=TRUE? OSCA: Downsampling. Para cuando existe un efecto en los valores que se asocia a la library size a pesar de haber nomalizado. Funciones interesantes para después de normalizar # sce.zeisel &lt;- runPCA(sce.zeisel) # plotPCA(sce.zeisel, colour_by = &quot;level1class&quot;) # plotRLE(sce.zeisel, exprs_values = &quot;logcounts&quot;, colour_by = &quot;level1class&quot;) 6.9 Adicionales [1] 2018 BioInfoSummer Workshop [2] HBC training 6.10 Agradecimientos Este curso está basado en el libro Orchestrating Single Cell Analysis with Bioconductor de Aaron Lun, Robert Amezquita, Stephanie Hicks y Raphael Gottardo, además del curso de scRNA-seq para WEHI creado por Peter Hickey. Y en el material de la comunidadbioinfo/cdsb2020 con el permiso de Leonardo Collado-Torres. 6.11 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:22:12 UTC&quot; proc.time() ## user system elapsed ## 77.657 5.369 83.845 options(width = 120) sessioninfo::session_info() ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["selección-de-genes.html", "7 Selección de genes 7.1 Diapositivas de Peter Hickey 7.2 Motivación 7.3 Selección de features (genes) 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.5 Dataset ilustrativo: 416B 7.6 Cuantificando la varianza por gen 7.7 Coeficiente de variación de las cuentas 7.8 Varianza de los log-counts vs coeficiente de variación 7.9 Cuantificando el ruido técnico 7.10 En la ausencia de spike-ins 7.11 Recordemos propiedades de los datos de sce.416b 7.12 Considerando factores experimentales 7.13 Seleccionando genes altamante variables (high-variable genes, HVGs) 7.14 Poniendo todo junto 7.15 Resumen y recomendaciones 7.16 Recomendaciones para empezar 7.17 Detalles de la sesión de R Patrocinadores", " 7 Selección de genes Instructora: Yalbi I. Balderas-Martínez Instructora: Laura Gómez-Romero 7.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 7.2 Motivación Usualmente usamos datos scRNA-seq para caracterizar la heterogeneidad entre células Para hacer esto, usamos métodos como el clustering y la reducción de dimensionalidad Esto involucra resumir las diferencias por gen en una sola medida de (dis)similitud entre un par de células ¿Cuáles genes deberíamos usar para calcular esta medida de (dis)similitud? 7.3 Selección de features (genes) La elección de los features tiene un mayor impacto en qué tan similares decidimos que son las células ➕ Features que contienen información útil biológica ➖ Features que contienen ruido aleatorio 👉 Efectos laterales al reducir la dimensionalidad de los datos Deseamos seleccionar los genes altamente variables (High Variable Genes HVGs). Genes con una variación incrementada en comparación con otros genes que están siendo afectados por ruido técnico u otra variación biológica que no es de nuestro interés. 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.4.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) sce.pbmc ## class: SingleCellExperiment ## dim: 33694 737280 ## metadata(1): Samples ## assays(1): counts ## rownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(2): ID Symbol ## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ... ## TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 11 7.4.2 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 7.4.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 7.4.4 Preguntas de repaso ¿Cómo determinamos cuáles eran los genes mitocondriales? 12 ¿Cómo decidimos filtrar las células? 13 ¿Puedes explicar como normalizamos los datos? 14 7.5 Dataset ilustrativo: 416B library(scRNAseq) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) sce.416b$block &lt;- factor(sce.416b$block) Línea celular de células mieloides progenitoras inmortalizadas de ratón usando SmartSeq2 https://osca.bioconductor.org/lun-416b-cell-line-smart-seq2.html 15 # gene-annotation library(AnnotationHub) ens.mm.v97 &lt;- AnnotationHub()[[&quot;AH73905&quot;]] rowData(sce.416b)$ENSEMBL &lt;- rownames(sce.416b) rowData(sce.416b)$SYMBOL &lt;- mapIds(ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SYMBOL&quot; ) rowData(sce.416b)$SEQNAME &lt;- mapIds(ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) library(scater) rownames(sce.416b) &lt;- uniquifyFeatureNames( rowData(sce.416b)$ENSEMBL, rowData(sce.416b)$SYMBOL ) # quality-control mito &lt;- which(rowData(sce.416b)$SEQNAME == &quot;MT&quot;) stats &lt;- perCellQCMetrics(sce.416b, subsets = list(Mt = mito)) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;subsets_Mt_percent&quot;, &quot;altexps_ERCC_percent&quot;), batch = sce.416b$block ) sce.416b &lt;- sce.416b[, !qc$discard] # normalization library(scran) sce.416b &lt;- computeSumFactors(sce.416b) sce.416b &lt;- logNormCounts(sce.416b) 7.5.1 Preguntas de repaso ¿Cómo determinamos cuáles eran los genes mitocondriales? ¿Cómo decidimos filtrar las células ¿Puedes explicar cómo normalizamos los datos? 7.6 Cuantificando la varianza por gen 7.6.1 Varianza de los log-counts El enfoque más simple para cuantificar la variación per-feature es simplemente calcular la varianza de los log-counts ➕ Selección del feature basado en los log-counts (que serán usadas en los análisis más adelante) ⚠️ La transformación log no logra la estabilización de la varianza perfecta, así que se requiere modelar la relación de la varianza-media de los features. 7.6.2 Enfoque simple Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Ordenar los genes del más-al-menos variable 7.6.3 Un enfoque más sofisticado Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Modelar la relación entre la media y la varianza de los log-counts para estimar la variación técnica Estimar la varianza biológica sustrayendo la varianza técnica de la varianza total Ordenar los genes de la variable de mayor-a-menor biológicamente 7.6.4 Supuestos # Varianza de las log-counts library(scran) dec.pbmc &lt;- modelGeneVar(sce.pbmc) 🤓 El supuesto es que a cualquier abundancia dada, la abundancia de los perfiles de expresión de la mayoría de los genes están dominados por el ruido aleatorio técnico 🤓 Por lo consiguiente, una tendencia representa un estimado del ruido técnico como una función de la abundancia 🤓 Podemos entonces descomponer la varianza total de cada gen en un componente técnico y uno biológico 🤓 Genes con una gran varianza biológica son considerados interesantes 7.6.5 Visualizando la media y varianza # Visualicemos la relación entre la media y la varianza fit.pbmc &lt;- metadata(dec.pbmc) plot(fit.pbmc$mean, fit.pbmc$var, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) curve(fit.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) 7.6.5.1 Ejercicios ¿Qué tipo de objeto nos regresó modelGeneVar()? 16 ¿dec.pbmc es una tabla? ¿O contiene mayor información? 17 ¿Qué tipo de objeto es fit.pbmc y que objetos con nombres contiene? 18 ¿Qué tipo de objeto es fit.pbmc$trend? 19 ¿Donde podemos encontrar más detalles de esta función? 20 7.6.6 Ordenando genes interesantes # Ordenemos por los genes más interesantes para checar # los datos dec.pbmc[order(dec.pbmc$bio, decreasing = TRUE), ] ## DataFrame with 33694 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## LYZ 1.95605 5.05854 0.835343 4.22320 1.10538e-270 2.17417e-266 ## S100A9 1.93416 4.53551 0.835439 3.70007 2.71043e-208 7.61593e-205 ## S100A8 1.69961 4.41084 0.824342 3.58650 4.31581e-201 9.43197e-198 ## HLA-DRA 2.09785 3.75174 0.831239 2.92050 5.93950e-132 4.86767e-129 ## CD74 2.90176 3.36879 0.793188 2.57560 4.83937e-113 2.50488e-110 ## ... ... ... ... ... ... ... ## TMSB4X 6.08142 0.441718 0.679215 -0.237497 0.992447 1 ## PTMA 3.82978 0.486454 0.731275 -0.244821 0.990002 1 ## HLA-B 4.50032 0.486130 0.739577 -0.253447 0.991376 1 ## EIF1 3.23488 0.482869 0.768946 -0.286078 0.995135 1 ## B2M 5.95196 0.314948 0.654228 -0.339280 0.999843 1 7.7 Coeficiente de variación de las cuentas El coeficiente de variación de las cuentas al cuadrado (CV2) es una alternativa a la varianza de los log-counts 👉 Se calcula usando las cuentas en lugar de los log-counts 🤓 CV es el ratio de la desviación estándar a la media y está muy relacionada con el parámetro de dispersión de la distribución binomial negativa usada en edgeR y DESeq2 7.7.1 Coeficiente de variación # Coeficiente de variación dec.cv2.pbmc &lt;- modelGeneCV2(sce.pbmc) 🤓 Modela la relación de la media de la varianza cuando se considera la relevancia de cada gen 🤓 Asume que la mayoría de los genes contienen ruido aleatorio y que la tendencia captura la mayoría de la variación técnica 🤓 Genes con un gran CV2 que se desvían fuertemente de la tendencia es probable que representen genes afectados por la estructura biológica 🤓 Usa la tasa (en lugar de la diferencia) del CV2 a la tendencia 7.7.2 Visualizando el coeficiente de variación # Visualicemos la relación con la media fit.cv2.pbmc &lt;- metadata(dec.cv2.pbmc) plot(fit.cv2.pbmc$mean, fit.cv2.pbmc$cv2, log = &quot;xy&quot; ) curve(fit.cv2.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2 ) 7.7.3 Genes por coeficiente de variación # Ordenemos por los genes más interesantes para checar # los datos dec.cv2.pbmc[order(dec.cv2.pbmc$ratio, decreasing = TRUE ), ] ## DataFrame with 33694 rows and 6 columns ## mean total trend ratio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## PPBP 2.2437397 132.364 0.803689 164.696 0 0 ## PRTFDC1 0.0658743 3197.564 20.266829 157.773 0 0 ## HIST1H2AC 1.3731487 175.035 1.176934 148.721 0 0 ## FAM81B 0.0477082 3654.419 27.902078 130.973 0 0 ## PF4 1.8333127 109.451 0.935484 116.999 0 0 ## ... ... ... ... ... ... ... ## AC023491.2 0 NaN Inf NaN NaN NaN ## AC233755.2 0 NaN Inf NaN NaN NaN ## AC233755.1 0 NaN Inf NaN NaN NaN ## AC213203.1 0 NaN Inf NaN NaN NaN ## FAM231B 0 NaN Inf NaN NaN NaN 7.8 Varianza de los log-counts vs coeficiente de variación Generalmente se usa la varianza de los log-counts Ambas son medidas efectivas para cuantificar la variación en la expresión génica CV2 tiende a tener otorgar rangos altos a genes altamente variables (HGVs) con bajos niveles de expresión Éstos son dirigidos por una sobreregulación en subpoblaciones raras Puede asignar un alto rango a genes que no son de nuestro interés con varianza baja absoluta La variación descrita por el CV2 de las cuentas es menos relevante para los procedimientos que operan en los log-counts 7.9 Cuantificando el ruido técnico Previamente, ajustamos una línea de tendencia a todos los genes endógenos y asumimos que la mayoría de los genes no están dominados por ruido técnico En la práctica, todos los genes expresados tienen algún nivel de variabilidad biológica diferente de cero (e.g., transcriptional bursting) Esto sugiere que nuestros estimados de los componentes técnicos estarán inflados probablemente 👉 Es mejor que pensemos estos estimados como una variación técnica más la variación biológica que no es interesante 🤔 Pero que tal si un grupo de genes a una abundancia particular es afectado por un proceso biológico? E.g., fuerte sobre regulación de genes específicos de un tipo celular podrían conllevar a un enriquecimiento de HVGs en abundancias altas. Esto inflaría la tendencia y compromete la detección de los genes relevantes ¿Cómo podemos evitar este problema? Podemos revisar dos enfoques: Cuando tenemos spike-ins Cuando no tenemos spike-ins 7.9.1 En la presencia de spike-ins dec.spike.416b &lt;- modelGeneVarWithSpikes( sce.416b, &quot;ERCC&quot; ) # Ordering by most interesting genes for # inspection. dec.spike.416b[order(dec.spike.416b$bio, decreasing = TRUE ), ] ## DataFrame with 46604 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Lyz2 6.61097 13.8497 1.57131 12.2784 1.48993e-186 1.54156e-183 ## Ccl9 6.67846 13.1869 1.50035 11.6866 2.21856e-185 2.19979e-182 ## Top2a 5.81024 14.1787 2.54776 11.6310 3.80016e-65 1.13040e-62 ## Cd200r3 4.83180 15.5613 4.22984 11.3314 9.46221e-24 6.08574e-22 ## Ccnb2 5.97776 13.1393 2.30177 10.8375 3.68706e-69 1.20193e-66 ## ... ... ... ... ... ... ... ## Rpl5-ps2 3.60625 0.612623 6.32853 -5.71590 0.999616 0.999726 ## Gm11942 3.38768 0.798570 6.51473 -5.71616 0.999459 0.999726 ## Gm12816 2.91276 0.838670 6.57364 -5.73497 0.999422 0.999726 ## Gm13623 2.72844 0.708071 6.45448 -5.74641 0.999544 0.999726 ## Rps12l1 3.15420 0.746615 6.59332 -5.84670 0.999522 0.999726 👉 Ajusta la tendencia solo con los spike-ins (que deberían estar afectados solamente por variación técnica) plot(dec.spike.416b$mean, dec.spike.416b$total, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) fit.spike.416b &lt;- metadata(dec.spike.416b) points(fit.spike.416b$mean, fit.spike.416b$var, col = &quot;red&quot;, pch = 16 ) curve(fit.spike.416b$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2 ) 7.10 En la ausencia de spike-ins set.seed(0010101) dec.pois.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) # Ordering by most interesting genes for inspection. dec.pois.pbmc[order(dec.pois.pbmc$bio, decreasing = TRUE), ] ## DataFrame with 33694 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## LYZ 1.95605 5.05854 0.631190 4.42735 0 0 ## S100A9 1.93416 4.53551 0.635102 3.90040 0 0 ## S100A8 1.69961 4.41084 0.671491 3.73935 0 0 ## HLA-DRA 2.09785 3.75174 0.604448 3.14730 0 0 ## CD74 2.90176 3.36879 0.444928 2.92386 0 0 ## ... ... ... ... ... ... ... ## ATP5J 0.614027 0.454754 0.502701 -0.0479473 0.943718 1.000000 ## NEDD8 0.841407 0.561295 0.609895 -0.0486003 0.907530 0.997441 ## NDUFA1 0.860049 0.560222 0.616330 -0.0561074 0.935049 1.000000 ## SAP18 0.763057 0.515764 0.578890 -0.0631264 0.965173 1.000000 ## SUMO2 1.359514 0.619811 0.693247 -0.0734360 0.960991 1.000000 👉 Realiza algunas asunciones estadísticas acerca del ruido 🤓 Las cuentas UMI típicamente muestran una variación cercana a Poisson si solo consideramos ruido técnico de la preparación de las librerías y la secuenciación ⚠️ modelGeneVarByPoisson() realiza simulaciones, por lo que necesitamos “ajustar la “semilla” para obtener resultados reproducibles 🤓 modelGeneVarByPoisson() pueden también simular una variación binomial negativa (variación de Poisson sobredispersada) plot(dec.pois.pbmc$mean, dec.pois.pbmc$total, pch = 16, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) curve(metadata(dec.pois.pbmc)$trend(x), col = &quot;dodgerblue&quot;, add = TRUE ) 🤓 La línea de tendencia basada puramente en ruido técnico tiende a producir componentes “biológicos” más grandes por los genes altamente expresados, que frecuentemente incluyen los genes “house-keeping” 🤔 Necesitas considerar si tales genes son “interesantes” o no en tu dataset de interés 7.11 Recordemos propiedades de los datos de sce.416b Este dataset consiste de células de una línea celular de células inmortalizadas mieloides progenitoras de ratón utilizando SmartSeq2 Una cantidad constante de spike-in ERCC RNA se agregó a cada lisado celular antes de la prepatación de la librería Descripción aquí Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., Göttgens, B. &amp; Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795–1806 (2017) 7.12 Considerando factores experimentales Los datos que contienen múltiples batches muy seguido presentan efecto de bloque que pueden crear HGVs artificiales Se debe identificar los HGVs en cada batch y combinarlos en una única lista de HGVs # calculando la variacion por bloque dec.block.416b &lt;- modelGeneVarWithSpikes(sce.416b, &quot;ERCC&quot;, block = sce.416b$block ) dec.block.416b[order( dec.block.416b$bio, decreasing = TRUE ), ] ## DataFrame with 46604 rows and 7 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Lyz2 6.61235 13.8619 1.58416 12.2777 0.00000e+00 0.00000e+00 ## Ccl9 6.67841 13.2599 1.44553 11.8143 0.00000e+00 0.00000e+00 ## Top2a 5.81275 14.0192 2.74571 11.2734 3.89855e-137 8.43398e-135 ## Cd200r3 4.83305 15.5909 4.31892 11.2719 1.17783e-54 7.00721e-53 ## Ccnb2 5.97999 13.0256 2.46647 10.5591 1.20380e-151 2.98405e-149 ## ... ... ... ... ... ... ... ## Gm12816 2.91299 0.842574 6.67730 -5.83472 0.999989 0.999999 ## Gm5786 2.90717 0.879485 6.71686 -5.83738 0.999994 0.999999 ## Rpl9-ps4 3.26421 0.807057 6.64932 -5.84226 0.999988 0.999999 ## Gm13623 2.72788 0.700296 6.63875 -5.93845 0.999998 0.999999 ## Rps12l1 3.15425 0.750775 6.70033 -5.94955 0.999995 0.999999 ## per.block ## &lt;DataFrame&gt; ## Lyz2 6.35652:13.3748:2.08227:...:6.86819:14.3490:1.08605:... ## Ccl9 6.68726:13.0778:1.65923:...:6.66956:13.4420:1.23184:... ## Top2a 5.34891:17.5972:3.91642:...:6.27659:10.4411:1.57501:... ## Cd200r3 4.60115:15.7870:5.55587:...:5.06496:15.3948:3.08197:... ## Ccnb2 5.56701:15.4150:3.46931:...:6.39298:10.6362:1.46362:... ## ... ... ## Gm12816 2.86995:0.624143:7.43036:...:2.95604:1.061004:5.92424:... ## Gm5786 2.96006:0.902872:7.49911:...:2.85427:0.856098:5.93462:... ## Rpl9-ps4 3.60690:0.543276:7.36805:...:2.92151:1.070839:5.93058:... ## Gm13623 2.83129:0.852901:7.39442:...:2.62447:0.547692:5.88308:... ## Rps12l1 3.14399:0.716670:7.57246:...:3.16452:0.784881:5.82819:... Al calcular tendencias específicas por batch se tomarán en cuenta las diferencias en la relación media-varianza entre batches Se deben obtener estimados de los componentes biológico y técnico para cada gene específicos de cada batch, los cuales se promedian entre los batches para crear una única lista de HVGs Factor experimental. 7.13 Seleccionando genes altamante variables (high-variable genes, HVGs) Hasta ahora hemos ordenado los genes del más al menos interesantemente variable ¿Qué tanto debemos de bajar en la lista para seleccionar nuestros HVGs? Para responder esta pregunta debemos tomar en cuenta lo siguiente: elegir un subset más grande: Reduce el riesgo de desechar señal biológica Incrementa el ruido por la inclusión de genes irrelevantes Es difícil determinar el balance óptimo porque el rudio en un contexto podría ser una señal útil en otro contexto Discutiremos algunas estrategias para seleccionar HVGs 7.13.1 Seleccionando HVGs sobre la métrica de varianza La estrategia más simple es seleccionar los top-X genes con los valores más grandes para la métrica relevante de varianza, por ejemplo, la varianza biológica más grande calculada con scran::modelGeneVar() Pro: El usuario puede controlar directamente el número de HVGs Contra: ¿Qué valor de X se debe usar? # Works with modelGeneVar() output hvg.pbmc.var &lt;- getTopHVGs(dec.pbmc, n = 1000) str(hvg.pbmc.var) ## chr [1:1000] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var &lt;- getTopHVGs(dec.spike.416b, n = 1000) str(hvg.416b.var) ## chr [1:1000] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` hvg.pbmc.cv2 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, n = 1000 ) str(hvg.pbmc.cv2) ## chr [1:1000] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.1.1 Estrategias para seleccionar X Asume que, por ejemplo, no más del 5% de los genes están diferencialmente expresados entre las células de nuestra población: Establece X como el 5% de los genes Normalmente no conocemos el número de genes diferencialmente expresados desde antes, por lo tanto, solo hemos cambiado un número arbitrario por otro número arbitrario RECOMENDACIÓN: Si decides utilizar los top-X HGVs, elige un valor de X y procede con el resto del análisis con la intención de regresar más adelante y probar otros valores, en vez de dedicarle mucho esfuerzo a encontrar el valor óptimo 7.13.2 Seleccionando HVGs de acuerdo a su significancia estadística Establece un límite fijo en alguna métrica de significancia estadística. Por ejemplo: algunos de los métodos reportan un p-valor para cada gene, entonces selecciona todos los genes con un p-valor ajustado menor que 0.05 Recuerda que las pruebas estadísticas siempre dependen del tamaño de la muestra Ventajas: * Fácil de implementar * Menos predecible que la estrategia de los top-X Desventajas: * Podría priorizar genes con significancia estadística fuerte en vez de significancia biológica fuerte # Works with modelGeneVar() output hvg.pbmc.var.2 &lt;- getTopHVGs(dec.pbmc, fdr.threshold = 0.05) str(hvg.pbmc.var.2) ## chr [1:813] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var.2 &lt;- getTopHVGs(dec.spike.416b, fdr.threshold = 0.05 ) str(hvg.416b.var.2) ## chr [1:2568] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` hvg.pbmc.cv2.2 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, fdr.threshold = 0.05 ) str(hvg.pbmc.cv2.2) ## chr [1:1972] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.3 Seleccionando genes por arriba de la tendencia media-varianza Selecciona todos los genes con una varianza biológica positiva Este es un extremo del equilibrio sesgo-varianza que minimiza el sesgo con el costo de maximizar el ruido Si seguimos esta aproximación, estamos: Dándole a la estructura secundaria de la población una oportunidad de manifestarse Capturando más ruido, lo cual puede reducir la resolución de poblaciones bien separadas enmascarando la señal secundaria que intentamos preservar Funciona mejor si tenemos datasets altamente heterogeneos que contienen muchos tipos celulares diferentes # Works with modelGeneVar() output hvg.pbmc.var.3 &lt;- getTopHVGs(dec.pbmc, var.threshold = 0) str(hvg.pbmc.var.3) ## chr [1:12745] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var.3 &lt;- getTopHVGs(dec.spike.416b, var.threshold = 0 ) str(hvg.416b.var.3) ## chr [1:11087] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` and # value of `var.threshold` hvg.pbmc.cv2.3 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, var.threshold = 1 ) str(hvg.pbmc.cv2.2) ## chr [1:1972] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.4 EJERCICIO: Dibujando los HVGs Para este ejercicio tendrás que repetir la gráfica que muestra la tendencia de la relación media-varianza (ejeX: media de la expresión, ejeY: varianza de la expresión) incluyendo la línea de tendencia obtenida con alguna de las funciones vistas en la primer parte de la clase (modelGeneVar, modelGeneVarWithSpikes, modelGeneCV2). En esta gráfica, deberás colorear los puntos que corresponden a los HGVs obtenidos con algunos de los enfoques revisados RESPUESTA plot(fit.pbmc$mean, fit.pbmc$var, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) points(fit.pbmc$mean[hvg.pbmc.var], fit.pbmc$var[hvg.pbmc.var], col = &quot;orange&quot;) curve(fit.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) 7.13.5 Seleccionando genes de interés a priori Una estrategia contundente es usar sets predefinidos de genes de interés. No hay vergüenza en aprovechar el conocimiento biológivo previo Sin embargo, limita nuestra capacidad de descubrir aspectos nuevos o inesperados de la variación. Por lo tanto, considera esta como una estrategia complementaria a otros tipo de estrategias de selección de HGVs También podrías eliminar listas pre-definidas de genes: Genes de proteínas ribosomales o genes mitocondriales son conocidos por encontrarse dentro de los genes más variables y por interferir con análisis posteriores Sin embargo, tampoco hay que pecar de prevacido, espera a que estos genes demuestren ser problemáticos para removerlos 7.14 Poniendo todo junto # Elegimos el 10% de los genes con con componente biologico de variacion mayor dec.pbmc &lt;- modelGeneVar(sce.pbmc) chosen &lt;- getTopHVGs(dec.pbmc, prop = 0.1) str(chosen) ## chr [1:1274] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... Después de esto tenemos varias opciones para imponer nuestra selección de HGVs durante el resto del análisis: Hacer un subset de SCE para quedarnos únicamente con los HGVs Especificar los HGVs en funciones posteriores Magia (altExps) 7.14.1 Quedándonos sólo con los HGVs sce.pbmc.hvg &lt;- sce.pbmc[chosen, ] sce.pbmc.hvg ## class: SingleCellExperiment ## dim: 1274 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(1274): LYZ S100A9 ... TNNT1 TMEM55A ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): PRO: Te aseguras de que los métodos posteriores sólo usen estos genes para sus cálculos CONTRA: Los genes no-HGVs son eliminados del nuevo objeto SingleCellExperiment, lo cual hace menos conveniente la interrogación del dataset completo sobre genes que no son HGVs 7.14.2 Especificando los HGVs # Example of specifying HVGs in a downstream function # Performing PCA only on the chosen HVGs. library(scater) sce.pbmc &lt;- runPCA(sce.pbmc, subset_row = chosen) sce.pbmc ## class: SingleCellExperiment ## dim: 33694 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Mantiene el objeto SingleCellExperiment original y especifica los genes para usar en funciones posteriores mediante un argumento adicional como subset_row PRO: Es útil si el análisis usa varios conjuntos de HGVs en diferentes pasos CONTRA: Podría ser inconveniente especificar repetidamente el mismo conjunto de HGVs en diferentes pasos 7.14.3 Witchcraft (Brujería) # Add the full SCE to the subsetted data SCE altExp(sce.pbmc.hvg, &quot;original&quot;) &lt;- sce.pbmc sce.pbmc.hvg ## class: SingleCellExperiment ## dim: 1274 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(1274): LYZ S100A9 ... TNNT1 TMEM55A ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(1): original altExp(sce.pbmc.hvg, &quot;original&quot;) ## class: SingleCellExperiment ## dim: 33694 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Utilizando el sistema de “experimento alternartivo” en la clase SingleCellExperiment PRO: Evita algunos problemas a largo plazo cuando el dataset original no está sincronizado con el conjunto filtrado por HVGs CONTRA: Ralentiza todos los análisis subsecuentes 7.15 Resumen y recomendaciones Es fácil atorarse en este paso debido a la variedad de opciones disponibles Elige un conjunto de HVGs y continúa con el análisis, recuerda regresar para probar la robustez de tus resultados usando una forma diferente para seleccionar los HVGs Si tienes spike-ins, trata de usarlos. No obstante, recuerda que los spike-ins no pueden capturar todas las fuentes de variación técnica 7.16 Recomendaciones para empezar Para CEL-Seq2: scran::modelGeneVarWithSpikes() Para 10X: scran::modelGeneVarByPoisson() Si quieres irte por el lado de conservar demasiados genes: scran::getTopHVGs(dec, var.threshold=0) Y realiza una comparación rápida con, por lo menos, el top-1000 HVGs Regresa al paso de selección de HVG para eliminar genes problemáticos tantas veces como sea necesario 7.17 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:24:40 UTC&quot; proc.time() ## user system elapsed ## 144.102 4.190 147.148 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ Usando Ensembl v86 para humano↩︎ Usamos los resultados de emptyDrops() con un límite de 0.1% FDR y el filtro de 3 desviaciones sobre la mediana (MAD) en la expresión mitocondrial.↩︎ Encontramos unos clusters rápidos para las célulasy usamos esa información para calcular los factores de tamaño.↩︎ Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., Göttgens, B. &amp; Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795–1806 (2017)).↩︎ Es un DFrame↩︎ No, contiene más información dentro de metadata(dec.pbmc)↩︎ class(metadata(dec.pbmc)) y sapply(metadata(dec.pbmc), class)↩︎ Una función↩︎ Checa ?fitTrendVar y si quieres también checa el código fuente (para mí es muy útil este paso) https://github.com/MarioniLab/scran/blob/master/R/fitTrendVar.R↩︎ "],["reducción-de-dimensiones.html", "8 Reducción de dimensiones 8.1 Diapositivas de Peter Hickey 8.2 Motivación 8.3 Reducción de dimensionalidad 8.4 Dataset ilustrativo: Zeisel 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas 8.6 Análisis de Componentes Principales 8.7 Reducción de dimensionalidad para visualización 8.8 Donde estamos 8.9 Detalles de la sesión de R Patrocinadores", " 8 Reducción de dimensiones Instructora: Laura Gómez-Romero 8.1 Diapositivas de Peter Hickey Contenido adaptado de: aquí 8.2 Motivación El siguiente paso en el análisis de scRNA-seq usualmente consiste en identificar grupos de células “similares” Por ejemplo: un análisis de clustering busca identificar células con un perfil transcriptómico similar al calcular distancias entre ellas Si tuviéramos un dataset con dos genes podríamos hacer una gráfica de dos dimensiones para identificar clusters de células Pero… tenemos decenas de miles de genes : Reducción de dimensionalidad 8.3 Reducción de dimensionalidad Es posible porque la expresión de diferentes genes estaría correlacionada si estos genes son afectados por el mismo proceso biológico. Por lo tanto, no necesitamos almacenar información independiente para genes individuales. Podemos comprimir múltiples “features” (genes) en una única dimensión. Ventajas: Reduce trabajo computacional en análisis posteriores Reduce el ruido al “promediar” mútiples genes obteniendo una representación más precisa de los patrones en los datos Permite una graficación efectiva en dos dimensiones 8.4 Dataset ilustrativo: Zeisel library(scRNAseq) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) # Estos datos contienen tipos celulares previamente anotados table(sce.zeisel$level1class) ## ## astrocytes_ependymal endothelial-mural interneurons ## 224 235 290 ## microglia oligodendrocytes pyramidal CA1 ## 98 820 939 ## pyramidal SS ## 399 Estudio de tipos celulares en el cerebro de ratón (oligodendrocitos, microglia, neuronas, etc) procesados con el sistema STRT-seq (similar a CEL-Seq) Descripción aquí Zeisel, A. et al. Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq. Science 347, 1138-1142 (2015) # Quality control # Descartar celulas con alto contenido mitocondrial o con alto porcentaje de spike-ins library(scater) is.mito &lt;- which(rowData(sce.zeisel)$featureType == &quot;mito&quot;) stats &lt;- perCellQCMetrics(sce.zeisel, subsets = list(Mt = is.mito) ) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;altexps_ERCC_percent&quot;, &quot;subsets_Mt_percent&quot;) ) sce.zeisel &lt;- sce.zeisel[, !qc$discard] # normalization # encontramos unos clusters rápidos para las células y usamos esa información para calcular los factores de tamaño library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.zeisel) sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster = clusters ) sce.zeisel &lt;- logNormCounts(sce.zeisel) # variance-modelling dec.zeisel &lt;- modelGeneVarWithSpikes( sce.zeisel, &quot;ERCC&quot; ) top.zeisel &lt;- getTopHVGs(dec.zeisel, n = 2000) ¿Cómo se está modelando la relación media varianza? ¿Cómo se están obteniendo los HGVs? 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) ¿Cómo se está modelando la relación media varianza? ¿Cómo se están obteniendo los HGVs? 8.6 Análisis de Componentes Principales PCA es el arma principal de la reducción de dimensionalidad PCA descubre las combinaciones (lineales) de “features” que capturan la cantidad más grande de variación En un PCA, la primer combinación lineal (componente principal) se elige tal que permite capturar la mayor varianza a través de las células. El siguiente PC se elige tal que es “ortogonal” al primero y captura la cantidad más grande de la variación restante, y así sucesivamente… 8.6.1 PCA aplicado a datos de scRNA-seq Podemos realizar reducción de dimensionalidad al aplicar PCA en la matriz de cuentas transformadas (log-counts matrix) y restringiendo los análisis posteriores a los primeros PCs (top PCs) Esto puede reducir nuestro dataset de 20,000 dimensiones a, digamos, 10, sin perder demasiada información La técnica de PCA tiene muchas propiedades teóricas bien estudiadas. Hay varias formas rápidas de realizar PCA en datasets grandes. 8.6.2 Suposiciones de PCA aplicadas a los datos de scRNA-seq Los procesos biológicos afectan múltiples genes en una manera coordinada Los primeros PCs probablemente representan la estructura biológica dado que más variación puede ser capturada considerando el comportamiento correlacionado de muchos genes Se espera que el ruido técnico azaroso afecte cada gen independientemente Consideración: Los primeros PCs capturarón “batch effects” (efectos de lote) que afectan muchos genes en una manera coordinada library(scran) library(scater) set.seed(100) sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel ) ¿Estamos corriendo el análisis sobre todos los genes de nuestro dataset? Por default, runPCA() usa un método rápido aproximado que realiza simulaciones, por lo tanto, es necesario ‘configurar la semilla’ para obtener resultados reproducibles 8.6.3 Eligiendo el número de PCs Esta elección en análoga a la elección del numero de HVGs. Elegir más PCs evitará descartar señal biológica a expensas de retener más ruido Es común seleccionar un número de PCs “razonable” pero arbitrario (10-50), continuar con el análisis y regresar para checar la robustez de los resultados en cierto rango de valores Ahora exploraremos algunas estrategias guiadas por los datos (data-driven) para hacer esta selección 8.6.3.1 Usando el punto del codo library(PCAtools) percent.var &lt;- attr(reducedDim(sce.zeisel), &quot;percentVar&quot;) chosen.elbow &lt;- PCAtools::findElbowPoint(percent.var) plot(percent.var, xlab = &quot;PC&quot;, ylab = &quot;Variance explained (%)&quot;) abline(v = chosen.elbow, col = &quot;red&quot;) Una heurística simple es elegir el número de PCs basado en el porcentaje de varianza explicado por PCs sucesivos 8.6.3.2 Basados en la estructura de la población choices &lt;- getClusteredPCs(reducedDim(sce.zeisel)) chosen.clusters &lt;- metadata(choices)$chosen plot(choices$n.pcs, choices$n.clusters, xlab = &quot;Number of PCs&quot;, ylab = &quot;Number of clusters&quot; ) abline(a = 1, b = 1, col = &quot;red&quot;) abline(v = chosen.clusters, col = &quot;grey80&quot;, lty = 2) Esta es una aproximación heurística más sofisticada que usa el número de clusters como un proxy del número de subpoblaciones Supongamos que esperamos d subpoblaciones de células, en ese caso, necesitamos d-1 dimensiones para garantizar la separación de todas las subpoblaciones Pero… en un escenario real realmente no sabes cuántas poblaciones hay… Intenta con un rango para d y únicamente considera valores que produzcan a lo más d+1 clusters Cuando se seleccionan más clusters con menos dimensiones se produce ‘overclustering’ Elige una d que maximice el número de clusters sin caer en ‘overclustering’ Ventaja: Es una solución pragmática que soluciona el equilibrio sesgo-varianza en los análisis posteriores (especialmente clustering) Desventaja: Hace suposiciones fuertes sobre la naturaleza de las diferencias biológicas entre los clusters, y de hecho supone la existencia de clusters, los cuales podrían no existir en procesos biológicos como la diferenciación 8.6.4 Juntando todo set.seed(100) # Compute and store the &#39;full&#39; set of PCs sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel) # Can also select d and store the reduced set of PCs # e.g., using the elbow point reducedDim(sce.zeisel, &quot;PCA_elbow&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.elbow] # e.g., based on population structure reducedDim(sce.zeisel, &quot;PCA_clusters&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.clusters] 8.6.5 EJERCICIO Realiza un PCA para los datos sce.pbmc. Elige el número de PCs a conservar utilizando el método del codo Elige el número de PCs a conservar utilizando la estructura de la población Agrega esta información al objeto sce.pbmc 8.6.6 Usando el ruido técnico library(scran) set.seed(111001001) denoised.pbmc &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc, subset.row = top.pbmc ) Conserva todos los PCs hasta que el % de variación explicado alcance algun límite (por ejemplo, basado en la estimación de la variación técnica) denoisePCA() automáticamente selecciona el número de PCs Por default, denoisePCA() realiza algunas simulaciones, por lo tanto necesitamos ‘configurar la semilla’ para obtener resultados reproducibles dim(reducedDim(denoised.pbmc, &quot;PCA&quot;)) ## [1] 3985 9 La dimensionalidad del output es el límite inferior para el número de PCs requeridos para explicar toda la variación biológica. Lo que significa que cualquier número menor de PCs definitivamente descartará algún aspecto de la señal biológica Esto no grantiza que los PCs retenidos capturen toda la señal biológica Esta técnica usualmente retiene más PCs que el método del punto del codo scran::denoisePCA() internamente limita el numero de PCs, por default 5-50, para evitar la selección de excesivamente pocos PCs (cuando el ruido técnico es alto relativo al ruido biológico) o excesivamente muchos PCs (cuando el ruido técnico es demasiado bajo) 8.6.6.1 ¿Qué pasa si calculamos la relación media-varianza con la función modelGeneVar para el dataset sce.pbmc? dec.pbmc2 &lt;- modelGeneVar(sce.pbmc) denoised.pbmc2 &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc2, subset.row = top.pbmc ) dim(reducedDim(denoised.pbmc2)) ## [1] 3985 5 scran::denoisePCA() tiende a funcionar mejor cuando la relación media-varianza refleja el ruiudo técnico verdadero, i.e estimado por scran::modelGeneVarByPoisson() o scran::modelGeneVarWithSpikes() en vez de scran::modelGeneVar() El dataset PBMC está cerca de este límite inferior: el ruido técnico es alto relativo al ruido biológico 8.6.6.2 ¿Qué pasa si calculamos el número de PCs usando el ruido técnico para el dataset sce.pbmc? set.seed(001001001) denoised.zeisel &lt;- denoisePCA(sce.zeisel, technical = dec.zeisel, subset.row = top.zeisel ) dim(reducedDim(denoised.zeisel)) ## [1] 2815 50 Los datos de cerebro de Zeisel están cerca de este límite superior: el ruido técnico es demasiado bajo 8.7 Reducción de dimensionalidad para visualización 8.7.1 Motivación Clustering y otros algoritmos operaran fácilmente sobre 10-50 (a lo más) PCs, pero ese número es aún demasiado para la visualización Por lo tanto, necesitamos estrategias adicionales para la reducción de dimensionalidad si queremos visualizar los datos 8.7.2 Visualizando con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, colour_by = &quot;level1class&quot; ) PCA es una técnica lineal, por lo tanto, no es eficiente para comprimir diferencias en más de 2 dimensiones en los primeros 2 PCs 8.7.3 Retos y resumen de la visualización con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, ncomponents = 4, colour_by = &quot;level1class&quot; ) Ventajas: PCA es predecible y no introducirá estructura aritficial en los datos Es determínistico y robusto a cambios pequeños en los valores de entrada Desventajas: Usualmente no la visualización no es suficiente para visualizar la naturaleza compleja de los datos de scRNA-seq 8.7.4 Visualización con t-SNE set.seed(00101001101) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) t-stochastic neighbour embedding (t-SNE) es la visualización por excelencia de datos de scRNA-seq. Intenta encontrar una representación (no-lineal) de los datos usando pocas dimensiones que preserve las distancias entre cada punto y sus vecinos en el espacio multi-dimensional 8.7.4.1 Retos de la visualización con t-SNE set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 30 ) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot; ) 8.7.4.2 Preguntas ¿Qué pasa si vuelves a correr runTSNE() sin especificar la semilla? ¿Qué pasa si especificas la semilla pero cambias el valor del parámetro perplexity? 8.7.4.3 Continuando Baja perplejidad favorece la resolución de la estructura fina, posiblemente al grado de que la visualización parece rudio random. set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 5) p1 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 20) p2 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 80) p3 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) library(&quot;patchwork&quot;) p1 + p2 + p3 El siguiente foro discute la selección de parámetros para t-SNE con cierta profundidad No sobreinterpretes los resultados de t-SNE como un ‘mapa’ de las identidades de las células individuales Algunos componentes aleatorios y la selección de parámetros cambiarán la visualización La interpretación puede ser engañada por el tamaño y posición de los clusters t-SNE infla clusters densos y comprime clusters escasos t-SNE no está obligado a preservar las localizaciones relativas de clusters no-vecinos (no puedes interpretar distancias no locales) Aún así: t-SNE es una herramienta probada para visualización general de datos de scRNA-seq y sigue siendo muy popular 8.7.5 Visualización con UMAP Uniform manifold approximation and project (UMAP) es una alternativa a t-SNE Así como t-SNE, UMAP intenta encontrar una representación (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional t-SNE y UMAP están basados en diferentes teorías matemáticas set.seed(1100101001) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) Comparado con t-SNE: UMAP tiende a encontrar clusters visualmente más compactos Intenta preservar más de la estructura global que t-SNE Tiende a ser más rápido que t-SNE, lo cual puede ser importante para datasets grandes. La diferencia desaparece cuando se aplican sobre los primeros PCs 8.7.5.1 Retos de la visualización con UMAP set.seed(100) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;, n_neighbors = 15 ) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) 8.7.5.2 Preguntas ¿Qué pasa si vuelves a correr runUMAP() sin especificar la semilla? ¿Qué pasa si especificas la semilla pero cambias el valor del parámetro n_neighbors? 8.7.5.3 Continuando Igual que para t-SNE, es necesario configurar una semilla y diferentes valores para los parámetros cambiarón la visualización Si el valor para los parámetros n_neighbors o min_dist es demasiado bajo entonces el ruido aleatorio se interpretará como estructura de alta-resolución, si son demasiado altos entonces se perderá la estructura fina TIP: Trata un rango de valores para cada parámetro para asegurarte de que no comprometen ninguna de las conclusiones derivadas de la gráfica UMAP o t-SNE 8.7.6 Interpretando las gráficas Recuerda: Reducción de dimensionalidad para la visualización de los datos necesariamente involucra descartar información y distorsionar las distancias entre las células No sobre interpretes las gráficas bonitas 8.7.7 Resumen y recomendaciones Las gráficas de t-SNE y UMAP son herramientas diagnóstico importantes, por ejemplo: para checar si dos clusters son realmente subclusters vecinos o si un cluster puede ser dividido en más de un cluster Es debatible cual visualización, t-SNE o UMAP, es más útil o estáticamente agradable. Está bien elegir aquella que funcione mejor para tu análisis (tomando en cuenta que tratarás la gráfica únicamente como una herramienta de visualización/diagnóstico y que no llegarás a ninguna conclusión fuerte basado únicamente en la gráfica ) 8.8 Donde estamos 8.9 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:29:32 UTC&quot; proc.time() ## user system elapsed ## 290.224 6.757 291.613 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel * 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## PCAtools * 2.4.0 2021-05-19 [1] Bioconductor ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["clustering.html", "9 Clustering 9.1 Dataset ilustrativo: 10X PBMC4k no filtrado 9.2 Motivación 9.3 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? 9.4 ¿Cuál es el verdadero clustering? 9.5 Clustering basado en grafos 9.6 Evaluando la separación de los clusters 9.7 Otros métodos de clustering 9.8 Evaluando la estabilidad de los clusters 9.9 Subclustering 9.10 Resumen y recomendaciones 9.11 Donde estamos 9.12 Detalles de la sesión de R Patrocinadores", " 9 Clustering Instructora: Laura Gómez-Romero Este contenido está basado en las diapositivas de Peter Hickey. Ve las diapositivas aquí. Y en el curso de OSCA, lee el material aquí 9.1 Dataset ilustrativo: 10X PBMC4k no filtrado library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset de células mononucleares de sangre periférica humana (PBMC) de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) # dimensionality-reduction set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) ¿Alquien me puede explicar que hace el método que etamos usando para reducir la dimensionalidad de los datos? ¿Los HGVs están almacenados en nuestro objeto sce.pbmc? 9.2 Motivación Clustering es un procedimiento no supervisado par definir grupos de células con perfiles de expresión similares Su propósito principal es resumir los datos en un formato digerido susceptible a interpretación humana Nos permite asignar etiquetas (por ejemplo, tipos celulares) a las células 9.3 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? Las técnicas de t-SNE/UMAP han comprimido datos altamente multi-dimensionales en dos dimensiones Esta compresión inevitablemente ha provocado la perdida de información Por lo tanto, agrupamos sobre los PCs y después visualizamos las identidades de los clusters en la gráfica t-SNE/UMAP 9.4 ¿Cuál es el verdadero clustering? Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido 9.5 Clustering basado en grafos 9.5.1 Antecedentes El clustering basado en grafos fue popularizado (más no inventado) por su uso en Seurat Objetivo: Construir un grafo en el que cada nodo es una célula que está conectada a sus vecinos más cercanos en el espacio multidimensional 9.5.2 Gráfica de los k vecinos más cercanos (k-nearest neighbour -KNN- graph) Ilustremos como funciona para 20 células 9.5.3 Gráfica de los vecinos más próximos compartidos (SNN) De una gráfica KNN se puede construir una grafica SNN En este tipo de grago, dos células estarán conectadas por una arista si comparten alguno de sus vecinos más próximos. Podemos asignar pesos a cada arista del grafo, basándonos en la similaridad de las células involucradas, dándole pesos más altos a células que están más cercanamente relacionadas 9.5.4 Gráfica SNN con pesos en las aristas Para ver los distintos esquemas de pesado puedes consultar la documentación de la función makeSNNGraph del paquete bluster. Algunos ejemplos son: -Rango: El peso entre dos nodos está dado por k-r/2 donde r es la suma más pequeña de los rangos (de proximidad, el vecino más cercano tiene el rango 1) para cualquiera de los vecinos compartidos -Número: el peso entre dos nodos es igual al número de vecinos más próximos compartidos -Jaccard: el peso entre dos nodos es igual a la similaridad de Jaccard entre los conjuntos de vecinos de estos nodos 9.5.5 Obteniendo comunidades a partir de una gráfica SNN pesada mediante un algoritmo de clustering A partir de una gráfica SNN pesada podemos aplicar algoritmos para identificar comunidades de células Comunidades son grupos de células que están más conectadas a células en el mismo grupo que lo que están a células de un grupo diferente Cada comunidad representa un cluster 9.5.6 Resumen de clustering basado en grafos La construcción y búsqueda de una red KNN es rápida, por lo tanto, es escalable para datasets grandes Debes evitar obtener conclusiones fuertes acerca de la forma de los clusters o la distribución de células dentro de cada cluster El algoritmo, conecta cada célula con un número mínimo de células vecinas, lo cual reduce el riesgo de clusters no informativos con unos pocos outliers Después de la construcción del grafo, no se almacena información adicional más alla de las células vecinas. Esto puede producir subclusters artificiales en regiones con muchas células 9.5.7 Detalles a considerar en la implementación ¿Cuántas céulas vecinas debo considerar durante la construcción del grafo? ¿Cómo debo pesar las aristas? ¿Cuál algoritmo de detección de comunidades se debe usar para definir los clusters? 9.5.8 Implementación library(scran) # Build graph using k = 10 nearest neighbours in PCA-space g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust &lt;- igraph::cluster_walktrap(g)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster &lt;- factor(clust) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) ¿Qué pasa si utilizas una k más grande o más pequeña? library(scran) # Build graph using k = 50 nearest neighbours in PCA-space g50 &lt;- buildSNNGraph(sce.pbmc, k = 50, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust50 &lt;- igraph::cluster_walktrap(g50)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster50 &lt;- factor(clust50) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster50&quot;) En esta implementación: La construcción de la red KNN se baso en la distancia Euclideana entre células La construcción de la red KNN implica que las aristas se crean entre todos los pares de células que comparten por lo menos un vecino Se utilizó el esquema de peso de: Xu and Su (2015) 9.5.9 Eligiendo un valor de k El valor de k puede ser toscamente interpretado como el tamaño anticipado de la subpoblación más pequeña Si una subpoblación tiene menos que (k+1) células entonces el método será forzado a construir aristas entre células de esa subpoblación y células de otras subpoblaciones Esto incrementa el riesgo de que la subpoblación en cuestión no forme su propio cluster 9.5.10 Una implementación diferente: estilo Seurat # Jaccard-based weights followed by Louvain clustering # aka &#39;Seurat-style&#39; clustering g2 &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) clust2 &lt;- igraph::cluster_louvain(g2)$membership sce.pbmc$cluster2 &lt;- factor(clust2) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) 9.5.11 Detalles de las implementaciones más comunes Pipelines basados en Seurat: Pesos basados en Jacard Clustering Louvain Pipelines basados en Scran: Pesos basados en Randos Clustering Walktrap Para detalles sobre la seleccion de parámetros y comparaciones: visitar esta página. library(&quot;patchwork&quot;) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) + plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) Estilo scran vs estilo Seurat. 9.5.12 Otras implementaciones Distintas métricas de distancia g.num &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;, type = &quot;number&quot;) g.jaccard &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) g.none &lt;- buildKNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) Distintos métodos de clustering clust.louvain &lt;- igraph::cluster_louvain(g)$membership clust.infomap &lt;- igraph::cluster_infomap(g)$membership clust.fast &lt;- igraph::cluster_fast_greedy(g)$membership clust.labprop &lt;- igraph::cluster_label_prop(g)$membership clust.eigen &lt;- igraph::cluster_leading_eigen(g)$membership 9.6 Evaluando la separación de los clusters Modularidad es una métrica natural para evaluar la separación entre comunidades/clusters La modularidad se define como la diferencia (escalada) entre el peso total observado de las aristas entre los nodos en el mismo cluster y el peso total esperado si los pesos fueran distribuidos aleatoriamente entre todos los pares de nodos Nosotros calcularemos un score de modularidad para cada cluster usando las tasas en vez de las diferencias, debido a que las tasas no se ven tan fuertemente influenciadas por el tamaño de los clusters library(bluster) # obteniendo la métrica de modularidad ratio &lt;- pairwiseModularity(g, clust, as.ratio = TRUE) dim(ratio) ## [1] 16 16 library(pheatmap) pheatmap(log2(ratio + 1), cluster_rows = FALSE, cluster_cols = FALSE, color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(100) ) Un dataset que contiene clusters bien separados debería contener la mayoría del peso total observado en las entradas diagonales, i.e la mayoría de las aristas ocurren entre células del mismo cluster Para más detalles sobre evaluación de la separación entre clusters visite esta página 9.7 Otros métodos de clustering Clustering por k-means PRO: Rápido Se debe especificar el número de clusters de antemano Favorece clusters esféricos Clustering jerárquico Produce un dendograma (árbol) representando las células y la similaridad entre subpoblaciones a varias resoluciones Demasiado lento para correrse en algo más grande que los datasets más pequeños de scRNA-seq 9.8 Evaluando la estabilidad de los clusters Una propiedad deseable de un cluster dado es que éste sea estable a las perturbaciones en los datos de entrada, de esta manera: Pequeños cambios al procesamiento no cambiarán el resultado Se incrementa la probabilidad de que las conclusiones puedan ser replicadas en un estudio independiente Uno puede hacer un proceso de bootstrap para evaluar la estabilidad de un algoritmo de clustering en un dataset dado y calcular la coasignación. La coasignación es la probabilidad de que células elegidas al azar del cluster X y Y sean asignadas al mismo cluster en la réplica del proceso de bootstrap myClusterFUN &lt;- function(x) { g &lt;- buildSNNGraph(x, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) igraph::cluster_louvain(g)$membership } originals &lt;- myClusterFUN(sce.pbmc) set.seed(0010010100) coassign &lt;- bootstrapStability(sce.pbmc, FUN = myClusterFUN, clusters = originals ) pheatmap(coassign, cluster_row = FALSE, cluster_col = FALSE, color = rev(viridis::magma(100)) ) Probabilidad alta de coasignación indica que X no es estable con respecto a su separación de Y. Queremos altas probabilidades de coasignación en la diagonal Debes considerar que el bootstraping solo considera el efecto del ruido de muestreo e ignora otros factores que pueden afectar la reproducibilidad (como efectos de batch o variación entre los donadores) Además, una pobre separación puede ser altamente estable 9.9 Subclustering Mejora la resolucón al repetir el proceso de feature selection y clustering dentro de un único cluster Se enfoca en los HGVs y PCs que son los más relevantes para un cluster específico g.full &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) clust.full &lt;- igraph::cluster_walktrap(g.full)$membership sce.pbmc$clust.full &lt;- factor(clust.full) plotExpression(sce.pbmc, features = c(&quot;CD3E&quot;, &quot;CCR7&quot;, &quot;CD69&quot;, &quot;CD44&quot;), x = &quot;clust.full&quot;, colour_by = &quot;clust.full&quot; ) CD3E, CCR7, CD69, y CD44 son marcadores de células T de memoria. Dentro de las células T de memoria, ¿dónde están las subpoblaciones CD4+ y CD8+? # Repeating modelling and PCA on the subset of cells we have # identified as memory T-cells (cluster 6). memory &lt;- 10 sce.memory &lt;- sce.pbmc[, clust.full == memory] dec.memory &lt;- modelGeneVar(sce.memory) sce.memory &lt;- denoisePCA(sce.memory, technical = dec.memory, subset.row = getTopHVGs(dec.memory, prop = 0.1) ) # Repeating clustering on the subset. g.memory &lt;- buildSNNGraph(sce.memory, use.dimred = &quot;PCA&quot;) clust.memory &lt;- igraph::cluster_walktrap(g.memory)$membership sce.memory$clust.memory &lt;- factor(clust.memory) plotExpression(sce.memory, features = c(&quot;CD8A&quot;, &quot;CD4&quot;), x = &quot;clust.memory&quot; ) Expresión de CD4 es bajo, por lo tanto, su cambio es modesto, pero la interpretación es clara scran::quickSubCluster() ciclará sobre los clusters y realizará el proceso de subclustering de acuerdo a una función especificada por el usuario. Esto asume que la misma función es apropiada para todos los clusters Si tipos celulares o estados celulares se extienden sobre las fronteras de los clusters, entonces un subcluster podría representar contaminación de un tipo celular en un cluster separado 9.10 Resumen y recomendaciones Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido Clustering basado en grafos es rápido y evita tener que hacer suposiciones fuertes sobre la forma de los clusters o la distribución de las células dentro de cada cluster: scran::buildSNNGraph() igraph::cluster_walktrap() o igraph::cluster_louvain() Modularidad y estabilidad de los clusters son diagnósticos útiles El proceso de subclustering podría mejorar la resolución dentro de clusters grandes 9.11 Donde estamos 9.12 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:33:26 UTC&quot; proc.time() ## user system elapsed ## 231.410 5.774 233.696 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster * 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["identificación-de-genes-marcadores.html", "10 Identificación de genes marcadores 10.1 Diapositivas de Peter Hickey 10.2 Motivación 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.4 Motivación - continuación 10.5 Prueba t modificada de Welch pareada 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.7 Aplicación estándar 10.8 Usando el log-fold change 10.9 Encontrando marcadores específicos de clústeres 10.10 Pruebas alternas 10.11 Prueba de rangos de Wilcoxon 10.12 Prueba binomial 10.13 Métodos de expresión diferencial personalizados 10.14 Problemas estadísticos 10.15 Resumen y recomendaciones 10.16 Detalles de la sesión de R Patrocinadores", " 10 Identificación de genes marcadores Instructora: Yalbi I. Balderas-Martínez. 10.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 10.2 Motivación Ahora que hemos obtenido los clústeres, nos preguntamos, pero qué son? (e.g. ¿qué tipo celular es el clúster 1?) ¿Cuáles genes están dirigiendo el agrupamiento (e.g., ¿cuáles son los genes diferencialmente expresados entre los clústeres 1 y 2?) Idea: Mirar las diferencias en los perfiles de expresión de las células de los diferentes clústeres 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.3.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 21 10.3.2 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 10.3.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 10.3.4 Genes variables ## Identificación de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 10.3.5 Reducción de dimensiones ## Reducción de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 10.3.6 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 10.4 Motivación - continuación ¿Algunos de estos genes están asociados con los resultados de clustering? # Is gene 1 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[1], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene 2 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[2], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene 2512 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[2512], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene CD3E associated with the clustering? plotExpression(sce.pbmc, features = &quot;CD3E&quot;, x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) Ver una gráfica como una forma de encontrar los genes marcadores obviamente no nos sirve a gran escala Necesitamos un método estadístico para identificar estos genes marcadores 👉 La prueba t de Welch es una opción obvia para probar las diferencias en la expresión entre clústeres 10.5 Prueba t modificada de Welch pareada ➕ Rápidas y buenas propiedades estadísticas para un gran número de células (Soneson and Robinson, 2018) ➕ Las comparaciones pareadas proveen un log-fold change para indicar cuáles clústerse son distinguidos por cada gen 🤔 ¿Por qué no comparar cada clúster con el promedio de todas las otras células? Sensible a la composición poblacional, una subpoblación dominante sola que dirige la selección de los marcadores top para cualquier otro clúster 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.6.1 Pruebas pareadas plotExpression(sce.pbmc, features = &quot;CD3E&quot;, x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) comparison logFC Pval 1 vs 2 1.50 1.7e-198 1 vs 3 -0.08 0.11 … … … 2 vs 1 1.39 1.7e-198 … … … 18 vs 17 0.11 0.46 K = 18 clústeres K!/(K-2)! = 306 comparaciones La mitad de ellas son redundantes 10.6.2 Combinando comparaciones del gen CD3E para el clúster 1 “Me interesa saber si el gen CD3 está diferencialmente expresado entre el clúster 1 y ..” cualquier (any) otro clúster = P = 1.3 x 10-205 (Simes adjusted P-value) todos (all) los otros clústeres = P = 0.11 (Berger’s intersection-union test) algunos (some) de los otros clústeres = P = 2.0 x 10-44 (mediana u otro cuantil, Holm-adjusted P-values) 10.6.2.1 Extendiendo a todos los genes scran::pairwiseTTests() scran::combineMarkers() M = 33,694 genes 🤓 K x M = 10,310,364 pruebas Comparaciones involucrando clúster 1… Comparaciones involucrando clúster … Comparaciones involucrando clúster 18 10.7 Aplicación estándar Para cada clúster, usar pruebas t de Welch para identificar los genes que están diferencialmente expresados entre éste y cualquier (any) otro clúster # scran::findMarkers() library(scran) markers.pbmc &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, pval.type = &quot;any&quot; ) 10.7.1 Explorando los resultados chosen &lt;- &quot;9&quot; interesting &lt;- markers.pbmc[[chosen]] plotExpression(sce.pbmc, rownames(interesting)[1:4], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) 10.7.2 Con un heatmap best.set &lt;- interesting[interesting$Top &lt;= 6, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) library(pheatmap) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) 👉 Usamos el campo Top para identificar un conjunto de genes que distinguen el clúster 9 de cualquier otro clúster 10.8 Usando el log-fold change 10.8.1 Sin espeficiar el lfc Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados entre éste y cualquier otro clúster markers.pbmc.up &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.up &lt;- markers.pbmc.up[[chosen]] 10.8.2 Especificando el lfc Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados con un log-fold change (lfc) o al menos 1 entre éste y cualquier otro clúster markers.pbmc.up2 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, lfc = 1, pval.type = &quot;any&quot; ) interesting.up2 &lt;- markers.pbmc.up2[[chosen]] 👉 La prueba t también nos permite especificar un log-fold change diferente de cero como la hipótesis nula 🤓 Es más riguroso que simplemente filtrar por log-fold change TREAT 10.8.3 Heatmap best.set &lt;- interesting.up2[interesting.up2$Top &lt;= 5, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) 👉 Los promedios están más centrados en un conjunto de genes marcadores candidatos que están sobreexpresados en el clúster 9 ⚠️ El incremento del rigor no se da sin costo ⚠️ Si el lfc es muy grande podría descartar genes útiles E.g., un gen sobreexpresado en una proporción pequeña de células en un clúster sigue siendo un marcador efectivo si el foco está en la especificidad más que en la sensibilidad 10.9 Encontrando marcadores específicos de clústeres 👉 Por defecto, scran::findMarkers() dará un alto rango a genes que están DE en cualquier comparación pareada 🤔 Quiero genes que son específicos de cada clúster 👉 Tú quieres genes que son DE en todas las comparaciones pareadas Para cada clúster, usa pruebas t de Welch para identificar genes que están sobreexpresados entre éste y todos los otros clústeres markers.pbmc.up3 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;all&quot; ) interesting.up3 &lt;- markers.pbmc.up3[[chosen]] 🤓 Usa una prueba de unión-intersección para combinar los P-values que es el máximo P-value de todas las comparaciones pareadas 10.9.1 Pros/cons de los genes marcadores específicos de los clústeres Poblacion Expresion_CD4 Expresion_CD8 DN(CD4-/CD8-) No No CD4+&gt; Si No CD8+&gt; No Si DP(CD4+/CD8+) Si Si 10.9.2 findMarkers con pval.type some Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados entre éste y algunos de los otros clústers markers.pbmc.up4 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;some&quot; ) interesting.up4 &lt;- markers.pbmc.up4[[chosen]] 👉 Para cuando pval.type=\"all\" es muy estricto todavía pval.type=\"any\" es muy generoso 🤓 Aplica la corrección Holm-Bonferroni a los P-values y toma el mejor valor de en medio como el P-value combinado ⚠️ Perderás algunas garantías ofrecidas por los otros métodos 10.10 Pruebas alternas 10.10.1 Motivación La prueba t no es la única forma de comparar dos grupos de mediciones 🤔 Quiero una prueba que pueda ser usada perfectamente para distinguir dos clústeres uno del otro 👉 Prueba de rangos Wilcoxon 🤔 Quiero identificar genes que son expresados más frecuentemente en un clúster que en otro 👉 Prueba Binomial 10.11 Prueba de rangos de Wilcoxon Evalúa directamente la separación entre la distribución de la expresión de los diferentes clústeres 🤓 Es proporcional al área bajo la curva (AUC), que es la probabilidad de que una célula al azar de un clúster tenga mayor que expresión que una célula al azar de otro clúster 👉 AUCs de 1 o 0 indican que los dos clústeres tienen distribuciones de expresión separadas 🤓 También se conoce como prueba Wilcoxon-Mann-Whitney (WMW) 10.11.1 findMarkers para Wilcoxon Para cada clúster, usa la prueba de rangos de Wilcoxon para identificar genes que están sobreexpresados entre éste y cualquier otro clúster markers.pbmc.wmw &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;wilcox&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.wmw &lt;- markers.pbmc.wmw[[chosen]] 10.11.2 Heatmap de genes marcadores con Wilcoxon best.set &lt;- interesting.wmw[interesting.wmw$Top &lt;= 5, ] AUCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(AUCs) &lt;- sub(&quot;AUC.&quot;, &quot;&quot;, colnames(AUCs)) pheatmap(AUCs, breaks = seq(0, 1, length.out = 21), color = viridis::viridis(21) ) 10.11.3 Resumen de la prueba de rangos de Wilcoxon ➕ Ofrece directamente la propiedad deseable de un gen marcador (i.e. que el gen distinga perfectamente entre dos clústeres) ➕ Es simétrico con respecto a las diferencias en el tamaño de los grupos comparados ➖ Es mucho más lento comparado con la prueba t (aunque esto en general no es un problema en la práctica) 10.12 Prueba binomial Es una prueba que identifica los genes que difieren en la proporción de células que se expresan entre clústeres Una definición mucho más estricta de genes marcadores 🤓 Convierte la expresión en una medida binaria de presencia/ausencia, por lo que toda la información cuantitativa es ignorada Desde una perspectiva práctica, puede ser más fácil para validar 10.12.1 findMarkers para binomial Para cada clúster, usa la prueba Binomial para identificar genes que están más frecuentemente expresados (sobreexpresados) en comparación con cualquier otro clúster markers.pbmc.binom &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;binom&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.binom &lt;- markers.pbmc.binom[[chosen]] 🤓 El efecto en el tamaño se reporta como el log-fold change en la proporción de las células que se expresan entre clústeres 👉 Log-fold changes grandes positivos, indican que el gen está más frecuentemente expresado en un clúster comparado con otro 10.12.2 Visualizando genes marcadores de la prueba bionomial top.genes &lt;- head(rownames(interesting.binom)) plotExpression(sce.pbmc, x = &quot;cluster&quot;, features = top.genes) 10.12.3 Resumen de la prueba binomial La prueba Binomial no toma en cuenta la normalización ➕ Produce genes marcadores que pueden ser más fáciles de validar ➖ Ser más estricto puede llevar a la pérdida de buenos marcadores candidatos 10.13 Métodos de expresión diferencial personalizados 🤔 ¿Por qué no usar edgeR/DESeq2/limma-voom u otros métodos personalizados (e.g., MAST)? 👉 Claro que puedes! Checa OSCA 👉 Pero éstos son tal vez algo exagerados para identificar genes marcadores 🤓 Las células son nuestras “réplicas” para el propósito de identificar genes marcadores 🤓 edgeR/DESeq2/limma-voom hacen asunciones más fuertes acerca de los datos que es más probable que no se cumplan para células individuales en scRNA-seq 10.14 Problemas estadísticos 10.14.1 Invalidez de P-values Todas las estrategias de DE para detectar genes marcadores entre clústeres son estadísticamente defectuosas de alguna manera 🤓 “Dragado de datos”: El análisis DE se realiza usando los mismos datos usados para obtener los clústeres 👉 Las pruebas para genes DE entre clústeres producirá inevitablemente algunos resultados significativos y así es como los clústeres serán definidos! 👉 Aún cuando los P-values son defectuosos, el efecto no es muy dañino para la detección de genes ya que los P-values solo son usados para los rangos 🤓 No se pueden usar P-values para definir “diferencias significativas” entre los clústeres con respecto a un umbral de la tasa de error 10.14.2 Naturaleza de la replicación 👉 Idealmente, validar algunos de los marcadores con una población de células independientes (y idealmente usando una técnica diferente, e.g., hibridación fluorescente in situ o qPCR) 10.14.3 Comentarios adicionales 👉 La estrategia de análisis DE es que los marcadores son definidos relativo a subpoblaciones en el mismo dataset 👉 Si un gen se expresa uniformemente a través de la población no servirá como un marcador e.g., los marcadores de las células T no serán detectados si solamente hay células T en los datos usualmente no es un problema, ya que tenemos idea de las células que se capturaron 👉 Existen métodos de machine learning para hacer la identificación de los genes marcadores, pero la humilde prueba t sigue siendo muy buena 10.15 Resumen y recomendaciones 👉 Crea múltiples listas de genes marcadores con diferentes niveles de rigor 👉 La forma más simple de interpretar los genes marcadores es que son los sobreexpresados de “forma única”, o son “genes específicos de clústeres”, especialmente si queremos imponer un log-fold change mínimo 👉 Puedes requerir hacer una identificación de genes marcadores más enfocada, e.g., subset de los datos de solo 2 clústeres de interés y entonces correr scran::findMarkers() 10.16 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:39:06 UTC&quot; proc.time() ## user system elapsed ## 337.015 4.850 338.857 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra * 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ "],["anotación-de-clusters-de-células.html", "11 Anotación de clusters de células 11.1 Diapositivas de Peter Hickey 11.2 Motivación 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.5 SingleR 11.6 Resumen de la anotación basada en una referencia (e.g., SingleR) 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores 11.8 Resumen y recomendaciones 11.9 Detalles de la sesión de R Patrocinadores", " 11 Anotación de clusters de células Instructora: Yalbi I. Balderas-Martínez. 11.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 11.2 Motivación Ahora estamos a punto de obtener la interpretación biológica de los resultados Esta es la tarea más retadora en los análisis de datos scRNA-seq 👉 La obtención de clústeres es más o menos directa 🤔 ¿Cuál es el estado biológico que está representado por cada uno de los clústeres? 👉 Necesitamos hacer un puente entre el gap del dataset actual y el conocimiento biológico a priori (no siempre está disponible en una forma consistente y cualitativa) 🤔 ¿Qué es un tipo celular? 🔬 “Lo sabré cuando lo vea” 💻 “No” Aplicaremos varios métodos computacionales que explotan la información a priori para asignar el significado a un dataset no caracterizado de scRNA-seq. Algunas fuentes de información a priori Conjuntos de genes curados (e.g. Gene Ontology) Perfiles de expresión de bases de datos publicadas de referencia Los datos raros que tú hayas escondido en tu cerebro Google 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 22 11.3.1 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 11.3.2 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 11.3.3 Genes variables ## Identificación de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 11.3.4 Reducción de dimensiones ## Reducción de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 11.3.5 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.4.1 Visión general 👉 Un enfoque directo es comparar los perfiles de expresión single-cell con datasets previamente anotados 👉 Las etiquetas pueden entonces ser asignadas a cada célula en nuestro dataset no caracterizado de prueba basado en la muestra de referencia más similar, por dar alguna definición de “similar” 👉 Cualquier dataset de expresión génica etiquetado (microarreglos, RNA-seq bulk, scRNA-seq) puede ser usado como una referencia ⚠️ Sin embargo, su confiabilidad depende enormemente en la calidad de los datos originales y la experiencia de los autores originales quienes asignaron las etiquetas en primer lugar 👉 Asignar las etiquetas a un dataset de “prueba” a partir de un dataset de “entrenamiento” (referencia), es un problema estándar en estadística / machine learning 👉 Usaremos el método SingleR (Aran et al. 2019) 11.5 SingleR 🤓 Asigna las etiquetas a las células basado en las muestras de referencia con las correlaciones de rangos más altas de Spearman 🤓 Para reducir el ruido, identifica genes marcadores entre pares de etiquetas (en la referencia) y calcula la correlación usando solamente esos marcadores 🤓 Hace algún tipo de tuneado fino, repitiendo las correlaciones solamente con los genes marcadores de las etiquetas con el mejor score, ayudando a resolver cualquier ambigüedad entre esas etiquetas al eliminar el ruido a partir de marcadores irrelevantes para otras etiquetas 11.5.1 SingleR incluye varias referencias Ver referencias # Human celldex::BlueprintEncodeData() celldex::DatabaseImmuneCellExpressionData() celldex::HumanPrimaryCellAtlasData() celldex::MonacoImmuneData() celldex::NovershternHematopoieticData() # Mice celldex::ImmGenData() celldex::MouseRNASeqData() 11.5.2 Usando las referencias # if needed install celldex # create directory? y library(celldex) ref &lt;- celldex::BlueprintEncodeData() ❓ ¿Qué tipos celulares están disponibles en este dataset de referencia? 11.5.3 Usando las referencias integradas library(SingleR) pred &lt;- SingleR( test = sce.pbmc, ref = ref, labels = ref$label.main ) ❓ ¿Qué etiquetas han sido asignadas a los datos single-cell? ❓ ¿Cómo usaríamos las etiquetas “finas” con SingleR? plotScoreHeatmap(pred) 👉 Inspeccionamos los resultados usando un heatmap de los scores por célula y por etiqueta 👉 Idealmente, cada célula debería exhibir un score alto en una etiqueta relativa a todas las otras 👉 Los scores se muestran antes de cualquier tuneado fino y son normalizadas a [0, 1] dentro de cada célula 11.5.4 Podado de etiquetas (Label pruning) total_pruned &lt;- sum(is.na(pred$pruned.labels)) plotScoreHeatmap(pred, show.pruned = TRUE) 👉 SingleR intentará podar aquellas asignaciones de baja calidad marcándolas como NA 🤓 El podado se hace calculando la diferencia del score de la etiqueta asignada a partir del score de la mediana dentro de cada célula y entonces podando las células con un valor pequeño de esta diferencia plotScoreDistribution(pred) 👉 Distribución de las diferencias del score de la etiqueta asignada a partir del score de la mediana dentro de cada célula 11.5.5 Identificando los genes con anotación dirigida 🤔 ¿Por qué las células en este clúster se etiquetan como el tipo celular X? 👉 Examina la expresión de los genes marcadores para cada etiqueta en el dataset de prueba 👉 Si una célula en el dataset de prueba está asignado con confianza a una etiqueta en particular, uno esperaría que tenga una fuerte expresión de los marcadores de esa etiqueta (al menos sobreexpresión con respecto a las células asignadas a otras etiquetas) # install gmp, ClusterR, mbkmeans dependencies if needed sce.pbmc$labels &lt;- pred$labels all.markers &lt;- metadata(pred)$de.genes lab &lt;- &quot;B-cells&quot; # Get top-10 marker genes for B-cells compared to each other cell # type top.markers &lt;- Reduce(union, sapply(all.markers[[lab]], head, 10)) plotHeatmap(sce.pbmc, order_columns_by = &quot;labels&quot;, features = top.markers, center = TRUE, zlim = c(-3, 3), main = lab ) ❓ Toma otro tipo celular e identifica los genes que dirigen la anotación 11.5.6 Comparando las etiquetas con los clústeres tab &lt;- table(Assigned = pred$pruned.labels, Cluster = sce.pbmc$cluster) library(pheatmap) # Proportion of cells in each cluster assigned to each label pheatmap(prop.table(tab, margin = 2), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) # (log-)number of cells in each cluster assigned to each label # Adding a pseudo-count of 10 to avoid strong color jumps with just # 1 cell. pheatmap(log2(tab + 10), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) 11.5.7 Voilà plotTSNE(sce.pbmc, colour_by = &quot;labels&quot;, text_by = &quot;labels&quot;) plotTSNE(sce.pbmc, colour_by = &quot;cluster&quot;, text_by = &quot;labels&quot;) 11.5.7.1 Aventura en el tiempo Hmm. We can't figure out why these two plots are different with the same code, though different R versions.BioC 3.11? @PeteHaitch https://t.co/8DJM6pagdjBioC 3.13https://t.co/t8KiPTyU9D@Bioconductor #rstats @yalbi_ibm @AnaBetty2304 pic.twitter.com/P65u7dnVCo — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 10, 2021 https://github.com/MarioniLab/DropletUtils/issues/67 Ok, not identical, but not bad with BioC 3.13 onlyLeft: BioC 3.13 with e.out from BioC 3.111Middle: Pete's slides with BioC 3.11Right: BioC 3.13 only#rstats #OSCA @Bioconductor #DropletUtils pic.twitter.com/d41LiuXKWn — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 11, 2021 11.6 Resumen de la anotación basada en una referencia (e.g., SingleR) ➕ Se centra en aspectos de los datos que se sabe son interesantes, simplifica el proceso de la interpretación biológica ➖ Está restringido por la diversidad y la resolución de las etiquetas disponibles en el dataset de referencia 👉 Se pueden suplir referencias personalizadas a SingleR 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores 🤔 ¿Cómo podemos hacer uso de nuestros genes marcadores agrupados? 🥉 Revisarlos en hojas de cálculo 🥈 Observar heatmaps 🥇 Realizar un gene set enrichment analysis 11.7.1 Gene set enrichment analysis 👉 Identifica las rutas y procesos que están (relativamente) activos en cada clúster basado en la sobreexpresión de los genes asociados en comparación con otros clústeres ➕ Un método confiable para determinar si las rutas están sobre- o sub- expresadas entre clúesteres ➕ Existen un montón de herramientas para gene set enrichment analysis ➖ Todas las conclusiones son relativas a otros clústeres, haciéndolo más difícil para determinar la identidad celular si alguno no está presente en el mismo estudio más info 11.7.2 Calculando las actividades de los conjuntos de genes 👉 Calcular el promedio de la expresión en log en todos los genes, en un conjunto de genes para cada célula y examinar los clústeres con valores altos (gene set activities) 👉 Se necesita proveer de conjuntos de genes ➖ No todos los genes en el conjunto pueden exhibir el mismo patrón de diferencia y los genes no-DE añadirán ruido, “diluyendo” la fuerza de cualquiera de las diferencias comparadas a un análisis que se centra directamente en genes DE 👉 Es más una visualización útil que la base para cualquier análisis estadístico real más info 11.8 Resumen y recomendaciones 👉 La anotación de tipos celulares “automática”, como SingleR, es mejor cuando funciona (i.e. cuando hay un dataset de referencia apropiado) 👉 Usualmente necesitaremos usar un método manual, como aquellos basados en agrupar los genes marcadores (e.g., gene set enrichment analysis) 👉 La anotación del tipo celular ofrecerá una reconsideración inmediata de los parámetros del agrupamiento y/o algunos retoques manuales a los clústeres 11.9 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:42:29 UTC&quot; proc.time() ## user system elapsed ## 200.819 4.594 202.975 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## celldex * 1.2.0 2021-05-20 [1] Bioconductor ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## SingleR * 1.6.1 2021-05-20 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ "],["análisis-de-expresión-diferencial.html", "12 Análisis de expresión diferencial 12.1 Diapositivas de Peter Hickey 12.2 Motivación 12.3 Datos de ejemplo 12.4 Análisis de expresión diferencial 12.5 Análisis de abundancia diferencial 12.6 Comentarios sobre la interpretación 12.7 Detalles de la sesión de R Patrocinadores", " 12 Análisis de expresión diferencial Instructor: Leonardo Collado Torres ## Paquetes de este capítulo library(&quot;MouseGastrulationData&quot;) ## para descargar datos de ejemplo library(&quot;scater&quot;) ## para gráficas y control de calidad library(&quot;scran&quot;) ## para selección de genes, clustering, etc library(&quot;batchelor&quot;) ## para métodos de correción de batch (lote) library(&quot;patchwork&quot;) ## para agrupar gráficas library(&quot;Polychrome&quot;) ## para muchos colores library(&quot;bluster&quot;) ## métodos de clustering library(&quot;edgeR&quot;) ## para expresión diferencial 12.1 Diapositivas de Peter Hickey Ve las diapositivas aquí. Esas diapositivas están basadas en este capítulo de OSCA. El libro de OSCA tiene algunas partes más actualizadas de lo que vienen en las diapositivas. 12.2 Motivación 👉 scRNA-seq nos puede ayudar a estudiar cambios en composición (cambios en proporciones de células) o cambios en niveles de expresión de genes entre varias condiciones biológicas El primero se llama cambios de abundancia, Ejemplo: después de un tratamiento con una droga Ejemplo: después de modificaciones genéticas 👉 Nos permite obtener mayor resolución biológica que experimentos convencionales de RNA-seq, sobre todo si podemos asociar cambios en poblaciones celulares a manipulaciones experimentales 12.2.1 Dos categorías de análisis 👉 Análisis de expresión diferencial Buscamos cambios en niveles de expresión entre condiciones para células del mismo tipo que están presentes en todas las condiciones 👉 Análisis de abundancia diferencial Buscamos cambios en la composición de los tipos celulares entre condiciones Podría ser entre estados celulares en vez de tipos celulares Son dos lados de la misma moneda 12.2.1.1 Expresión diferencial gene condición celula expresión gene1 grupo1 celula1 13.31 gene1 grupo2 celula1 6.15 gene2 grupo1 celula1 9.67 gene2 grupo2 celula1 11.53 gene1 grupo1 celula2 10.89 gene1 grupo2 celula2 7.65 gene2 grupo1 celula2 10.97 gene2 grupo2 celula2 9.37 12.2.1.2 Abundancia diferencial condición celula frecuencia grupo1 celula1 47 grupo2 celula1 32 grupo1 celula2 39 grupo2 celula2 43 12.3 Datos de ejemplo Embriones de ratón quiméricos. Chimeric E8.5 mouse embryos td-Tomato+ ESCs injected into WT blastocyst No genetic differences between the injected and background cells (except expression of td-Tomato in the former) 3 replicate batches Each batch contains td-Tomato+ and td-Tomato- cells sorted from a single pool of dissociated cells from 6-7 chimeric embryos 2,000 - 7,000 cells/sample using 10X Genomics Aim is to determine whether the injection procedure itself introduces differences in lineage commitment compared to the background cells https://bioconductor.org/books/release/OSCA/pijuan-sala-chimeric-mouse-embryo-10x-genomics.html Pijuan-Sala, B. et al. A single-cell molecular map of mouse gastrulation and early organogenesis. Nature 566, 490–495 (2019). 12.3.1 Descarguemos los datos de ejemplo #--- loading ---# library(&quot;MouseGastrulationData&quot;) sce.chimera &lt;- WTChimeraData(samples = 5:10) sce.chimera ## class: SingleCellExperiment ## dim: 29453 20935 ## metadata(0): ## assays(1): counts ## rownames(29453): ENSMUSG00000051951 ENSMUSG00000089699 ... ## ENSMUSG00000095742 tomato-td ## rowData names(2): ENSEMBL SYMBOL ## colnames(20935): cell_9769 cell_9770 ... cell_30702 cell_30703 ## colData names(11): cell barcode ... doub.density sizeFactor ## reducedDimNames(2): pca.corrected.E7.5 pca.corrected.E8.5 ## mainExpName: NULL ## altExpNames(0): ## Exploremos los datos sapply(colData(sce.chimera)[, -(1:2)], function(x) { x &lt;- if (is.character(x) || is.integer(x)) factor(x) else x summary(x) }) ## $sample ## 5 6 7 8 9 10 ## 2411 1047 3007 3097 4544 6829 ## ## $stage ## E8.5 ## 20935 ## ## $tomato ## Mode FALSE TRUE ## logical 10973 9962 ## ## $pool ## 3 4 5 ## 3458 6104 11373 ## ## $stage.mapped ## E7.0 E7.25 E7.5 E7.75 E8.0 E8.25 E8.5 ## 55 39 255 1224 1641 6998 10723 ## ## $celltype.mapped ## Allantois Blood progenitors 1 ## 955 56 ## Blood progenitors 2 Cardiomyocytes ## 245 601 ## Caudal epiblast Caudal Mesoderm ## 71 71 ## Caudal neurectoderm Def. endoderm ## 19 91 ## Doublet Endothelium ## 1509 350 ## Erythroid1 Erythroid2 ## 448 1115 ## Erythroid3 ExE ectoderm ## 3173 156 ## ExE endoderm ExE mesoderm ## 14 1003 ## Forebrain/Midbrain/Hindbrain Gut ## 1803 701 ## Haematoendothelial progenitors Intermediate mesoderm ## 518 397 ## Mesenchyme Mixed mesoderm ## 1495 4 ## Neural crest NMP ## 615 606 ## Notochord Paraxial mesoderm ## 11 1059 ## Parietal endoderm PGC ## 61 25 ## Pharyngeal mesoderm Rostral neurectoderm ## 1109 198 ## Somitic mesoderm Spinal cord ## 328 713 ## Stripped Surface ectoderm ## 47 1357 ## Visceral endoderm ## 11 ## ## $closest.cell ## cell_71220 cell_132352 cell_37581 cell_38398 cell_133630 cell_75985 ## 180 179 135 123 102 78 ## cell_74615 cell_96860 cell_134438 cell_38140 cell_36067 cell_98277 ## 76 72 59 59 54 51 ## cell_40210 cell_133739 cell_69452 cell_137250 cell_40746 cell_74744 ## 46 43 42 41 41 40 ## cell_37295 cell_139027 cell_76775 cell_98128 cell_97456 cell_132412 ## 39 38 37 37 36 34 ## cell_69071 cell_70906 cell_133892 cell_40183 cell_132070 cell_133063 ## 34 34 33 32 30 30 ## cell_133712 cell_38655 cell_40388 cell_131552 cell_39059 cell_66392 ## 28 27 27 26 26 25 ## cell_66974 cell_102032 cell_131092 cell_67212 cell_98050 cell_39343 ## 25 24 24 24 24 23 ## cell_40527 cell_74684 cell_100899 cell_130659 cell_133721 cell_134638 ## 23 23 22 22 22 22 ## cell_38244 cell_39903 cell_70218 cell_76927 cell_137879 cell_27132 ## 22 22 22 22 21 21 ## cell_65563 cell_101969 cell_38451 cell_40571 cell_91221 cell_125957 ## 21 20 20 20 20 19 ## cell_40143 cell_40412 cell_65386 cell_66720 cell_70671 cell_96014 ## 19 19 19 19 19 19 ## cell_97435 cell_131123 cell_133876 cell_134544 cell_136737 cell_138771 ## 19 18 18 18 18 18 ## cell_65700 cell_70110 cell_72521 cell_102689 cell_132918 cell_133005 ## 18 18 18 17 17 17 ## cell_133481 cell_37978 cell_38407 cell_65580 cell_134191 cell_136502 ## 17 17 17 17 16 16 ## cell_25052 cell_40387 cell_40844 cell_71754 cell_74962 cell_76390 ## 16 16 16 16 16 16 ## cell_96412 cell_96512 cell_96673 cell_98024 cell_99878 cell_101054 ## 16 16 16 16 16 15 ## cell_102334 cell_102822 cell_103120 (Other) ## 15 15 15 17749 ## ## $doub.density ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00000 0.00294 0.02468 0.14791 0.09480 43.64080 ## ## $sizeFactor ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1199 0.5500 0.7545 0.9091 1.1114 5.4110 Básicamente: sample: 6 ratones diferentes tomato: inyectados o no con td-Tomato pool: lote de secuenciación, cada lote con 1 con y otro sin inyección celltype.mappped: 35 tipos de células anotados ## Número de células en nuestras variables principales with(colData(sce.chimera), table(sample, pool, tomato)) ## , , tomato = FALSE ## ## pool ## sample 3 4 5 ## 5 0 0 0 ## 6 1047 0 0 ## 7 0 0 0 ## 8 0 3097 0 ## 9 0 0 0 ## 10 0 0 6829 ## ## , , tomato = TRUE ## ## pool ## sample 3 4 5 ## 5 2411 0 0 ## 6 0 0 0 ## 7 0 3007 0 ## 8 0 0 0 ## 9 0 0 4544 ## 10 0 0 0 ## Número de tipos celulares length(unique(sce.chimera$celltype.mapped)) ## [1] 35 12.3.2 Procesamiento Usaremos los métodos que ya vimos para procesar datos Usaremos batchelor porque tenemos muestras de 3 lotes de muestras y queremos eliminar diferencias entre los lotes Para más detalles, revisar https://bioconductor.org/books/release/OSCA/integrating-datasets.html #--- feature-annotation ---# library(&quot;scater&quot;) rownames(sce.chimera) &lt;- uniquifyFeatureNames( rowData(sce.chimera)$ENSEMBL, rowData(sce.chimera)$SYMBOL ) #--- quality-control ---# drop &lt;- sce.chimera$celltype.mapped %in% c(&quot;stripped&quot;, &quot;Doublet&quot;) sce.chimera &lt;- sce.chimera[, !drop] #--- normalization ---# sce.chimera &lt;- logNormCounts(sce.chimera) #--- variance-modelling ---# library(&quot;scran&quot;) dec.chimera &lt;- modelGeneVar(sce.chimera, block = sce.chimera$sample) chosen.hvgs &lt;- dec.chimera$bio &gt; 0 #--- merging ---# library(&quot;batchelor&quot;) set.seed(01001001) merged &lt;- correctExperiments(sce.chimera, batch = sce.chimera$sample, subset.row = chosen.hvgs, PARAM = FastMnnParam( merge.order = list( list(1, 3, 5), # WT (3 replicates) list(2, 4, 6) # td-Tomato (3 replicates) ) ) ) #--- clustering ---# g &lt;- buildSNNGraph(merged, use.dimred = &quot;corrected&quot;) clusters &lt;- igraph::cluster_louvain(g) colLabels(merged) &lt;- factor(clusters$membership) #--- dimensionality-reduction ---# merged &lt;- runTSNE(merged, dimred = &quot;corrected&quot;, external_neighbors = TRUE) merged &lt;- runUMAP(merged, dimred = &quot;corrected&quot;, external_neighbors = TRUE) 12.3.3 Exploremos los datos de ejemplo Exploremos si tenemos clusters con una diferencia grande en el número de celulas entre las muestras sin y con inyecciones de td-Tomato Exploremos el número de células en cada cluster a lo largo de los 3 lotes de secuenciación (batch) ## Clusters vs DE por td-Tomato table(colLabels(merged), merged$tomato) ## ## FALSE TRUE ## 1 546 401 ## 2 60 52 ## 3 470 398 ## 4 469 211 ## 5 335 271 ## 6 258 249 ## 7 1241 967 ## 8 203 221 ## 9 630 629 ## 10 71 181 ## 11 417 310 ## 12 47 57 ## 13 58 0 ## 14 209 214 ## 15 414 630 ## 16 363 509 ## 17 234 198 ## 18 657 607 ## 19 151 303 ## 20 579 443 ## 21 137 74 ## 22 82 78 ## 23 155 1 ## 24 762 878 ## 25 363 497 ## 26 1420 716 ## Clusters vs lotes de muestras (batch) table(colLabels(merged), merged$pool) ## ## 3 4 5 ## 1 224 173 550 ## 2 26 30 56 ## 3 226 172 470 ## 4 78 162 440 ## 5 99 227 280 ## 6 187 116 204 ## 7 300 909 999 ## 8 69 134 221 ## 9 229 423 607 ## 10 114 54 84 ## 11 179 169 379 ## 12 16 31 57 ## 13 2 51 5 ## 14 77 97 249 ## 15 114 289 641 ## 16 183 242 447 ## 17 157 81 194 ## 18 123 308 833 ## 19 106 118 230 ## 20 236 238 548 ## 21 3 10 198 ## 22 27 29 104 ## 23 6 84 66 ## 24 217 455 968 ## 25 132 172 556 ## 26 194 870 1072 Visualizaremos nuestros clusters que son 26 en dimensiones reducidas de t-SNE Queremos que todos los clusters tengan muestras de cada lote de secuenciación (batch). Detalles en OSCA Vemos que no parece que haya mucha señal en base a td-Tomato library(&quot;patchwork&quot;) plotTSNE(merged, colour_by = &quot;tomato&quot;, text_by = &quot;label&quot;) + plotTSNE(merged, colour_by = data.frame(pool = factor(merged$pool))) Podemos usar facet_wrap() para reducir el over-plotting y ver mejor la información. plotTSNE(merged, colour_by = &quot;tomato&quot;, other_fields = c(&quot;tomato&quot;) ) + facet_wrap(~tomato) plotTSNE(merged, colour_by = data.frame(pool = factor(merged$pool)), other_fields = c(&quot;pool&quot;) ) + facet_wrap(~pool) También podríamos usar Nebulosa. This one is from a while back, but on 2020-11-20 I presented for @LIBDrstats the #Nebulosa @Bioconductor #rstats package by @josealquicirah et al for visualizing sc/snRNA-seq data📔 https://t.co/vWmT398lXGhttps://t.co/D3TbpOKkwF https://t.co/KFihrSGVUy — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) April 15, 2021 12.3.4 Nuestros clusters vs los originales Las siguientes gráficas nos ayudan a comparar nuestros clusters vs los que encontraron en el estudio original ¿Les parecen similares? ## Definir colores, si no scater nos los pone en una escala ## continua cols_label &lt;- Polychrome::palette36.colors(length(unique(merged$label))) names(cols_label) &lt;- unique(merged$label) cols_celltype.mapped &lt;- Polychrome::palette36.colors(length(unique(merged$celltype.mapped))) names(cols_celltype.mapped) &lt;- unique(merged$celltype.mapped) ## Nuestros clusters vs anotación de células por los ## autores originales plotTSNE(merged, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) + theme(legend.position = &quot;none&quot;) + scale_colour_manual(values = cols_label) + plotTSNE(merged, colour_by = &quot;celltype.mapped&quot;) + theme(legend.position = &quot;none&quot;) + scale_colour_manual(values = cols_celltype.mapped) ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. Es difícil el proceso de comparar clusters Podemos usar bluster para evaluar númericamente que tanto se parecen los clusters. Entre más cerca de 1, mejor en pairwiseRand() También podemos hacer un heatmap library(&quot;bluster&quot;) pairwiseRand(colLabels(merged), merged$celltype.mapped, &quot;index&quot;) ## [1] 0.5513742 by.label &lt;- table(colLabels(merged), merged$celltype.mapped) pheatmap::pheatmap(log2(by.label + 1), color = viridis::viridis(101)) Por eso es más fácil combinar datos de varios lotes de secuenciación y hacer un solo clustering en vez de varios y tener que identificar que clusters de una muestra corresponden a los de otra ⚠️ Nos saltaremos el proceso de anotación de células y usaremos los clusters y etiquetas originales 12.4 Análisis de expresión diferencial En RNA-seq estamos acostumbrados a evaluar si hay diferencias en los niveles de expresión de genes entre condiciones, así que es natural que lo hagamos con scRNA-seq también 🤔 Pero los datos de scRNA-seq tienen muchos ceros 12.4.1 Pseudo-bulking El proceso de pseudo-bulking es un truco que nos permite usar métodos de bulk RNA-seq para analizar nuestros datos de scRNA-seq Cómo tenemos muchas células de cada condición, para cada gene podemos sumar los niveles de expresión entre todas las células de esa condición 🔥off the press! 👀 our @biorxivpreprint on human 🧠brain @LieberInstitute spatial 🌌🔬transcriptomics data 🧬using Visium @10xGenomics🎉#spatialLIBD🔍https://t.co/RTW0VscUKR 👩🏾‍💻https://t.co/bsg04XKONr📚https://t.co/FJDOOzrAJ6📦https://t.co/Au5jwADGhYhttps://t.co/PiWEDN9q2N pic.twitter.com/aWy0yLlR50 — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) February 29, 2020 Ejemplo de mi trabajo: 12 muestras 7 regiones 47,681 spots (digamos que células) Podemos comprimir la información a una matriz de 12 * 7 = 84 columnas Nos quedamos con pocas réplicas para nuestro análisis, pero justamente los métodos de bulk RNA-seq están diseñados para esos escenarios (claro, entre más datos mejor!!!) Acá pueden explorar los datos si quieren http://spatial.libd.org/spatialLIBD/ Estas diapositivas son parte de un webinar que di con Kristen R Maynard el 2021-04-27 para BioTuring que pueden ver desde su sitio web o en YouTube. Podemos hacerlo manualmente o de forma más sencilla con la función aggregateAcrossCells() # Using &#39;label&#39; and &#39;sample&#39; as our two factors; each column of the output # corresponds to one unique combination of these two factors. summed &lt;- aggregateAcrossCells(merged, id = colData(merged)[, c(&quot;celltype.mapped&quot;, &quot;sample&quot;)] ) summed ## class: SingleCellExperiment ## dim: 14699 186 ## metadata(2): merge.info pca.info ## assays(1): counts ## rownames(14699): Xkr4 Rp1 ... Vmn2r122 CAAA01147332.1 ## rowData names(3): rotation ENSEMBL SYMBOL ## colnames: NULL ## colData names(16): batch cell ... sample ncells ## reducedDimNames(5): corrected pca.corrected.E7.5 pca.corrected.E8.5 ## TSNE UMAP ## mainExpName: NULL ## altExpNames(0): dim(merged) ## [1] 14699 19426 dim(summed) ## [1] 14699 186 with(colData(merged), length(unique(celltype.mapped)) * length(unique(sample))) ## [1] 204 En teoría podríamos tener más columnas, pero no las tenemos todas porque no tenemos datos para todas las combinaciones Esto puede afectar nuestro análisis, y pues afecta cuantas variables podremos usar para ajustar Por ejemplo, si agregamos sexo con 2 opciones, duplicaríamos el número teórico de columnas pero tal vez no tengamos suficientes datos Si lo llevas al extremo, terminas con los mismos datos de scRNA-seq que con los que empezamos 12.4.2 Convertir a un objeto nuevo Hagamos nuestro análisis de expresión diferencial Empezaremos con solo un tipo celular: Mesenchyme label &lt;- &quot;Mesenchyme&quot; current &lt;- summed[, label == summed$celltype.mapped] dim(current) ## [1] 14699 6 Vemos que nos quedamos con solo 14,699 genes a lo largo de 6 muestras Esto sería un experimento pequeño de bulk RNA-seq Usaremos edgeR de Robinson, McCarthy e Smyth, Bioinformatics, 2010 que es uno de los paquetes más usados para análisis de expresión diferencial en bulk RNA-seq Aaron Lun, autor de OSCA, se formó por el mismo grupo en Australia # Creating up a DGEList object for use in edgeR: library(&quot;edgeR&quot;) y &lt;- DGEList(counts(current), samples = colData(current)) y ## An object of class &quot;DGEList&quot; ## $counts ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 ## Xkr4 2 0 0 0 3 0 ## Rp1 0 0 1 0 0 0 ## Sox17 7 0 3 0 14 9 ## Mrpl15 1420 271 1009 379 1578 749 ## Rgs20 3 0 1 1 0 0 ## 14694 more rows ... ## ## $samples ## group lib.size norm.factors batch cell barcode sample stage tomato pool ## Sample1 1 4607053 1 5 &lt;NA&gt; &lt;NA&gt; 5 E8.5 TRUE 3 ## Sample2 1 1064970 1 6 &lt;NA&gt; &lt;NA&gt; 6 E8.5 FALSE 3 ## Sample3 1 2494010 1 7 &lt;NA&gt; &lt;NA&gt; 7 E8.5 TRUE 4 ## Sample4 1 1028668 1 8 &lt;NA&gt; &lt;NA&gt; 8 E8.5 FALSE 4 ## Sample5 1 4290221 1 9 &lt;NA&gt; &lt;NA&gt; 9 E8.5 TRUE 5 ## Sample6 1 1950840 1 10 &lt;NA&gt; &lt;NA&gt; 10 E8.5 FALSE 5 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## Sample1 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample2 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample3 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample4 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample5 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample6 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## celltype.mapped.1 sample.1 ncells ## Sample1 Mesenchyme 5 286 ## Sample2 Mesenchyme 6 55 ## Sample3 Mesenchyme 7 243 ## Sample4 Mesenchyme 8 134 ## Sample5 Mesenchyme 9 478 ## Sample6 Mesenchyme 10 299 Listo, ya convertimos nuestros datos al formato que le gusta a edgeR 12.4.3 Pre-procesamiento Antes de poder continuar, vamos a eliminar muestras que construimos con el proceso de pseudo-bulking que no tengan al menos 10 células discarded &lt;- current$ncells &lt; 10 y &lt;- y[, !discarded] summary(discarded) ## Mode FALSE ## logical 6 A continuación eliminaremos genes que tengan bajos niveles de expresión keep &lt;- filterByExpr(y, group = current$tomato) y &lt;- y[keep, ] summary(keep) ## Mode FALSE TRUE ## logical 9011 5688 Después normalizaremos los datos Pero si ya habíamos normalizado los datos de scRNA-seq, ¿qué pasó? 23 y &lt;- calcNormFactors(y) y$samples ## group lib.size norm.factors batch cell barcode sample stage tomato pool ## Sample1 1 4607053 1.0683392 5 &lt;NA&gt; &lt;NA&gt; 5 E8.5 TRUE 3 ## Sample2 1 1064970 1.0487418 6 &lt;NA&gt; &lt;NA&gt; 6 E8.5 FALSE 3 ## Sample3 1 2494010 0.9582296 7 &lt;NA&gt; &lt;NA&gt; 7 E8.5 TRUE 4 ## Sample4 1 1028668 0.9774156 8 &lt;NA&gt; &lt;NA&gt; 8 E8.5 FALSE 4 ## Sample5 1 4290221 0.9707300 9 &lt;NA&gt; &lt;NA&gt; 9 E8.5 TRUE 5 ## Sample6 1 1950840 0.9816914 10 &lt;NA&gt; &lt;NA&gt; 10 E8.5 FALSE 5 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## Sample1 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample2 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample3 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample4 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample5 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample6 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## celltype.mapped.1 sample.1 ncells ## Sample1 Mesenchyme 5 286 ## Sample2 Mesenchyme 6 55 ## Sample3 Mesenchyme 7 243 ## Sample4 Mesenchyme 8 134 ## Sample5 Mesenchyme 9 478 ## Sample6 Mesenchyme 10 299 calcNormFactors() asume que la mayoría de los genes no están diferencialmente expresados como describen Robinson y Oshlack, Genome Biol., 2010 Podemos visualizar los cambios de expresión para todos los genes, una muestra a la vez par(mfrow = c(2, 3)) for (i in seq_len(ncol(y))) { plotMD(y, column = i) } Podemos usar técnicas de reducción de dimensiones como MDS y PCA para explorar la variación entre nuestras muestras (ya no células) par(mfrow = c(1, 1)) plotMDS(cpm(y, log = TRUE), col = ifelse(y$samples$tomato, &quot;red&quot;, &quot;blue&quot;) ) Podemos repetir el plotMDS() pero con colores por lote (batch) de pool. plotMDS(cpm(y, log = TRUE), col = c(&quot;3&quot; = &quot;darkorchid1&quot;, &quot;4&quot; = &quot;darkblue&quot;, &quot;5&quot; = &quot;tomato4&quot;)[factor(y$samples$pool)] ) Acá vemos que si hay diferencias entre lotes, en particular entre el lote de las muestras 1 y 2 y el resto, ya que el eje X explica el 38% de la varianza. 12.4.4 Modelo estadístico Si todo nos parece bien, podemos seguir con definir nuestro modelo estadístico Vamos a ajustar por lote (batch) y encontrar diferencias por la inyección de td-Tomato Como empezamos con las cuentas desde cero, tenemos que tomar en cuenta la variación por lote de secuenciación design &lt;- model.matrix(~ factor(pool) + factor(tomato), y$samples) design ## (Intercept) factor(pool)4 factor(pool)5 factor(tomato)TRUE ## Sample1 1 0 0 1 ## Sample2 1 0 0 0 ## Sample3 1 1 0 1 ## Sample4 1 1 0 0 ## Sample5 1 0 1 1 ## Sample6 1 0 1 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 2 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$`factor(pool)` ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$`factor(tomato)` ## [1] &quot;contr.treatment&quot; Si queremos explorar nuestro modelo estadístico de forma interactiva, podemos usar ExploreModelMatrix por Charlotte Soneson y Michael Love. Charlotte es de las autoras de iSEE. if (interactive()) { ExploreModelMatrix::ExploreModelMatrix(y$samples[, c(&quot;pool&quot;, &quot;tomato&quot;)], ~ factor(pool) + factor(tomato)) } Tal y como en bulk RNA-seq, podemos usar la información de los genes para mejorar nuestros estimados de la varianza para cada gene, de tal forma que mejoramos los resultados estadísticos aunque tengamos pocas muestras y &lt;- estimateDisp(y, design) summary(y$trended.dispersion) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.01026 0.01670 0.02128 0.02020 0.02349 0.02665 plotBCV(y) fit &lt;- glmQLFit(y, design, robust = TRUE) summary(fit$var.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.3179 0.7143 0.8538 0.8045 0.9128 1.0665 summary(fit$df.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.2267 12.6749 12.6749 12.3390 12.6749 12.6749 plotQLDisp(fit) Ahora si podemos correr nuestro modelo estádistico res &lt;- glmQLFTest(fit, coef = ncol(design)) de_n &lt;- summary(decideTests(res)) de_n ## factor(tomato)TRUE ## Down 8 ## NotSig 5672 ## Up 8 topTags(res) ## Coefficient: factor(tomato)TRUE ## logFC logCPM F PValue FDR ## Phlda2 -4.3873546 9.934130 1638.59469 1.812293e-16 1.030832e-12 ## Erdr1 2.0690698 8.832662 356.36590 1.060836e-11 3.017019e-08 ## Mid1 1.5190728 6.931325 120.14656 1.844351e-08 3.496889e-05 ## H13 -1.0596020 7.540121 80.79795 2.373001e-07 2.526790e-04 ## Kcnq1ot1 1.3762700 7.241651 83.30701 2.392052e-07 2.526790e-04 ## Akr1e1 -1.7205826 5.127802 79.31386 2.665390e-07 2.526790e-04 ## Zdbf2 1.8008336 6.797367 83.66324 6.808994e-07 5.532794e-04 ## Asb4 -0.9234911 7.340648 53.44578 2.918297e-06 2.074909e-03 ## Impact 0.8516300 7.353208 50.31429 4.145416e-06 2.619903e-03 ## Lum -0.6031413 9.274529 41.67104 1.204523e-05 6.851324e-03 Encontramos 16 genes diferencialmente expresados por la inyección de td-Tomato. 12.4.5 De forma sencilla Eso fue mucho trabajo, ¿no? La función pseudoBulkDGE() corre todos esos pasos por nosotros # Removing all pseudo-bulk samples with &#39;insufficient&#39; cells. summed.filt &lt;- summed[, summed$ncells &gt;= 10] library(&quot;scran&quot;) de.results &lt;- pseudoBulkDGE(summed.filt, label = summed.filt$celltype.mapped, design = ~ factor(pool) + tomato, coef = &quot;tomatoTRUE&quot;, condition = summed.filt$tomato ) class(de.results) ## [1] &quot;SimpleList&quot; ## attr(,&quot;package&quot;) ## [1] &quot;S4Vectors&quot; length(de.results) ## [1] 23 Nos regresa una lista con los resultados para cada uno de nuestros tipos celulares Podemos extraer los resultados para nuestro tipo celular de interés, por ejemplo Allantois. cur.results &lt;- de.results[[&quot;Allantois&quot;]] cur.results[order(cur.results$PValue), ] ## DataFrame with 14699 rows and 5 columns ## logFC logCPM F PValue FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Phlda2 -2.489508 12.58150 1207.016 3.33486e-21 1.60507e-17 ## Xist -7.978532 8.00166 1092.831 1.27783e-17 3.07510e-14 ## Erdr1 1.947170 9.07321 296.937 1.58009e-14 2.53500e-11 ## Slc22a18 -4.347153 4.04380 117.389 1.92517e-10 2.31647e-07 ## Slc38a4 0.891849 10.24094 113.899 2.52208e-10 2.42776e-07 ## ... ... ... ... ... ... ## Ccl27a_ENSMUSG00000095247 NA NA NA NA NA ## CR974586.5 NA NA NA NA NA ## AC132444.6 NA NA NA NA NA ## Vmn2r122 NA NA NA NA NA ## CAAA01147332.1 NA NA NA NA NA y.allantois &lt;- metadata(cur.results)$y plotBCV(y.allantois) También nos dice que tipos celulares fallaron porque no teníamos suficiente información para hacer el análisis metadata(de.results)$failed ## [1] &quot;Blood progenitors 1&quot; &quot;Caudal epiblast&quot; &quot;Caudal neurectoderm&quot; ## [4] &quot;ExE ectoderm&quot; &quot;Parietal endoderm&quot; &quot;Stripped&quot; Aquí podemos hacer la misma gráfica que hicimos de forma manual para Mesenchyme. cur.results.Mesenchyme &lt;- de.results[[&quot;Mesenchyme&quot;]] y.Mesenchyme &lt;- metadata(cur.results.Mesenchyme)$y plotBCV(y.Mesenchyme) 12.4.6 Ejercicios 12.4.6.1 Pseudo-bulking Hagamos el cálculo de pseudo-bulking de forma manual para la primera muestra de summed y el gene con los valores más altos de expresión para esa muestra. Es decir, trabajaremos con el siguiente gene. colData(summed)[1, ] ## DataFrame with 1 row and 16 columns ## batch cell barcode sample stage tomato pool ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;logical&gt; &lt;integer&gt; ## 1 5 NA NA 5 E8.5 TRUE 3 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; ## 1 NA Allantois NA NA NA NA ## celltype.mapped sample ncells ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## 1 Allantois 5 97 which.max(counts(summed)[, 1]) ## Ptma ## 360 Usa el objeto merged para volver a calcular el siguiente valor. counts(summed)[which.max(counts(summed)[, 1]), 1] ## Ptma ## 22802 12.4.6.2 Visualización de resultados de expresión diferencial Usando los resultados de expresión diferencial para el tipo celular Mesenchyme, reproduce la siguiente visualización. ## Warning: Removed 9011 rows containing missing values (geom_point). Explora la información que tenemos en cur.results.Mesenchyme. Si usas el paquete ggplot2, tendrás que usar as.data.frame() para convertir un objeto DFrame a un data.frame. Revisa que valores salen en cada eje y en los colores. Tal vez algunos valores tiene alguna transformación. ¿Por qué sale un warning diciendo que eliminamos 9011 puntos? 24 12.4.7 Respuestas 12.4.7.1 Pseudo-bulking ## Valor esperado counts(summed)[which.max(counts(summed)[, 1]), 1] ## Ptma ## 22802 ## Respuesta sum(counts(merged)[ names(which.max(counts(summed)[, 1])), merged$celltype.mapped == &quot;Allantois&quot; &amp; merged$sample == 5 ]) ## [1] 22802 ## Otra versión sum(counts(merged)[ &quot;Ptma&quot;, with(colData(merged), celltype.mapped == &quot;Allantois&quot; &amp; sample == 5) ]) ## [1] 22802 12.4.7.2 Visualización de resultados de expresión diferencial library(&quot;ggplot2&quot;) ## class(cur.results.Mesenchyme) # [1] &quot;DFrame&quot; # attr(,&quot;package&quot;) # [1] &quot;S4Vectors&quot; df &lt;- as.data.frame(cur.results.Mesenchyme) df$label &lt;- rownames(df) p &lt;- ggplot( df, aes( x = logFC, y = -log10(PValue), color = FDR &lt; 0.05, label = label ) ) + geom_point() p ## Warning: Removed 9011 rows containing missing values (geom_point). Este tipo de gráfica es un volcano plot donde vemos en el eje X el cambio de expresión y en el eje Y el valor p transformado con -log10(p). Usamos colores para marcar los genes con un FDR &lt; 0.05. 12.4.7.3 Con etiquetas Podemos agregarle etiquetas usando el paquete ggrepel. p + ggrepel::geom_text_repel(data = subset(df, FDR &lt; 0.05)) ## Warning: Removed 9011 rows containing missing values (geom_point). 12.4.7.4 Versión interactiva O podemos hacer una versión interactiva con plotly. plotly::ggplotly(p) 12.5 Análisis de abundancia diferencial table(merged$sample) ## ## 5 6 7 8 9 10 ## 2298 1026 2740 2904 4057 6401 Si recuerdan, tenemos 6 muestras en total. 👉 Otro tipo de análisis que podemos hacer es preguntarnos si cambió la composición celular entre nuestras muestras con y sin la inyección de td-Tomato. 👉 Este tipo de análisis nos dirá que tipos celulares cambiaron de acuerdo a nuestras condiciones de interés, que puede ser igual de interesante que encontrar genes diferencialmente expresados. 👉 Es como si scRNA-seq fuera un super-FACS donde usamos todo el transcriptoma. Hagamos una tabla de la frecuencia de cada tipo celular a lo largo de nuestras muestras. Es decir, una tabla de abundancias abundances &lt;- table(merged$celltype.mapped, merged$sample) abundances &lt;- unclass(abundances) head(abundances) ## ## 5 6 7 8 9 10 ## Allantois 97 15 139 127 318 259 ## Blood progenitors 1 6 3 16 6 8 17 ## Blood progenitors 2 31 8 28 21 43 114 ## Cardiomyocytes 85 21 79 31 174 211 ## Caudal epiblast 2 2 0 0 22 45 ## Caudal Mesoderm 10 10 9 3 10 29 A esta tabla le podemos agregar algo de información de nuestras muestras, y con eso construir un objeto del tipo que le gusta a edgeR # Attaching some column metadata. extra.info &lt;- colData(merged)[match(colnames(abundances), merged$sample), ] y.ab &lt;- DGEList(abundances, samples = extra.info) y.ab ## An object of class &quot;DGEList&quot; ## $counts ## ## 5 6 7 8 9 10 ## Allantois 97 15 139 127 318 259 ## Blood progenitors 1 6 3 16 6 8 17 ## Blood progenitors 2 31 8 28 21 43 114 ## Cardiomyocytes 85 21 79 31 174 211 ## Caudal epiblast 2 2 0 0 22 45 ## 29 more rows ... ## ## $samples ## group lib.size norm.factors batch cell barcode sample stage ## 5 1 2298 1 5 cell_9769 AAACCTGAGACTGTAA 5 E8.5 ## 6 1 1026 1 6 cell_12180 AAACCTGCAGATGGCA 6 E8.5 ## 7 1 2740 1 7 cell_13227 AAACCTGAGACAAGCC 7 E8.5 ## 8 1 2904 1 8 cell_16234 AAACCTGCAAACCCAT 8 E8.5 ## 9 1 4057 1 9 cell_19332 AAACCTGCAACGATCT 9 E8.5 ## 10 1 6401 1 10 cell_23875 AAACCTGAGGCATGTG 10 E8.5 ## tomato pool stage.mapped celltype.mapped closest.cell ## 5 TRUE 3 E8.25 Mesenchyme cell_24159 ## 6 FALSE 3 E8.25 Somitic mesoderm cell_63247 ## 7 TRUE 4 E8.5 Somitic mesoderm cell_25454 ## 8 FALSE 4 E8.25 ExE mesoderm cell_139075 ## 9 TRUE 5 E8.0 ExE mesoderm cell_116116 ## 10 FALSE 5 E8.5 Forebrain/Midbrain/Hindbrain cell_39343 ## doub.density sizeFactor label ## 5 0.02985045 1.6348759 19 ## 6 0.29191572 2.5980769 6 ## 7 0.60173979 1.5939009 17 ## 8 0.00473259 0.8707367 9 ## 9 0.07941464 0.8932525 15 ## 10 0.04074704 0.3947355 1 A diferencia de los análisis de expresión diferencial, no usaremos calcNormFactors() porque este tipo de análisis no cumple, generalmente, con las condiciones del método estadístico A continuación filtramos los tipos celulares para los cuales no tenemos suficiente información, si es el caso keep &lt;- filterByExpr(y.ab, group = y.ab$samples$tomato) y.ab &lt;- y.ab[keep, ] summary(keep) ## Mode FALSE TRUE ## logical 10 24 Luego hacemos nuestro análisis de abundancia con edgeR el cual nos permite usar el modelo estadístico que está diseñado para valores enteros (cuentas) y pocas réplicas Es la misma formúla del modelo estadístico (design) que usamos anteriormente, pero para otros números design &lt;- model.matrix(~ factor(pool) + factor(tomato), y.ab$samples) design ## (Intercept) factor(pool)4 factor(pool)5 factor(tomato)TRUE ## 5 1 0 0 1 ## 6 1 0 0 0 ## 7 1 1 0 1 ## 8 1 1 0 0 ## 9 1 0 1 1 ## 10 1 0 1 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 2 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$`factor(pool)` ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$`factor(tomato)` ## [1] &quot;contr.treatment&quot; y.ab &lt;- estimateDisp(y.ab, design, trend = &quot;none&quot;) summary(y.ab$common.dispersion) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0614 0.0614 0.0614 0.0614 0.0614 0.0614 plotBCV(y.ab, cex = 1) A diferencia de antes, tenemos pocos puntos (antes eran genes, ahora son tipos celulares), así que no estimaremos una curva, por eso usamos abundance.trend = FALSE fit.ab &lt;- glmQLFit(y.ab, design, robust = TRUE, abundance.trend = FALSE) summary(fit.ab$var.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.254 1.254 1.254 1.254 1.254 1.254 plotQLDisp(fit.ab, cex = 1) Corremos el análisis res &lt;- glmQLFTest(fit.ab, coef = ncol(design)) summary(decideTests(res)) ## factor(tomato)TRUE ## Down 1 ## NotSig 22 ## Up 1 topTags(res) ## Coefficient: factor(tomato)TRUE ## logFC logCPM F PValue ## ExE ectoderm -6.5663339 13.02497 66.266874 1.352022e-10 ## Mesenchyme 1.1651500 16.29382 11.290523 1.534506e-03 ## Allantois 0.8345294 15.50702 5.312163 2.554581e-02 ## Cardiomyocytes 0.8484008 14.86430 5.203963 2.701306e-02 ## Neural crest -0.7706378 14.76462 4.106177 4.830292e-02 ## Endothelium 0.7518608 14.28905 3.911511 5.371320e-02 ## Erythroid3 -0.6430834 17.28041 3.603666 6.367366e-02 ## Haematoendothelial progenitors 0.6581135 14.72323 3.123946 8.350641e-02 ## ExE mesoderm 0.3805309 15.67835 1.180627 2.826550e-01 ## Pharyngeal mesoderm 0.3793160 15.72073 1.169279 2.849523e-01 ## FDR ## ExE ectoderm 3.244852e-09 ## Mesenchyme 1.841407e-02 ## Allantois 1.620784e-01 ## Cardiomyocytes 1.620784e-01 ## Neural crest 2.148528e-01 ## Endothelium 2.148528e-01 ## Erythroid3 2.183097e-01 ## Haematoendothelial progenitors 2.505192e-01 ## ExE mesoderm 6.257608e-01 ## Pharyngeal mesoderm 6.257608e-01 Entre los tipos celulares donde teníamos suficiente información, solo 2 muestran diferencias en sus niveles de frecuencia entre las muestras con y sin inyecciones de td-Tomato. 12.6 Comentarios sobre la interpretación 👉 La distinción entre ambos tipos de análisis en scRNA-seq es articial Las etiquetas que usamos para el análisis de abundancia están definidas por los niveles de expresión de los genes Este tema de cuantas veces usas los datos y como eso afecta las pruebas estadísticas que usamos es un tema de investigación actual In a talk that was as clear as her book “intro to stat learning”, today's #bioc2021 keynote @daniela_witten showed how double dipping (e.g. using genes to cluster data and then testing for DE between clusters) leads to + type 1 error and an intuitive method to correct this prob. — Alejandro Reyes (@areyesq) August 4, 2021 Les recomiendo que lean detenidamente esa parte en OSCA 12.7 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:48:17 UTC&quot; proc.time() ## user system elapsed ## 346.357 28.645 347.347 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## batchelor * 1.8.1 2021-08-12 [1] Bioconductor ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster * 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## BumpyMatrix 1.0.1 2021-07-04 [1] Bioconductor ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## edgeR * 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma * 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magick 2.7.2 2021-05-02 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## MouseGastrulationData * 1.6.0 2021-05-20 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## Polychrome * 1.3.1 2021-07-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scatterplot3d 0.3-41 2018-03-14 [1] RSPM (R 4.1.0) ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## SpatialExperiment * 1.2.1 2021-06-10 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Empezamos de nuevo con las cuentas originales en y &lt;- DGEList(counts(current), samples=colData(current)) y no las normalizadas.↩︎ Revisa cuántos genes no pasaron nuestro filtro de expresión cuando lo hicimos de forma manual en nuestro objeto keep. Corre otra vez table(keep).↩︎ "],["introducción-a-seurat.html", "13 Introducción a Seurat 13.1 Diapositivas 13.2 Una perspectiva diferente 13.3 Kick-start 13.4 Quality Control 13.5 Normalización 13.6 Detección de genes (caractersticas) altamente variables 13.7 Escalar los datos 13.8 Reducción dimensional lineal 13.9 Determinar la dimensionalidad del conjunto de datos 13.10 Clustering 13.11 Reducción dimensional no lineal (UMAP/tSNE) 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) 13.13 Assigning cell type identity to clusters 13.14 Guardar Resultados 13.15 Detalles de la sesión de R Patrocinadores", " 13 Introducción a Seurat Instructor: Kevin E. Meza-Landeros 13.1 Diapositivas Presentación: aquí 13.2 Una perspectiva diferente Seurat es un paquete R diseñado para control de calidad, análisis y exploración de datos de secuencia de ARN de una sola célula. Seurat tiene como objetivo permitir a los usuarios identificar e interpretar fuentes de heterogeneidad a partir de mediciones transcriptómicas unicelulares e integrar diversos tipos de datos unicelulares. Seurat es desarrollado y mantenido por el laboratorio de Satija y se publica bajo la Licencia Pública GNU (GPL 3.0). En este tutorial se ve como procesar los datos de scRNAseq con un nuevo paquete. Los pasos a realizar son en esencia los mismos que ya revisamos con el tutorial de la OSCA de RStudio. No olvides nunca que el paquete mas adecuado y que deberás utilizar dependerá mayoritariamente de tus datos y el procesamiento que se adecúe a estos. Además… siempre es bueno diversos puntos de vista sobre las cosas, ¿no es así? Aprende mas sobre Seurat: aquí 13.3 Kick-start En este tutorial partimos a partir de que ya se tienen los archivos FASTQ resultados de secuenciación. ¿Con qué datos estoy trabajando? Peripheral Blood Mononuclear Cells (PBMC) disponibles gratuitamente de 10X Genomics. Son en total 2,700 céluas únicas secuenciadas con Illumina NextSeq 500. Puedes descargar los datos de aquí (7.3MB). Descarga el archivo comprimido y procede a descomprimirlo. Se creara el siguiente directorio filtered_gene_bc_matrices/hg19/, aquí estarán los archivos que necesitaremos. A continuación lo haremos con código de R. Este tutorial solo es la punta del iceberg de lo que se puede hacer con la paquetera de Seurat. Para comenzar a sumergirte en este mundo no dudes en visitar la página oficial mantenida por Satija Lab Vignettes A continuación estableceremos nuestros directorio de trabajo y leeremos los datos anteriores. La función Read10X() lee en la salida de cellranger de 10X (de donde se obtuvieron los FASTQs), devolviendo una matriz de recuento única identificada molecularmente (UMI). Los valores en esta matriz representan el número de moléculas para cada característica (es decir, gen; fila) que se detectan en cada célula (columna). ## Cargar paquetes de R library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;dplyr&quot;) ## para filtar datos library(&quot;Seurat&quot;) ## paquete principal de este capítulo library(&quot;patchwork&quot;) ## para graficar imágenes juntas # Usemos datos de pbmc3k tal y como lo hacen en # https://satijalab.org/seurat/articles/pbmc3k_tutorial.html # pero con nuestro propio código bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&quot; )) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc3k&quot;)) fname &lt;- file.path(tempdir(), &quot;pbmc3k/filtered_gene_bc_matrices/hg19&quot;) # Load the PBMC dataset pbmc.data &lt;- Read10X(data.dir = fname) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) Veamos la estructura del Objeto de Seurat str(pbmc) ## Formal class &#39;Seurat&#39; [package &quot;SeuratObject&quot;] with 13 slots ## ..@ assays :List of 1 ## .. ..$ RNA:Formal class &#39;Assay&#39; [package &quot;SeuratObject&quot;] with 8 slots ## .. .. .. ..@ counts :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ data :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ scale.data : num[0 , 0 ] ## .. .. .. ..@ key : chr &quot;rna_&quot; ## .. .. .. ..@ assay.orig : NULL ## .. .. .. ..@ var.features : logi(0) ## .. .. .. ..@ meta.features:&#39;data.frame&#39;: 13714 obs. of 0 variables ## .. .. .. ..@ misc : list() ## ..@ meta.data :&#39;data.frame&#39;: 2700 obs. of 3 variables: ## .. ..$ orig.ident : Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ nCount_RNA : num [1:2700] 2419 4903 3147 2639 980 ... ## .. ..$ nFeature_RNA: int [1:2700] 779 1352 1129 960 521 781 782 790 532 550 ... ## ..@ active.assay: chr &quot;RNA&quot; ## ..@ active.ident: Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## ..@ graphs : list() ## ..@ neighbors : list() ## ..@ reductions : list() ## ..@ images : list() ## ..@ project.name: chr &quot;pbmc3k&quot; ## ..@ misc : list() ## ..@ version :Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. ..$ : int [1:3] 4 0 2 ## ..@ commands : list() ## ..@ tools : list() ¿Cómo accedemos a cada slot? Clase Seurat. La información resumida sobre los objetos de Seurat se puede obtener de forma rápida y sencilla mediante las funciones estándar de R. La forma / dimensiones del objeto se pueden encontrar usando las funciones dim(), ncol() y nrow(); Los nombres de celda y característica se pueden encontrar usando las funciones colnames() y rownames(), respectivamente, o la función dimnames(). Se puede obtener un vector de nombres de objetos Assay, DimReduc y Graph contenidos en un objeto Seurat mediante el uso de nombres. dim(pbmc) ## [1] 13714 2700 head(rownames(pbmc)) ## [1] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ## [5] &quot;LINC00115&quot; &quot;NOC2L&quot; head(colnames(pbmc)) ## [1] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ## [5] &quot;AAACCGTGTATGCG-1&quot; &quot;AAACGCACTGGTAC-1&quot; Se puede obtener un vector de nombres de objetos Assay, DimReduc y Graph contenidos en un objeto Seurat mediante el uso de nombres. La extracción de objetos específicos de Assay, DimReduc o Graph se puede realizar con el operador doble [[ ]] extract. La adición de nuevos objetos a un objeto de Seurat también se hace con el operador doble [[ ]] extract; Seurat averiguará a qué parte del objeto Seurat pertenece un nuevo objeto asociado. names(pbmc) ## [1] &quot;RNA&quot; pbmc[[&quot;RNA&quot;]] ## Assay data with 13714 features for 2700 cells ## First 10 features: ## AL627309.1, AP006222.2, RP11-206L10.2, RP11-206L10.9, LINC00115, NOC2L, ## KLHL17, PLEKHN1, RP11-54O7.17, HES4 # pbmc[[&#39;tsne&#39;]] El acceso a los datos de un objeto Seurat se realiza con la función GetAssayData(). La adición de datos de expresión a counts, data, o scale.data se puede hacer con SetAssayData(). Los datos nuevos deben tener las mismas celdas en el mismo orden que los datos de la expresión actual. Los datos agregados a los recuentos o datos deben tener las mismas características que los datos de la expresión actual. GetAssayData(object = pbmc, slot = &quot;data&quot;)[1:3, 1:3] ## 3 x 3 sparse Matrix of class &quot;dgCMatrix&quot; ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 ## AL627309.1 . . . ## AP006222.2 . . . ## RP11-206L10.2 . . . Metadata de las Células. Se puede acceder a los metadatos a nivel de celda con el operador de extracción [[ ]] extract o usando $sigil. Extraer con $sigil significa que solo se puede extraer un bit de metadatos a la vez, aunque se ha habilitado el autocompletado de pestañas, lo que lo hace ideal para uso interactivo. La adición de metadatos a nivel de celda se puede configurar usando el operador de extracción único [[ ]] también, o usando AddMetaData. head(pbmc@meta.data) ## orig.ident nCount_RNA nFeature_RNA ## AAACATACAACCAC-1 pbmc3k 2419 779 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 ## AAACCGTGTATGCG-1 pbmc3k 980 521 ## AAACGCACTGGTAC-1 pbmc3k 2163 781 head(pbmc[[c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;)]]) ## nCount_RNA nFeature_RNA ## AAACATACAACCAC-1 2419 779 ## AAACATTGAGCTAC-1 4903 1352 ## AAACATTGATCAGC-1 3147 1129 ## AAACCGTGCTTCCG-1 2639 960 ## AAACCGTGTATGCG-1 980 521 ## AAACGCACTGGTAC-1 2163 781 # Passing `drop = TRUE` will turn the meta data into a names vector # with each entry being named for the cell it corresponds to head(pbmc[[&quot;nCount_RNA&quot;, drop = TRUE]]) ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 ## 2419 4903 3147 2639 ## AAACCGTGTATGCG-1 AAACGCACTGGTAC-1 ## 980 2163 La clase Assay almacena datos de una sola celda. Para los experimentos típicos de scRNA-seq, un objeto Seurat tendrá un único ensayo (“RNA”). Este ensayo también almacenará múltiples ‘transformaciones’ de los datos, incluidos recuentos sin procesar (ranura @counts), datos normalizados (ranura @data) y datos escalados para la reducción dimensional (ranura @scale.data). Para experimentos más complejos, un objeto podría contener múltiples ensayos. Estos podrían incluir tipos de datos multimodales (etiquetas derivadas de anticuerpos CITE-seq, ADT) o mediciones imputadas / corregidas por lotes. Cada uno de esos ensayos tiene la opción de almacenar también las mismas transformaciones de datos. ¿Cómo se ven los datos en una matriz de recuento? Examinemos algunos genes en las primeras treinta células. Los valores en la matriz representan ceros (no se detectan moléculas). Dado que la mayoría de los valores en una matriz scRNA-seq son 0, Seurat utiliza una representación de matriz dispersa (sparse matrix) siempre que sea posible. Esto da como resultado un ahorro significativo de memoria y velocidad. pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 30 column names &#39;AAACATACAACCAC-1&#39;, &#39;AAACATTGAGCTAC-1&#39;, &#39;AAACATTGATCAGC-1&#39; ... ]] ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . dense.size &lt;- object.size(as.matrix(pbmc.data)) dense.size ## 709591472 bytes sparse.size &lt;- object.size(pbmc.data) sparse.size ## 29905192 bytes dense.size / sparse.size ## 23.7 bytes ¡EN ESTE CASO UNA MATRIZ NO DISPERSA OCUPA ~ 24 VECES MAS ESPACIO! 13.4 Quality Control Algunas métricas de control de calidad comúnmente utilizadas por la comunidad incluyen: El número de genes únicos detectados en cada célula. Las células de baja calidad o las gotitas vacías suelen tener muy pocos genes. Los dobletes o multipletes celulares pueden exhibir un recuento de genes aberrantemente alto De manera similar, el número total de moléculas detectadas dentro de una célula (se correlaciona fuertemente con genes únicos). El porcentaje de lecturas que se asignan al genoma mitocondrial. Las células de baja calidad / moribundas a menudo exhiben una extensa contaminación mitocondrial Calculamos métricas de control de calidad mitocondrial con la función PercentageFeatureSet(), que calcula el porcentaje de recuentos que se originan a partir de un conjunto de características. El operador [[ puede agregar columnas a los metadatos del objeto. Este es un gran lugar para almacenar estadísticas de control de calidad. Entonces calculamos y añadimos la cantidad de lecturas que corresponden al genoma mitocondrial. pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) Visualizamos las métricas de control de calidad mencionadas anteriormente como un diagrama de violín. Ademas vemos la correlación entre el numero de moléculas de RNA detectadas en cada célula con el número de genes únicos y con el porcentaje de lecturas que corresponden a mtADN. VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 Finalmente filtramos aquellas células que se salen de los estándares de cada uno de los parámetros. # Filter pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) ¿Dónde se almacenan la métricas de QC en Seurat? Están almacenadas en la seccion de @meta.data del objeto Seurat. head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 13.5 Normalización De forma predeterminada, se emplea un método de normalización de escala global “LogNormalize” que normaliza las medidas de expresión de características para cada célula por la expresión total, multiplica esto por un factor de escala (10.000 por defecto) y transforma el resultado en logaritmos. Los valores normalizados se almacenan en pbmc [[\"RNA\"]]@data. pbmc &lt;- NormalizeData(pbmc, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) 13.6 Detección de genes (caractersticas) altamente variables A continuación, calculamos un subconjunto de características que exhiben una alta variación de célula a célula en el conjunto de datos (es decir, están altamente expresadas en algunas células y poco expresadas en otras). El equipo de Seurat y otros equipos han descubierto que centrarse en estos genes en el análisis posterior ayuda a resaltar la señal biológica en conjuntos de datos unicelulares. El procedimiento en Seurat mejora a comparación de las versiones anteriores al modelar directamente la relación de varianza media inherente a los datos de una sola célula, y se implementa en la función FindVariableFeatures(). De forma predeterminada, se devuelven 2000 características por conjunto de datos (aunque se puede modificar). Estos se utilizarán en análisis posteriores, como PCA. pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) top10 ## [1] &quot;PPBP&quot; &quot;LYZ&quot; &quot;S100A9&quot; &quot;IGLL5&quot; &quot;GNLY&quot; &quot;FTL&quot; &quot;PF4&quot; &quot;FTH1&quot; ## [9] &quot;GNG11&quot; &quot;S100A8&quot; # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results plot1 + plot2 ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). 13.7 Escalar los datos A continuación, aplicamos una transformación lineal (“escalado”) que es un paso de preprocesamiento estándar antes de las técnicas de reducción dimensional como PCA. La función ScaleData(): Cambia la expresión de cada gen, de modo que la expresión media en las células sea 0 Escala la expresión de cada gen, de modo que la varianza entre las células sea 1 Este paso otorga el mismo peso en los análisis posteriores, de modo que los genes altamente expresados no dominen Los resultados de esto se almacenan en pbmc [[\"RNA\"]]@scale.data. all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes) ## Centering and scaling data matrix 13.8 Reducción dimensional lineal A continuación, realizamos PCA sobre los datos escalados. De forma predeterminada, solo las características variables determinadas previamente se utilizan como entrada, pero se pueden definir mediante el argumento de características si desea elegir un subconjunto diferente. pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL, FTH1, LYZ, FCN1, S100A9, TYMP ## FCER1G, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, IFITM3, SPI1, CFP ## PSAP, IFI30, SAT1, COTL1, S100A11, NPC2, GRN, LGALS3, GSTP1, PYCARD ## Negative: MALAT1, LTB, IL32, IL7R, CD2, B2M, ACAP1, CD27, STK17A, CTSW ## CD247, GIMAP5, AQP3, CCL5, SELL, TRAF3IP3, GZMA, MAL, CST7, ITM2A ## MYC, GIMAP7, HOPX, BEX2, LDLRAP1, GZMK, ETS1, ZAP70, TNFAIP8, RIC3 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1, HLA-DRA, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DMA, HLA-DPB1, HLA-DQA2, CD37, HLA-DRB5, HLA-DMB, HLA-DPA1, FCRLA, HVCN1, LTB ## BLNK, P2RX5, IGLL5, IRF8, SWAP70, ARHGAP24, FCGR2B, SMIM14, PPP1R14A, C16orf74 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA, FGFBP2, CTSW, GNLY, B2M, SPON2 ## CCL4, GZMH, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX ## TTC38, APMAP, CTSC, S100A4, IGFBP7, ANXA1, ID2, IL32, XCL1, RHOC ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, HLA-DPA1, CD74, MS4A1, HLA-DRB1, HLA-DRA ## HLA-DRB5, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, CD37, HVCN1, FCRLA, IRF8 ## PLAC8, BLNK, MALAT1, SMIM14, PLD4, LAT2, IGLL5, P2RX5, SWAP70, FCGR2B ## Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU ## HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, PTCRA, CA2, ACRBP, MMD, TREML1 ## NGFRAP1, F13A1, SEPT5, RUFY1, TSC22D1, MPP1, CMTM5, RP11-367G6.3, MYL9, GP1BA ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1, CD74, HLA-DPB1, HIST1H2AC, PF4, TCL1A ## SDPR, HLA-DPA1, HLA-DRB1, HLA-DQA2, HLA-DRA, PPBP, LINC00926, GNG11, HLA-DRB5, SPARC ## GP9, AP001189.4, CA2, PTCRA, CD9, NRGN, RGS18, GZMB, CLU, TUBB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8, S100A4, GIMAP7, S100A10, S100A9, MAL ## AQP3, CD2, CD14, FYB, LGALS2, GIMAP4, ANXA1, CD27, FCN1, RBP7 ## LYZ, S100A11, GIMAP5, MS4A6A, S100A12, FOLR3, TRABD2A, AIF1, IL8, IFI6 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY, CCL4, CST7, PRF1, GZMA, SPON2 ## GZMH, S100A9, LGALS2, CCL3, CTSW, XCL2, CD14, CLIC3, S100A12, CCL5 ## RBP7, MS4A6A, GSTP1, FOLR3, IGFBP7, TYROBP, TTC38, AKR1C3, XCL1, HOPX ## Negative: LTB, IL7R, CKB, VIM, MS4A7, AQP3, CYTIP, RP11-290F20.3, SIGLEC10, HMOX1 ## PTGES3, LILRB2, MAL, CD27, HN1, CD2, GDI2, ANXA5, CORO1B, TUBA1B ## FAM110A, ATP1A1, TRADD, PPA1, CCDC109B, ABRACL, CTD-2006K23.1, WARS, VMO1, FYB Seurat proporciona varias formas útiles de visualizar tanto las células como las características que definen el PCA, incluidas VizDimReduction(), DimPlot() y DimHeatmap(). Puedes examinar y visualizar los resultados de PCA de diferentes formas. print(pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) En particular, DimHeatmap() permite una fácil exploración de las fuentes primarias de heterogeneidad en un conjunto de datos y puede ser útil cuando se intenta decidir qué PC incluir para análisis posteriores posteriores. Tanto las células como las características se ordenan de acuerdo con sus puntajes de PCA. Establecer cells en un número traza las células “extremas” en ambos extremos del espectro, lo que acelera drásticamente el trazado de grandes conjuntos de datos. Aunque claramente es un análisis supervisado, consideramos que esta es una herramienta valiosa para explorar conjuntos de características correlacionadas. DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) 13.9 Determinar la dimensionalidad del conjunto de datos Para superar el extenso ruido técnico en cualquier característica única para los datos de scRNA-seq, Seurat agrupa las células en función de sus puntuaciones de PCA, y cada PC representa esencialmente una “metafunción” que combina información en un conjunto de características correlacionadas. Por lo tanto, los componentes principales principales representan una compresión sólida del conjunto de datos. Sin embargo, ¿cuántos componentes deberíamos elegir incluir? 10? 20? 100? En Macosko et al, implementamos una prueba de remuestreo inspirada en el procedimiento JackStraw. Permutamos aleatoriamente un subconjunto de los datos (1% por defecto) y volvemos a ejecutar PCA, construyendo una “distribución nula” de puntuaciones de características, y repetimos este procedimiento. Identificamos PC “importantes” como aquellas que tienen un gran enriquecimiento de características de bajo valor p.  # NOTE: This process can take a long time for big datasets, comment out for expediency. More # approximate techniques such as those implemented in ElbowPlot() can be used to reduce # computation time pbmc &lt;- JackStraw(pbmc, num.replicate = 100) pbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20) La función JackStrawPlot() proporciona una herramienta de visualización para comparar la distribución de los p-values para cada PC con una distribución uniforme (línea discontinua). Las PC “significativas” mostrarán un gran enriquecimiento de funciones con valores p bajos (curva sólida por encima de la línea discontinua). En este caso, parece que hay una fuerte caída en la importancia después de los primeros 10-12 PCs. JackStrawPlot(pbmc, dims = 1:15) ## Warning: Removed 23504 rows containing missing values (geom_point). Un método heurístico alternativo genera un “diagrama de codo (Elbow Plot)”: una clasificación de componentes principales basada en el porcentaje de varianza explicada por cada uno (función ElbowPlot()). En este ejemplo, podemos observar un “codo” alrededor de PC9-10, lo que sugiere que la mayor parte de la señal verdadera se captura en las primeras 10 PC. ElbowPlot(pbmc) 13.10 Clustering pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) ## Computing nearest neighbor graph ## Computing SNN pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95965 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8723 ## Number of communities: 9 ## Elapsed time: 0 seconds 13.11 Reducción dimensional no lineal (UMAP/tSNE) Seurat ofrece varias técnicas de reducción dimensional no lineal, como tSNE y UMAP, para visualizar y explorar estos conjuntos de datos. El objetivo de estos algoritmos es aprender la variedad subyacente de los datos para colocar células similares juntas en un espacio de baja dimensión. Las células dentro de los grupos basados en gráficos determinados anteriormente deben ubicarse conjuntamente en estos gráficos de reducción de dimensión. Como entrada para UMAP y tSNE, sugerimos usar las mismas PC como entrada para el análisis de agrupamiento. # If you haven&#39;t installed UMAP, you can do so via reticulate::py_install(packages = &#39;umap-learn&#39;) pbmc &lt;- RunUMAP(pbmc, dims = 1:10) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 15:49:35 UMAP embedding parameters a = 0.9922 b = 1.112 ## 15:49:35 Read 2638 rows and found 10 numeric columns ## 15:49:35 Using Annoy for neighbor search, n_neighbors = 30 ## 15:49:35 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 15:49:35 Writing NN index file to temp file /tmp/RtmptOf5dE/file85718fe4172 ## 15:49:35 Searching Annoy index using 1 thread, search_k = 3000 ## 15:49:36 Annoy recall = 100% ## 15:49:36 Commencing smooth kNN distance calibration using 1 thread ## 15:49:37 Initializing from normalized Laplacian + noise ## 15:49:37 Commencing optimization for 500 epochs, with 105124 positive edges ## 15:49:40 Optimization finished # Note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(pbmc, reduction = &quot;umap&quot;) Puede guardar el objeto en este punto para que se pueda volver a cargar fácilmente sin tener que volver a ejecutar los pasos computacionalmente intensivos realizados anteriormente o compartir fácilmente con los colaboradores. if (interactive()) { saveRDS(pbmc, file = &quot;pbmc_tutorial.rds&quot;) } 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) Seurat puede ayudarlo a encontrar marcadores que definan clústeres mediante expresión diferencial. De forma predeterminada, identifica marcadores positivos y negativos de un solo grupo (especificado en ident.1), en comparación con todas las demás células. FindAllMarkers() automatiza este proceso para todos los clústeres, pero también se pueden comparar grupos de clústeres entre sí o contra todas las células. El argumento min.pct requiere que se detecte una característica en un porcentaje mínimo en cualquiera de los dos grupos de células, y el argumento thresh.test requiere que una característica se exprese diferencialmente (en promedio) en alguna cantidad entre los dos grupos. Puede establecer ambos en 0, pero con un aumento dramático en el tiempo, ya que esto probará una gran cantidad de características que probablemente no sean altamente discriminatorias. - ¿Demasiado lento? Como otra opción para acelerar estos cálculos, se puede configurar el número máximo de células por identificador. Esto reducirá la resolución de cada clase de identidad para que no tenga más células que las que se establezcan. Si bien generalmente habrá una pérdida de potencia, los aumentos de velocidad pueden ser significativos y es probable que las características expresadas de manera más diferencial aún se eleven a la cima. # find all markers of cluster 2 cluster2.markers &lt;- FindMarkers(pbmc, ident.1 = 2, min.pct = 0.25) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.593535e-91 1.2154360 0.949 0.466 3.556774e-87 ## LTB 7.994465e-87 1.2828597 0.981 0.644 1.096361e-82 ## CD3D 3.922451e-70 0.9359210 0.922 0.433 5.379250e-66 ## IL7R 1.130870e-66 1.1776027 0.748 0.327 1.550876e-62 ## LDHB 4.082189e-65 0.8837324 0.953 0.614 5.598314e-61 # find all markers distinguishing cluster 5 from clusters 0 and 3 cluster5.markers &lt;- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 2.150929e-209 4.267579 0.975 0.039 2.949784e-205 ## IFITM3 6.103366e-199 3.877105 0.975 0.048 8.370156e-195 ## CFD 8.891428e-198 3.411039 0.938 0.037 1.219370e-193 ## CD68 2.374425e-194 3.014535 0.926 0.035 3.256286e-190 ## RP11-290F20.3 9.308287e-191 2.722684 0.840 0.016 1.276538e-186 # find markers for every cluster compared to all remaining cells, report only the positive # ones pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## # A tibble: 18 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1.74e-109 1.07 0.897 0.593 2.39e-105 0 LDHB ## 2 1.17e- 83 1.33 0.435 0.108 1.60e- 79 0 CCR7 ## 3 0 5.57 0.996 0.215 0 1 S100A9 ## 4 0 5.48 0.975 0.121 0 1 S100A8 ## 5 7.99e- 87 1.28 0.981 0.644 1.10e- 82 2 LTB ## 6 2.61e- 59 1.24 0.424 0.111 3.58e- 55 2 AQP3 ## 7 0 4.31 0.936 0.041 0 3 CD79A ## 8 9.48e-271 3.59 0.622 0.022 1.30e-266 3 TCL1A ## 9 1.17e-178 2.97 0.957 0.241 1.60e-174 4 CCL5 ## 10 4.93e-169 3.01 0.595 0.056 6.76e-165 4 GZMK ## 11 3.51e-184 3.31 0.975 0.134 4.82e-180 5 FCGR3A ## 12 2.03e-125 3.09 1 0.315 2.78e-121 5 LST1 ## 13 1.05e-265 4.89 0.986 0.071 1.44e-261 6 GZMB ## 14 6.82e-175 4.92 0.958 0.135 9.36e-171 6 GNLY ## 15 1.48e-220 3.87 0.812 0.011 2.03e-216 7 FCER1A ## 16 1.67e- 21 2.87 1 0.513 2.28e- 17 7 HLA-DPB1 ## 17 7.73e-200 7.24 1 0.01 1.06e-195 8 PF4 ## 18 3.68e-110 8.58 1 0.024 5.05e-106 8 PPBP Seurat tiene varias pruebas de expresión diferencial que se pueden configurar con el parámetro test.use (consulte nuestra viñeta DE para obtener más detalles). Por ejemplo, la prueba ROC devuelve el “poder de clasificación” para cualquier marcador individual (que varía de 0 - aleatorio a 1 - perfecto) . cluster0.markers &lt;- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) Se incluyen varias herramientas para visualizar la expresión de los marcadores. VlnPlot() (muestra distribuciones de probabilidad de expresión entre clústeres) y FeaturePlot() (visualiza la expresión de características en un gráfico tSNE o PCA) son nuestras visualizaciones más utilizadas. También sugerimos explorar RidgePlot(), CellScatter() y DotPlot() como métodos adicionales para ver su conjunto de datos. VlnPlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) ## you can plot raw counts as well VlnPlot(pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) FeaturePlot(pbmc, features = c( &quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot; )) # DoHeatmap() generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster. pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) -&gt; top10 DoHeatmap(pbmc, features = top10$gene) + NoLegend() 13.13 Assigning cell type identity to clusters Podemos usar marcadores canónicos para hacer coincidir fácilmente la agrupación imparcial con los tipos de células conocidos. new.cluster.ids &lt;- c( &quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot; ) names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() 13.14 Guardar Resultados if (interactive()) { saveRDS(pbmc, file = &quot;pbmc3k_final.rds&quot;) } 13.15 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-19 15:50:19 UTC&quot; proc.time() ## user system elapsed ## 164.156 12.161 120.738 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr * 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["plática-de-ricardo-ramirez.html", "Plática de Ricardo Ramirez", " Plática de Ricardo Ramirez Empieza la plática científica de Ricardo O. Ramirez Flores @roramirezf94 🇲🇽 🙌🏽https://t.co/iXo6Pnl4tl👀 https://t.co/1J4h0H2QKL#scRNAseq #rstats#rstatsES @Bioconductor #EBM2021 #CDSB2021 @saezlab pic.twitter.com/EBPKwtyhO4 — ComunidadBioInfo (@CDSBMexico) August 13, 2021 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
