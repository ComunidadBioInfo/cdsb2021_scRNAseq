[["index.html", "An√°lisis de datos transcript√≥micos de c√©lula √∫nica (scRNA-seq) con R y Bioconductor Informaci√≥n del taller Formato del curso: en l√≠nea ¬øQui√©n es nuestra audiencia? Formulario de registro Instructores Ponentes e instructores invitados Ayudantes Temario C√≥digo de Conducta Pre-requisitos Horario M√∫sica para ejercicios Materiales Fuentes Zoom Organizadores Patrocinadores Informaci√≥n sesi√≥n de R Licencia", " An√°lisis de datos transcript√≥micos de c√©lula √∫nica (scRNA-seq) con R y Bioconductor Leonardo Collado-Torres Lieber Institute for Brain Development, Johns Hopkins Medical Campus Informaci√≥n del taller 9-13 de agosto de 2021 ¬°Bienvenidxs al taller An√°lisis de datos transcript√≥micos de c√©lula √∫nica (scRNA-seq) con R y Bioconductor! En los √∫ltimos a√±os, la generaci√≥n y an√°lisis de transcriptomas de c√©lula √∫nica ha cobrado gran importancia para resolver preguntas biol√≥gicas. En este taller revisaremos los m√©todos m√°s recientes para analizar datos de single cell RNA-seq (transcript√≥mica en c√©lulas √∫nicas), usando paquetes de R especializados que est√°n disponibles libremente v√≠a Bioconductor. Este taller estar√° basado en el libro Orchestrating Single Cell Analysis with Bioconductor que fue publicado en Nature Methods y es de los art√≠culos con mayor publicidad en 2020 y 2021. Durante este taller aprender√°s las herramientas estad√≠sticas para analizar datos de transcript√≥mica en c√©lulas √∫nicas usando Bioconductor. Revisaremos qu√© es un an√°lisis de datos de c√©lula √∫nica, cu√°les son las principales diferencias entre el an√°lisis de transcriptomas de c√©lula √∫nica y en bulk, c√≥mo documentar tu an√°lisis y algunas herramientas para interpretar tus resultados. Formato del curso: en l√≠nea Este es un curso digital. Las sesiones y material del curso ser√°n presentados en l√≠nea. Esta modalidad incluir√° grabaciones de video o audio del material, intercambio de archivos y sesiones de discusi√≥n tem√°ticos, ejercicios de auto-evaluaci√≥n y acceso a los instructores para comentarios durante el curso. ¬øQui√©n es nuestra audiencia? Este curso est√° dirigido a personas que desean aprender c√≥mo analizar datos transcript√≥micos de c√©lula √∫nica usando paquetes de R/Bioconductor. Revisa los videos de CDSB2020 en YouTube o la p√°gina web de cdsb2020, que es similar al taller de este a√±o. Formulario de registro http://congresos.nnb.unam.mx/EBM2021/ Do you want to learn how to analyze #scRNAseq with @Bioconductor?Learn with @lcolladotor@yalbi_ibm @AnaBetty2304 @argininaa @naielisha @lawrah20 @roramirezf94 @jvelezmagic @KevsGenomic @mpadilla905Material adapted from OSCA @PeteHaitch et al#rstatshttps://t.co/MIfFmKt3Fq pic.twitter.com/nSPCmVEPAC ‚Äî ComunidadBioInfo (@CDSBMexico) July 2, 2021 Instructores Leonardo Collado-Torres Yalbi Balderas https://comunidadbioinfo.github.io/es/#people Ponentes e instructores invitados Ana Beatriz Villase√±or Altamirano Citlali Gil Aguillon Elisa M√°rquez Zavala Laura Lucila G√≥mez Romero Ricardo Ramirez Flores Ayudantes Jes√∫s V√©lez Santiago Kevin Emmanuel Meza Landeros M√≥nica Padilla G√°lvez Temario D√≠a 1 Introducci√≥n a R y RStudio Ejercicio usando usethis, here y postcards Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA D√≠a 2 Estructura e importe de datos Comunidades RLadies Control de calidad D√≠a 3 Normalizaci√≥n de datos Foto y actividades de la comunidad Selecci√≥n de genes D√≠a 4 Reducci√≥n de dimensiones Clustering Identificaci√≥n de genes marcadores D√≠a 5 Anotaci√≥n de clusters de c√©lulas An√°lisis de expresi√≥n diferencial Pl√°tica cient√≠fica del ponente invitadx C√≥digo de Conducta Seguiremos el c√≥digo de conducta de la CDSB M√©xico comunidadbioinfo.github.io/es/codigo-de-conducta/ adem√°s del c√≥digo de conducta de Bioconductor bioconductor.org/about/code-of-conduct/. Pre-requisitos De forma general, Computadora con al menos 8Gb de memoria y permisos de administrador para instalar paqueter√≠as de R. Tener instalado R y RStudio en su √∫ltima versi√≥n. Conocimientos b√°sicos de secuenciaci√≥n de transcriptomas. Conocimientos b√°sicos de RStudio (Creaci√≥n de Rscripts, manejo de la consola de RStudio, manejo del espacio de visualizaci√≥n). Conocimiento intermedio de R (Manejo de variables, lectura de archivos, creaci√≥n y manejo de data frames y listas, generaci√≥n de gr√°ficas b√°sicas, conocimiento sobre c√≥mo instalar paqueter√≠as desde CRAN y Bioconductor). M√°s espec√≠ficamente, computadora con al menos 8 GB de memoria RAM, aplicaci√≥n Zoom https://zoom.us/download, R versi√≥n 4.1 instalada de CRAN https://cran.r-project.org/ (ver video de https://youtu.be/6knyHlUe1cM sobre como instalar R en macOS o winOS), RStudio versi√≥n 1.4 https://www.rstudio.com/products/rstudio/download/#download, y los siguientes paquetes de R y Bioconductor: ## Para instalar paquetes if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } ## Para instalar paquetes de Bioconductor remotes::install_cran(&quot;BiocManager&quot;) BiocManager::version() # El anterior comando debe mostrar que est√°s usando la versi√≥n 3.13 ## Instala los paquetes de R que necesitamos ## BiocManager::install(c(&quot;batchelor&quot;, &quot;BiocFileCache&quot;, &quot;BiocSingular&quot;, &quot;bluster&quot;, &quot;celldex&quot;, &quot;cowplot&quot;, &quot;dplyr&quot;, &quot;DropletUtils&quot;, &quot;edgeR&quot;, &quot;EnsDb.Hsapiens.v86&quot;, &quot;ExperimentHub&quot;, &quot;ExploreModelMatrix&quot;, &quot;fossil&quot;, &quot;gert&quot;, &quot;ggrepel&quot;, &quot;gh&quot;, &quot;here&quot;, &quot;iSEE&quot;, &quot;kableExtra&quot;, &quot;lobstr&quot;, &quot;MouseGastrulationData&quot;, &quot;org.Mm.eg.db&quot;, &quot;patchwork&quot;, &quot;PCAtools&quot;, &quot;pheatmap&quot;, &quot;plotly&quot;, &quot;Polychrome&quot;, &quot;postcards&quot;, &quot;pryr&quot;, &quot;RColorBrewer&quot;, &quot;Rtsne&quot;, &quot;scater&quot;, &quot;scPipe&quot;, &quot;scran&quot;, &quot;scRNAseq&quot;, &quot;sessioninfo&quot;, &quot;Seurat&quot;, &quot;SingleCellExperiment&quot;, &quot;SingleR&quot;, &quot;suncalc&quot;, &quot;TENxPBMCData&quot;, &quot;usethis&quot;, &quot;uwot&quot;)) Horario Consulta el calendario de este curso en: http://bit.ly/calendarcdsb2021. Horario Tema Instructores D√≠a 1: Agosto 9, 2021 08:00-09:00 (opcional) Ayuda con instalaci√≥n de paquetes de R 09:00-09:30 Inauguraci√≥n EBM2021 Julio Collado Vides, Christian Sohlenkamp, Irma Mart√≠nez Flores, Shirley Alquicira Hern√°ndez 09:30-10:00 Bienvenida a la CDSB y revisi√≥n del c√≥digo de conducta Leonardo Collado-Torres 10:00-11:00 Introducci√≥n a R y RStudio Leonardo Collado-Torres 11:00-11:30 Descanso 11:30-14:00 Ejercicio usando usethis, here y postcards Citlali Gil Aguillon y Elisa M√°rquez Zavala 14:00-15:30 Descanso: comida 15:30-17:00 Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA Citlali Gil Aguillon y Elisa M√°rquez Zavala 17:00-18:00 (Invitada) Principios FAIR para software de investigaci√≥n Paula Andrea D√≠a 2: Agosto 10, 2021 08:00-09:00 (opcional) Ayuda con instalaci√≥n de paquetes de R 09:00-11:00 Estructura e importe de datos Citlali Gil Aguillon y Elisa M√°rquez Zavala 11:00-11:30 Descanso 11:30-12:00 Keynote: La comunidad R-Ladies Ana Beatriz Villase√±or Altamirano 12:00-14:00 Control de calidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Control de calidad Leonardo Collado-Torres 17:30-18:00 (opcional) Interact√∫a con lxs instructores y ayudantes D√≠a 3: Agosto 11, 2021 08:00-09:00 (opcional) Ayuda con instalaci√≥n de paquetes de R 09:00-10:30 Normalizaci√≥n de datos Ana Beatriz Villase√±or Altamirano 10:30-11:00 Foto 11:00-11:30 Descanso 11:30-12:30 Selecci√≥n de genes Yalbi Balderas 12:30-14:00 Actividades para construir la comunidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Selecci√≥n de genes Laura Lucila G√≥mez Romero 17:30-18:00 (opcional) Interact√∫a con lxs instructores y ayudantes D√≠a 4: Agosto 12, 2021 08:00-09:00 (opcional) Ayuda con instalaci√≥n de paquetes de R 09:00-11:00 Reducci√≥n de dimensiones Laura Lucila G√≥mez Romero 11:00-11:30 Descanso 11:30-14:00 Clustering Laura Lucila G√≥mez Romero 14:00-15:30 Descanso: comida 15:30-17:30 Identificaci√≥n de genes marcadores Yalbi Balderas 17:30-18:30 CDSB 2021: Evento social remoto D√≠a 5: Agosto 13, 2021 08:00-09:00 (opcional) Ayuda con instalaci√≥n de paquetes de R 09:00-10:30 Anotaci√≥n de clusters de c√©lulas Yalbi Balderas 10:30-11:00 Evaluaci√≥n del taller Irma Mart√≠nez Flores y Shirley Alquicira Hern√°ndez 11:00-11:30 Descanso 11:30-12:30 An√°lisis de expresi√≥n diferencial Leonardo Collado-Torres 12:30-14:00 Introducci√≥n a Seurat Kevin Emmanuel Meza Landeros 14:00-15:30 Descanso: comida 15:30-17:00 Pl√°tica cient√≠fica y sesi√≥n de preguntas Ricardo Ramirez Flores 17:00-17:30 Clausura y recordatorio de la CDSB 17:30-18:00 (opcional) Interact√∫a con lxs instructores y ayudantes M√∫sica para ejercicios Aqu√≠ est√°n las listas de canciones por si desean escuchar algo de m√∫sica mientras realizan ejercicios iTunes Spotify Materiales Descarga los materiales con usethis::use_course('comunidadbioinfo/cdsb2021_scRNAseq') o revisalos en l√≠nea v√≠a comunidadbioinfo.github.io/cdsb2021_scRNAseq. Durante el curso Durante el curso estaremos actualizando el material, as√≠ que les recomendamos que usen RStudio para crear un nuevo proyecto que est√© configurado con git/GitHub, para que con un simple Pull puedan actualizar los archivos del curso en su computadora. Para que funcione bien esto, les recomendamos que no editen los archivos que descarguen. Eso mejor h√°ganlo en sus notas. Primero, en RStudio seleccionen File y luego New Project .... Les saldr√° la siguiente ventana donde tienen que escoger la opci√≥n de control de versiones. Figure 0.1: Al crear un nuevo proyecto, seleccionen la opci√≥n de Version Control (la tercera). A continuaci√≥n, seleccionen la opci√≥n de Git. Figure 0.2: Selecciona la opci√≥n de Git (la primera). En la venta para especificar los detalles de git, Espec√≠fica el siguiente URL del repositorio https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git El nombre del directorio se llenar√° de forma autom√°tica. No tienes que cambiarlo. Especif√≠ca el subdirectorio de donde quieres que guarde este proyecto. Te conviene ponerlo en tu Desktop o alg√∫n lugar que no sea adentro de otro proyecto de RStudio. Selecciona la opci√≥n de Open in new session para que te abra una nueva ventana de RStudio si as√≠ lo prefieres. Figure 0.3: Especifica que el Repository URL es https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git. Fuentes El material de este curso est√° basado en el: libro Orchestrating Single Cell Analysis with Bioconductor de Aaron Lun, Robert Amezquita, Stephanie Hicks y Raphael Gottardo curso de scRNA-seq para WEHI creado por Peter Hickey curso de Leonardo Collado-Torres para LCG-UNAM-EJ de marzo 2020 https://github.com/lcolladotor/osca_LIIGH_UNAM_2020 taller de la CDSB 2020 https://github.com/ComunidadBioInfo/cdsb2020 curso de Leonardo Collado-Torres para la LCG-UNAM de febrero 2021 https://github.com/lcolladotor/rnaseq_LCG-UNAM_2021 Zoom Las ligas de Zoom est√°n disponibles exclusivamente para lxs participantes de CDSB2021 v√≠a Slack. Te enviaremos una invitaci√≥n al correo electr√≥nico que usaste para registrate. Organizadores Comunidad de Desarrolladores de Software en Bioinform√°tica CDSB Red Mexicana de Bioinform√°tica RMB Nodo Nacional de Bioinform√°tica en la UNAM NNB-CCG Patrocinadores Agradecemos a nuestros patrocinadores: Informaci√≥n sesi√≥n de R Detalles de la sesi√≥n de R usada para crear este libro. El c√≥digo fuente est√° disponible v√≠a ComunidadBioInfo/cdsb2021_scRNAseq. options(width = 120) pkgs &lt;- installed.packages()[, &quot;Package&quot;] sessioninfo::session_info(pkgs, include_base = TRUE) ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## ade4 1.7-17 2021-06-17 [1] RSPM (R 4.1.0) ## annotate 1.70.0 2021-05-19 [1] Bioconductor ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## AnVIL 1.4.1 2021-06-22 [2] Bioconductor ## ape 5.5 2021-04-25 [1] RSPM (R 4.1.0) ## askpass 1.1 2019-01-13 [2] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## backports 1.2.1 2020-12-09 [1] RSPM (R 4.1.0) ## base * 4.1.0 2021-07-29 [3] local ## base64enc 0.1-3 2015-07-28 [1] RSPM (R 4.1.0) ## batchelor 1.8.1 2021-08-12 [1] Bioconductor ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## benchmarkme 1.0.7 2021-03-21 [1] RSPM (R 4.1.0) ## benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.1.0) ## BH 1.75.0-0 2021-01-11 [1] RSPM (R 4.1.0) ## Biobase 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocStyle 2.20.2 2021-06-17 [1] Bioconductor ## biocthis 1.2.0 2021-05-19 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## boot 1.3-28 2021-05-03 [3] CRAN (R 4.1.0) ## brew 1.0-6 2011-04-13 [2] RSPM (R 4.1.0) ## brio 1.1.2 2021-04-23 [2] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## BumpyMatrix 1.0.1 2021-07-04 [1] Bioconductor ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## callr 3.7.0 2021-04-20 [2] RSPM (R 4.1.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.1.0) ## cdsb2021scRNAseq 0.99.0 2021-08-19 [1] local ## celldex 1.2.0 2021-05-20 [1] Bioconductor ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## class 7.3-19 2021-05-03 [3] CRAN (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clipr 0.7.1 2020-10-08 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## clusterExperiment 2.12.0 2021-05-19 [1] Bioconductor ## ClusterR 1.2.5 2021-05-21 [1] RSPM (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## commonmark 1.7 2018-12-01 [2] RSPM (R 4.1.0) ## compiler 4.1.0 2021-07-29 [3] local ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## cpp11 0.3.1 2021-06-25 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## credentials 1.3.1 2021-07-25 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## datasets * 4.1.0 2021-07-29 [3] local ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## desc 1.3.0 2021-03-05 [2] RSPM (R 4.1.0) ## devtools 2.4.2 2021-06-07 [2] RSPM (R 4.1.0) ## diffobj 0.3.4 2021-03-22 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## docopt 0.7.1 2020-06-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## ExploreModelMatrix 1.4.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## forcats 0.5.1 2021-01-27 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## foreign 0.8-81 2020-12-22 [3] CRAN (R 4.1.0) ## formatR 1.11 2021-06-01 [1] RSPM (R 4.1.0) ## fossil 0.4.0 2020-03-23 [1] RSPM (R 4.1.0) ## fs 1.5.0 2020-07-31 [2] RSPM (R 4.1.0) ## futile.logger 1.4.3 2016-07-10 [1] RSPM (R 4.1.0) ## futile.options 1.0.1 2018-04-20 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## genefilter 1.74.0 2021-05-19 [1] Bioconductor ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges 1.44.0 2021-05-19 [1] Bioconductor ## gert 1.3.2 2021-08-16 [2] RSPM (R 4.1.0) ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## gh 1.3.0 2021-04-30 [2] RSPM (R 4.1.0) ## gitcreds 0.1.1 2020-12-04 [2] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gmp 0.6-2 2021-01-07 [1] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gplots 3.1.1 2020-11-28 [1] RSPM (R 4.1.0) ## graphics * 4.1.0 2021-07-29 [3] local ## grDevices * 4.1.0 2021-07-29 [3] local ## grid 4.1.0 2021-07-29 [3] local ## gridBase 0.4-7 2014-02-24 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## gtools 3.9.2 2021-06-06 [1] RSPM (R 4.1.0) ## hash 2.2.6.1 2019-03-04 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## howmany 0.3-1 2012-06-01 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## ini 0.3.1 2018-05-20 [2] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE 2.4.0 2021-05-19 [1] Bioconductor ## isoband 0.2.5 2021-07-13 [1] RSPM (R 4.1.0) ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## kernlab 0.9-29 2019-11-12 [1] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lambda.r 1.2.4 2019-09-18 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## littler 0.3.13 2021-07-24 [2] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfdr 1.1-8 2015-07-15 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## lubridate 1.7.10 2021-02-26 [1] RSPM (R 4.1.0) ## magick 2.7.2 2021-05-02 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## maps 3.3.0 2018-04-03 [1] RSPM (R 4.1.0) ## markdown 1.1 2019-08-07 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mbkmeans 1.8.0 2021-05-19 [1] Bioconductor ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## methods * 4.1.0 2021-07-29 [3] local ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## MouseGastrulationData 1.6.0 2021-05-20 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## NMF 0.23.0 2020-08-01 [1] RSPM (R 4.1.0) ## nnet 7.3-16 2021-05-03 [3] CRAN (R 4.1.0) ## openssl 1.4.4 2021-04-30 [2] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## parallel 4.1.0 2021-07-29 [3] local ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## PCAtools 2.4.0 2021-05-19 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## phylobase 0.8.10 2020-03-01 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pixmap 0.4-12 2021-01-29 [1] RSPM (R 4.1.0) ## pkgbuild 1.2.0 2020-12-15 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## pkgload 1.2.1 2021-04-06 [2] RSPM (R 4.1.0) ## pkgmaker 0.32.2 2020-10-20 [1] RSPM (R 4.1.0) ## plogr 0.2.0 2018-03-25 [1] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## Polychrome 1.3.1 2021-07-16 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## postcards 0.2.2 2021-07-31 [1] RSPM (R 4.1.0) ## pracma 2.3.3 2021-01-23 [1] RSPM (R 4.1.0) ## praise 1.0.0 2015-08-11 [2] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## processx 3.5.2 2021-04-30 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## pryr 0.1.5 2021-07-26 [1] RSPM (R 4.1.0) ## ps 1.6.0 2021-02-28 [2] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.cache 0.15.0 2021-04-30 [1] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rapiclient 0.1.3 2020-01-17 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## rcmdcheck 1.3.3 2019-05-07 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RcppArmadillo 0.10.6.0.0 2021-07-16 [1] RSPM (R 4.1.0) ## RcppEigen 0.3.3.9.1 2020-12-17 [1] RSPM (R 4.1.0) ## RcppHNSW 0.3.0 2020-09-06 [1] RSPM (R 4.1.0) ## RcppProgress 0.4.2 2020-02-06 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## registry 0.5-1 2019-03-05 [1] RSPM (R 4.1.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.1.0) ## remotes 2.4.0 2021-06-02 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## rncl 0.8.4 2020-02-10 [1] RSPM (R 4.1.0) ## RNeXML 2.4.5 2020-06-18 [1] RSPM (R 4.1.0) ## rngtools 1.5 2020-01-23 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## roxygen2 7.1.1 2020-06-27 [2] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rversions 2.1.1 2021-05-31 [2] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scatterplot3d 0.3-41 2018-03-14 [1] RSPM (R 4.1.0) ## scPipe 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle 1.2.1 2021-08-05 [1] Bioconductor ## selectr 0.4-2 2019-11-20 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shapefiles 0.7 2013-01-26 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment 1.14.1 2021-05-21 [1] Bioconductor ## SingleR 1.6.1 2021-05-20 [1] Bioconductor ## sitmo 2.0.1 2019-01-07 [1] RSPM (R 4.1.0) ## snow 0.4-3 2018-09-14 [1] RSPM (R 4.1.0) ## softImpute 1.4-1 2021-05-09 [1] RSPM (R 4.1.0) ## sourcetools 0.1.7 2018-04-25 [1] RSPM (R 4.1.0) ## sp 1.4-5 2021-01-10 [1] RSPM (R 4.1.0) ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatial 7.3-14 2021-05-03 [3] CRAN (R 4.1.0) ## SpatialExperiment 1.2.1 2021-06-10 [1] Bioconductor ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## splines 4.1.0 2021-07-29 [3] local ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stats * 4.1.0 2021-07-29 [3] local ## stats4 4.1.0 2021-07-29 [3] local ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## styler 1.5.1 2021-07-13 [1] RSPM (R 4.1.0) ## SummarizedExperiment 1.22.0 2021-05-19 [1] Bioconductor ## suncalc 0.5.0 2019-04-03 [1] RSPM (R 4.1.0) ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## sys 3.4 2020-07-23 [2] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tcltk 4.1.0 2021-07-29 [3] local ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## TENxPBMCData 1.10.0 2021-05-20 [1] Bioconductor ## testthat 3.0.4 2021-07-01 [2] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## tinytex 0.33 2021-08-05 [1] RSPM (R 4.1.0) ## tools 4.1.0 2021-07-29 [3] local ## usethis 2.0.1 2021-02-10 [2] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## utils * 4.1.0 2021-07-29 [3] local ## uuid 0.1-4 2020-02-26 [1] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## waldo 0.2.5 2021-03-08 [2] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## whisker 0.4 2019-08-28 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xopen 1.0.0 2018-09-17 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zinbwave 1.14.1 2021-05-25 [1] Bioconductor ## zip 2.2.0 2021-05-31 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Fecha de la √∫ltima actualizaci√≥n de esta p√°gina: 2021-08-19 15:15:46. Licencia This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["inauguraci√≥n-cdsb2021.html", "Inauguraci√≥n CDSB2021", " Inauguraci√≥n CDSB2021 "],["introducci√≥n-a-r-y-rstudio.html", "1 Introducci√≥n a R y RStudio 1.1 R 1.2 GitHub 1.3 RStudio 1.4 Material del curso 1.5 Detalles de la sesi√≥n de R Patrocinadores", " 1 Introducci√≥n a R y RStudio Instructor: Leonardo Collado Torres 1.1 R R: es gratis, de acceso libre, utilizado para muchos campos de trabajo, fuerte en la bioinform√°tica a trav√©s de Bioconductor Instalaci√≥n a trav√©s de CRAN: https://cran.r-project.org/ Para explorar que se puede hacer con R: R Weekly https://rweekly.org/ R Bloggers https://www.r-bloggers.com/ Twitter https://twitter.com/search?q=%23rstats&amp;src=typed_query Twitter en espa√±ol https://twitter.com/search?q=%23rstatsES&amp;src=typed_query TidyTuesday https://twitter.com/search?q=%23TidyTuesday&amp;src=typed_query DatosDeMiercoles https://twitter.com/search?q=%23datosdemiercoles&amp;src=typed_query Para pedir ayuda hay muchas opciones https://lcolladotor.github.io/bioc_team_ds/how-to-ask-for-help.html Material en el que estoy involucrado: https://twitter.com/lcolladotor https://www.youtube.com/c/LeonardoColladoTorres/playlists LIBD rstats club https://docs.google.com/spreadsheets/d/1is8dZSd0FZ9Qi1Zvq1uRhm-P1McnJRd_zxdAfCRoMfA/edit?usp=sharing https://twitter.com/CDSBMexico, https://twitter.com/LIBDrstats, https://twitter.com/Bioconductor https://comunidadbioinfo.github.io/ YouTube CDSB: https://www.youtube.com/channel/UCHCdYfAXVzJIUkMoMSGiZMw Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor https://lmweber.org/OSTA-book/ Thank you @Bioconductor for welcoming me &amp; providing me a foundation &amp; platform for my careerGracias BioC por darme una oportunidad y plataforma para desarrollar mi carreraTime to pass it on/Toca ense√±ar y crecer la bola de nieve ‚ùÑÔ∏è @CDSBMexico üá≤üáΩ#BioC2021 #rstats #rstatsES https://t.co/8cDXP4Pf2W pic.twitter.com/rpQgH8UsWW ‚Äî üá≤üáΩ Leonardo Collado-Torres (@lcolladotor) August 5, 2021 1.2 GitHub Permite compartir c√≥digo Se complementa con Git que es para tener un control de versiones de tu c√≥digo https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Introduccion-al-flujo-de-trabajo-orientado-a-proyectos.pdf Puedes tener p√°ginas web est√°ticas https://pages.github.com/ https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/. En especial https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/tree/gh-pages se convierte en https://comunidadbioinfo.github.io/cdsb2021_scRNAseq/ P√°gina personal: https://github.com/lcolladotor/lcolladotor.github.com se convierte en http://lcolladotor.github.io/. Est√° todo hecho con https://github.com/lcolladotor/lcolladotorsource Tip: usen el mismo nombre de usuario en GitHub, Twitter, Gmail, etc. How to be a Modern Scientist: https://lcolladotor.github.io/bioc_team_ds/how-to-be-a-modern-scientist.html 1.3 RStudio RStudio Desktop es gratis http://www.rstudio.com/products/rstudio/download/preview/ Nos ayuda a realizar muchas cosas con R de forma m√°s r√°pida Demo rsthemes remotes::install_github(c( &quot;gadenbuie/rsthemes&quot; )) remotes::install_cran(&quot;suncalc&quot;) rsthemes::install_rsthemes(include_base16 = TRUE) usethis::edit_r_profile() ## From https://www.garrickadenbuie.com/project/rsthemes/ if (interactive() &amp;&amp; requireNamespace(&quot;rsthemes&quot;, quietly = TRUE)) { # Set preferred themes if not handled elsewhere.. rsthemes::set_theme_light(&quot;Solarized Light {rsthemes}&quot;) # light theme rsthemes::set_theme_dark(&quot;base16 Monokai {rsthemes}&quot;) # dark theme rsthemes::set_theme_favorite(c( &quot;Solarized Light {rsthemes}&quot;, &quot;base16 Monokai {rsthemes}&quot;, &quot;One Dark {rsthemes}&quot; )) # Whenever the R session restarts inside RStudio... setHook(&quot;rstudio.sessionInit&quot;, function(isNewSession) { # Automatically choose the correct theme based on time of day ## Used rsthemes::geolocate() once rsthemes::use_theme_auto(lat = 39.2891, lon = -76.5583) }, action = &quot;append&quot;) } ## https://blog.rstudio.com/2013/06/10/rstudio-cran-mirror/ options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) Es actualizado con bastante frecuencia RStudio cheatsheets https://www.rstudio.com/resources/cheatsheets/ https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf RStudio projects: usalos para organizar tu c√≥digo https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Trabajando-con-proyectos.pdf usethis::create_project(&quot;~/Desktop/cdsb2021_scRNAseq_notas&quot;) ## Inicien un archivo para sus notas usethis::use_r(&quot;01-notas.R&quot;) O por ejemplo el archivo 01-visualizar-mtcars.R ## Creemos el archivo R/01-visualizar-mtcars.R usethis::use_r(&quot;01-visualizar-mtcars.R&quot;) con el siguiente contenido: ## Cargar paquetes que usaremos en este c√≥digo library(&quot;sessioninfo&quot;) library(&quot;here&quot;) library(&quot;ggplot2&quot;) ## Hello world print(&quot;Soy Leo&quot;) ## Crear directorio para las figuras dir.create(here::here(&quot;figuras&quot;), showWarnings = FALSE) ## Hacer una imagen de ejemplo pdf(here::here(&quot;figuras&quot;, &quot;mtcars_gear_vs_mpg.pdf&quot;), useDingbats = FALSE ) ggplot(mtcars, aes(group = gear, y = mpg)) + geom_boxplot() dev.off() ## Para reproducir mi c√≥digo options(width = 120) sessioninfo::session_info() Configura usethis con GitHub v√≠a https://usethis.r-lib.org/articles/articles/git-credentials.html ## Para poder conectar tu compu con GitHub usethis::create_github_token() ## Abrir√° una p√°gina web, escoje un nombre √∫nico ## y luego da click en el bot√≥n verde al final. Despu√©s copia el token ## (son 40 caracteres) gitcreds::gitcreds_set() ## Ojo, copia el token, no tu password de git! ## Si no, terminaras en la situaci√≥n descrita en ## https://github.com/r-lib/usethis/issues/1347 ## Configura tu usuario de GitHub usethis::edit_git_config() # [user] # name = Leonardo Collado Torres # email = lcolladotor@gmail.com ## Para inicializar el repositorio de Git usethis::use_git() ## Para conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Resultado ejemplo: https://github.com/lcolladotor/cdsb2021_scRNAseq_notas. El que hice en vivo est√° disponible v√≠a https://github.com/lcolladotor/cdsb2021_scRNAseq_notas_en_vivo (o https://github.com/lcolladotor/rnaseq_2021_notas_en_vivo para un ejemplo de febrero 2021). Una vez que termines, agrega la liga al repositorio con tus notas del curso en el Google Sheet del curso. (De ser necesario, pide permisos para editar el archivo.) 1.4 Material del curso Pueden descargar la versi√≥n est√°tica con usethis::use_course('ComunidadBioInfo/cdsb2021_scRNAseq') Pueden verlo en l√≠nea a trav√©s de ComunidadBioInfo.github.io/cdsb2021_scRNAseq Pueden clonarlo desde GitHub de tal forma que podr√°n actualizarlo f√°cilmente usando git pull git clone https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git ## Si tienen su SSH key configurarda pueden usar ## Info sobre SSH keys de GitHub: ## https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent git clone git@github.com:ComunidadBioInfo/cdsb2021_scRNAseq.git O desde R con: ## Opci√≥n m√°s nueva: library(&quot;gert&quot;) repo &lt;- git_clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) setwd(repo) ## Otra opci√≥n: git2r::clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) 1.5 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:15:47 UTC&quot; proc.time() ## user system elapsed ## 0.407 0.145 0.438 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["ejercicio-usando-usethis-here-y-postcards.html", "2 Ejercicio usando usethis, here y postcards 2.1 here 2.2 usethis 2.3 Vinculando RStudio con Git y GitHub 2.4 Ejercicio postcards 2.5 Detalles de la sesi√≥n de R Patrocinadores", " 2 Ejercicio usando usethis, here y postcards Instructoras: Elisa M√°rquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres 2.1 here Este paquete es bastante √∫til El directorio que toma como base ser√° en el que nos encontremos al momento de cargar el paquete here, heuristicamente busca la ra√≠z del proyecto y se posiciona en √©l. # se descarg√≥ previamente, as√≠ que solo se carga library(&quot;here&quot;) # busca la raiz del proyecto en el que se encuentre En ciertas ocasiones puede haber algun error, ya que puede chocar con otros paquetes (como plyr). para evitar esto podemos usar here::here (que b√°sicamente aclara que la funci√≥n solicitada es del paquete here) here::here() Podemos checar en qu√© directorio nos encontramos con getwd(), si no es el que deseamos podemos cambiarlo con setwd() getwd() # regresa la path en donde nos encontramos setwd(&quot;direccion/deseada&quot;) # nos lleva a la path indicada Pero con here podemos no especificar la path getwd() # para checar en donde nos encontramos here::here() # para checar d√≥nde te encuentras # nos movemos al subdirectorio R setwd(here::here(&quot;R&quot;)) # podemos cambiar de directorio, aun as√≠ `here est√° en la ra√≠z A continuaci√≥n ofrecemos algunos ejemplos de c√≥mo podr√≠a emplearse here::here # como ejemplo: vamos a guardar datos en archivo y cargarlos a &lt;- 1 c &lt;- 23 save(a, c, file = here::here(&quot;datos-prueba.RData&quot;)) # rm(a,c) load(here::here(&quot;datos-prueba.RData&quot;)) # creamos un directorio dir.create(here::here(&quot;subdirectorio&quot;), showWarnings = FALSE) # podemos crear un archivo, indicando el subdirectorio, (en este caso el primer argumento) file.create(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # abrimos el nuevo archivo creado file.show(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # podemos editarlo!! # por ejemplo si quisieramos ver nuestros archivos del directorio list.files(here::here(), recursive = TRUE) 2.2 usethis manual de usuario usethis puede ser m√°s amigable, por ejemplo para la creaci√≥n de nuevos archivos .R es capaz de agruparlos en la carpeta R (dando un orden al proyecto) usethis::use_r(&quot;notas-prueba.R&quot;) # no importando en qu√© path estemos En el siguiente ejercicio veremos algunos usos de usethis 2.3 Vinculando RStudio con Git y GitHub Ahora vamos a vincular nuestro proyecto de Rstudio con Github, esto es muy util para tener un control de nuestros archivos, poder compartirlos o usar el de otrxs 2.3.1 Prerrequisitos Debemos tener una cuenta de Github. Si no tienes este es el momento para crear una cuenta! https://docs.github.com/es/github/getting-started-with-github/signing-up-for-github/signing-up-for-a-new-github-account Tambi√©n debemos instalar git en nuestras computadoras ya que el paquete gitcreds lo requiere https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Despues de instalar git debemor reiniciar nuestro RStudio para que pueda anexarse Y la instalaci√≥n de los siguientes paquetes: # paquetes que vamos a requerir install.packages(c(&quot;gitcreds&quot;, &quot;gert&quot;, &quot;gh&quot;)) # cargarlos de manera separada library(&quot;gitcreds&quot;) library(&quot;gert&quot;) library(&quot;gh&quot;) 2.3.2 Creando token de acceso personal (PAT) Para conectar nuestro repositorio de Rstudio con Github solicitamos un token, esto para que github otorgue permiso a nuestra computadora Emplearemos el siguiente bloque de c√≥digo para solicitar dicho token (elige un nombre significativo) Otra manera de solicitar el token es ingresando a https://github.com/settings/tokens, esta opci√≥n no dar√° una recomendaci√≥n de los par√°metros a seleccionar El par√°metro de expiraci√≥n del token puede cambiarse para que no expire (por seguridad no lo recomienda Github), de otra manera considera su tiempo de vigencia Una vez generado el token debes guardarlo, pues no volver√° a aparecer. Siempre puedes volver a generar uno nuevo (no olvides borrar el token anterior) # Para iniciar conexi√≥n con GitHub usethis::create_github_token() # redirige a github donde eligiras nombre especifico del token # copia el token para despu√©s ingresarlo con gitcreds_set() gitcreds::gitcreds_set() # aqu√≠ colocas el token (NO tu contrase√±a de github!!!) NOTA: en el comando gitcreds::gitcreds_set() NO debemos poner nuestro token entre parentesis, sino que al ejecutar el comando la misma funci√≥n nos pedir√° ingresar el token El siguiente paso ser√° configurar nuestro usuario de github en el archivo .gitconfig # Configurar usuario de gitHub usethis::edit_git_config() # que abre el archivo .gitconfig # colocaremos nombre y correo de cuenta de github. SOLO borrar los # y respetar los demas espacios # [user] # name = N O M B R E # email = correodeGithub 2.3.3 Inicializar repositorio de Git y Github Ahora vamos a inicializar el repositorio en Git (de manera local en tu computadora) y enseguida solicitamos que se conecte con los servidores de Github # inicializar el repositorio de Git usethis::use_git() # # conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Git es el software mientras que GitHub es la plataforma web (basada en Git) que permite la colaboraci√≥n LISTO!! Comando √∫til para checar configuraci√≥n gh::gh_whoami() # para checar c√≥mo qued√≥ la configuraci√≥n 2.3.4 Probar otros comandos de gert Una vez que ya vinculamos nuestro repositorio con github podemos seguir actualizandolo. Vamos a checar brevemente algunos de los comandos que son √∫tiles para ello: Checaremos git_add, git_commit, git_log y git_push # escribimos un nuevo archivo, volvemos a usar here::here para especificar path writeLines(&quot;hola&quot;, here::here(&quot;R&quot;, &quot;prueba-here.R&quot;)) # otra manera es usar use_r usethis::use_r(&quot;archivo-prueba-github.R&quot;) # a√±ade archivo al directorio R del proyecto actual # Por ejemplo podr√≠amos probar a√±adir algo nuevo gert::git_add(&quot;R/archivo-prueba-github.R&quot;) # a√±adimos commit de lo que se hizo gert::git_commit(&quot;se subio archivo prueba&quot;) # nos da info de los commits gert::git_log() # sube tus cambios del repo local a los de github gert::git_push() # COMANDO IMPORTANTE Puede ser m√°s amigable usar el recuadro de Git que aparece en RStudio para hacer todo lo anterior! Recuerden subir sus repositorios al Google Sheet 2.4 Ejercicio postcards Similar a https://pages.github.com/ postcards tiene 4 templados de p√°ginas web https://github.com/seankross/postcards Tu p√°gina web debe describir decir algo sobre ti, tus intereses, y tus proyectos adem√°s de c√≥mo contactarte Ejemplo https://amy-peterson.github.io/ v√≠a https://github.com/amy-peterson/amy-peterson.github.com http://jtleek.com/ v√≠a https://github.com/jtleek/jtleek.github.io http://aejaffe.com/ v√≠a https://github.com/andrewejaffe/andrewejaffe.github.io 2.4.1 Crear el repositorio Podemos crearlo desde RStudio o desde github.com (opci√≥n 1) Desde RStudio ¬°Cuidado!: Antes de crear un proyecto, revisen d√≥nde est√°n parados (getwd()) en su directorio y d√≥nde quieren que se cree ## Creen el RStudio project. Es MUY importante que el usuario debe sea igual que en github usethis::create_project(&quot;Su_Usuario.github.io&quot;) Nuevo proyecto : git user ## Configura Git y GitHub # Con use_git() preguntar√° si desean hacer un commit, y despu√©s pedir√° reiniciar Rstudio para que obtengan un nuevo bot√≥n llamado &quot;git()&quot; usethis::use_git() Nuevo bot√≥n button_git usethis::use_github() Creen su templado usando postcards corriendo una de las 4 l√≠neas (la que tenga el templado que m√°s les gust√≥). Va a crear un archivo index.Rmd ## Solo uno de estos, de acuerdo al templado que m√°s les gust√≥ postcards::create_postcard(template = &quot;jolla&quot;) postcards::create_postcard(template = &quot;jolla-blue&quot;) postcards::create_postcard(template = &quot;trestles&quot;) postcards::create_postcard(template = &quot;onofre&quot;) (opci√≥n 2) Desde github Creen un nuevo repositorio, p√∫blico y sin archivo README en https://github.com/new llamado ‚Äúusuario.github.io‚Äù con su nombre exacto en github ¬°Cuidado! El repositorio debe ser p√∫blico y sin README Creen un nuevo proyecto en RStudio: File &gt; New_project &gt; New directory &gt; Postcards Website Elijan el templado que m√°s les gust√≥ Ya con el proyecto creado, hay que configurar git y github ## Configura Git y GitHub # Con use_git() preguntar√° si desean hacer un commit, y despu√©s pedir√° reiniciar Rstudio para que obtengan un nuevo bot√≥n llamado &quot;git()&quot; usethis::use_git() Nuevo bot√≥n: button_git Ahora que tienen el bot√≥n Git, hagan click y en la esquina derecha habr√° un s√≠mbolo con dos rect√°ngulos morados y un rombo blanco, denle click. button_branch Ahora el bot√≥n Add Remote y ah√≠ podr√°n nombrar este acceso remoto como gusten, y agregar la URL de su repositorio en github. Da click en Add y despu√©s asignen el nombre de rama master Ahora pueden crear la rama, y sobreescribir el acceso cuando se los pregunte. 2.4.2 Modificar y subir a github nuestro postcard Ya que hayan creado con cualquiera de las 2 opciones anteriores pueden continuar: Llenen su informaci√≥n usando el formato Markdown. Por ejemplo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L17-L31. Agreguen sus perfiles estilo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L7-L12 Den click en el bot√≥n azul de knit en RStudio. Es equivalente a rmarkdown::render(\"index.Rmd\"). Esto crear√° el archivo index.html. Hagan un commit para guardar los archivos nuevos incluyendo index.html y luego un push para subir los archivos a GitHub con alguna de las siguientes dos maneras: (opci√≥n 1) Bot√≥n de Git * Para guardar los archivos nuevos, incluyendo index.html, debemos hacer un commit. Podemos hacerlo con el nuevo bot√≥n de git, primero seleccionando los archivos: add_file Cuando hayamos seleccionado todos los archivos, veremos que la columna Status cambia a una ‚ÄúA‚Äù de agregado o added y podemos darle al bot√≥n Commit justo arriba de Status. Esto abrir√° una nueva pesta√±a donde podremos poner un mensaje sobre nuestro commit y despu√©s darle al bot√≥n Commit. button_git Una vez terminado, en esa misma pantalla podemos darle un push para subir los archivos a GitHub con el bot√≥n de Push con una flecha verde arriba de Commit message. (opcion 2) L√≠nea de comandos Otra manera de hacer es v√≠a l√≠nea de comandos, primero pueden agregar los archivos con gert::git_add() o hacer directamente un commit de todos los archivos y luego un pull: ## Guardamos los archivos nuevos con el commit gert::git_commit_all(&quot;mensaje sobre el commit&quot;) ## Subimos los archivos a github gert::git_push() (extra) . Pueden copiar y pegar emojis en sus p√°ginas o utilizar fontawesome para agregar diferentes s√≠mbolos (como github o twitter): En c√≥digo YAML # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en c√≥digo YAML y_fawesome Se ve as√≠: fawesome En el texto # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en el texto tfawesome (opcional). Anuncien su nueva p√°gina web en Twitter usando el hashtag #rstats y/o etiquen al autor de postcards https://twitter.com/seankross. Pueden despu√©s incluir su p√°gina web en su introducci√≥n en el canal #bienvenida del Slack de la CDSB ^^. Recuerden subir sus repositorios al Google Sheet Ac√° podemos ver varias de las p√°ginas web que hicieron lxs participantes del taller. En el taller de #scRNAseq aprendimos a usar #postcards de @seankross y #usethis de @JennyBryan @jimhester_ et al para hacer p√°ginas web‚ú®El objetivo: aumentar la presencia de Latinxs en la red üåêInstructoras ü¶Ü: Elisa @naielisha y @argininaa #rstatsEShttps://t.co/O6AoxRqp6o pic.twitter.com/rGWb1l38hk ‚Äî ComunidadBioInfo (@CDSBMexico) August 13, 2021 2.5 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:15:47 UTC&quot; proc.time() ## user system elapsed ## 0.544 0.141 0.570 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducci√≥n-a-rna-seq-de-c√©lula-√∫nica-scrna-seq-con-bioconductor-y-al-libro-de-osca.html", "3 Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA 3.1 Bioconductor 3.2 Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA 3.3 Detalles de la sesi√≥n de R Patrocinadores", " 3 Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA Instructoras: Elisa M√°rquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres y de Original Notes in English 3.1 Bioconductor CRAN, the R package repository: https://cran.r-project.org/ CRAN task views: https://cran.r-project.org/web/views/ ‚ÄúBioconductor proporciona herramientas para el an√°lisis y la comprensi√≥n de datos gen√≥micos de alto rendimiento. Bioconductor utiliza el lenguaje de programaci√≥n estad√≠stico R y es de c√≥digo abierto y desarrollo abierto. Tiene dos lanzamientos cada a√±o y una comunidad de usuarios activa. Bioconductor tambi√©n est√° disponible como AMI (Imagen de m√°quina de Amazon) e im√°genes de Docker.‚Äù https://www.bioconductor.org/ Where do I start using Bioconductor? http://lcolladotor.github.io/2014/10/16/startbioc/#.XqxNGRNKiuo B√°sicamente es un repositorio con reglas o est√°ndares para el an√°lisis y la comprensi√≥n de datos gen√≥micos de alto rendimiento. Para conocer sobre Bioconductor podemos ir a: https://www.bioconductor.org/ y dar click en About 3.1.1 Equipos y consejos Es conformado por diversos equipos y consejos (Asesores cient√≠ficos, t√©cnicos y de la comunidad). Por ejemplo Leonardo Collado. Cient√≠ficos : Proporciona orientaci√≥n externa y supervisi√≥n de la direcci√≥n cient√≠fica del proyecto y est√° compuesto por l√≠deres en el an√°lisis estad√≠stico de datos gen√≥micos. T√©cnicos: Desarrollar estrategias para asegurar que la parte t√©cnica de la infraestructura sea apropiada a largo plazo (manejo de paquetes, sitio web, slack, etc) Comunidad : Empoderar a las comunidades de usuarios y desarrolladores mediante la coordinaci√≥n de actividades de capacitaci√≥n y divulgaci√≥n. Dentro del equipo core que mantiene a Bioconductor y apoya con las dudas (https://www.bioconductor.org/about/core-team/) hay gente a la que Bioconductor le paga por mantener los repositorios, lo cual lo hace diferente de CRAN. El tener gente que oficialmente sabe c√≥mo ayudarte y tiene el tiempo para hacerlo crea una mejor experiencia para los usuarios y los desarrolladores. 3.1.2 Encontrando paquetes de Bioconductor Tipos de paquetes Hay 4 tipos de paquetes que aceptan Software: tipo principal de paquete BioC, en su mayor√≠a aportado por el usuario. Es un paquete con un tipo de an√°lisis espec√≠fico. Algunos los hacen gente pagada directamente por Bioconductor Annotation: facilita la interacci√≥n con bases de datos gen√≥micas muy utilizadas Experiment: contienen datos para alg√∫n art√≠culo o datos que se usan en ejemplos m√°s exhaustivos, en su mayor√≠a aportados por el usuario. ~&lt;5 Mb Workflows: demuestran como puedes usar varios paquetes de Bioconductor para ciertos tipos de an√°lisis Para descubrir paquetes: Software: http://bioconductor.org/packages/release/bioc/ Annotation: http://bioconductor.org/packages/release/data/annotation/ Experiment Data: http://bioconductor.org/packages/release/data/experiment/ Workflows: http://bioconductor.org/packages/release/workflows/ Las listas de cada tipo de paquete se ven algo as√≠: Package Maintainer Title Nombre del paquete Qui√©n lo mantiene T√≠tulo completo recount3 Leonardo Collado-Torres Explore and download data from the recount3 project Paquetes de R de Leo: https://lcolladotor.github.io/pkgs/ Sin embargo, estas listas no son muy amigables si queremos explorar por lo que podemos usar biocViews Encontrando paquetes a trav√©s de biocViews: http://bioconductor.org/packages/release/BiocViews.html#___Software Estructura tipo √°rbol Son 4 √°rboles principales: software, annotation, experiment, workflow Dentro de cada √°rbol, un paquete puede ser parte de varias ramas, por ejemplo, recount3 est√° dentro de todas estas ramas: Software AssayDomain GeneExpression BiologicalQuestion DifferentialExpression Coverage Infrastructure DataImport Technology Sequencing RNASeq Tiene una b√∫squeda de texto simple Ejemplo: Software ‚Üí WorkflowStep ‚Üí Visualization ‚Üí http://bioconductor.org/packages/release/BiocViews.html#___Visualization (486 paquetes en BioC 3.11 abril-octubre 2020, 506 en BioC 3.12 octubre 2020-abril 2021, 529 en BioC 3.13 agosto 2021) 3.1.3 Estructura de un paquete de BioC Usa https://bioconductor.org/packages/&lt;pkg_name&gt; Ejemplo: https://bioconductor.org/packages/recount Otro ejemplo: https://bioconductor.org/packages/SummarizedExperiment Badges (etiquetas): r√°pidamente podemos evaluar como est√° : ¬øEn qu√© plataformas funciona? : ¬øQu√© tan descargado es? : ¬øSe han hecho preguntas del paquete en los √∫ltimos 6 meses? (respondidas/hechas) : ¬øCu√°nto tiempo lleva en Bioconductor? : ¬øFunciona en las m√°quinas de bioconductor? : ¬øCu√°ndo fue la √∫ltima vez que lo actualizaron? : N√∫mero de dependencias recursivas necesarias para instalar el paquete Parr√°fo de descripci√≥n del paquete C√≥mo citar al paquete de Bioconductor C√≥mo instalarlo. M√°s detalles en http://bioconductor.org/install/ Documentaci√≥n Una l√≠ga por cada vignette en formato PDF o HTML. Es la documentaci√≥n principal! Una vignette es donde lxs autores del paquete explican c√≥mo usar las diferentes funciones del paquete y en qu√© orden Detalles T√©rminos de biocViews C√≥mo se relaciona a otros paquetes (depends, imports, linking to, suggests, depends on me, ‚Ä¶) URL: donde puedes encontrar el c√≥digo fuente (nos puede dar m√°s infor) BugReports: donde puedes pedir ayuda M√°s detalles sobre el paquete Estad√≠sticas de descargas 3.1.4 Las dos ramas de Bioconductor: release y devel Dos ramas release, actualmente 3.13 devel, actualmente 3.14 Bioconductor version 3.14 (Development) https://bioconductor.org/packages/devel/BiocViews.html#___Software Ejemplo: http://bioconductor.org/packages/devel/bioc/html/recount.html Bioconductor tiene es actualizado cada 6 meses (abril y octubre). R lo actualizan 1 vez al a√±o (abril). Todo el software lo prueban en macOS, Windows y linux Ejemplo: http://bioconductor.org/checkResults/release/bioc-LATEST/recount/ y http://bioconductor.org/checkResults/devel/bioc-LATEST/recount/ Resumen BioC 3.13 http://bioconductor.org/news/bioc_3_13_release/ Blog post en LIBD rstats club: Quick overview on the new Bioconductor 3.8 release http://research.libd.org/rstatsclub/2018/11/02/quick-overview-on-the-new-bioconductor-3-8-release/ 3.1.5 Cursos y eventos http://bioconductor.org/help/events/ http://bioconductor.org/help/course-materials/ BioC2021: conferencia principal anual https://bioc2021.bioconductor.org/ Talleres del BioC2019: https://rebrand.ly/biocworkshops2019 Teach online data science, bioinformatics, or other computational skills interactively using the Orchestra platform:https://t.co/r4aJ2xAZbh Nearly 50 workshop environments preloaded with #jupyter, #rstudio, #shell. #rstats, or #python.@NIHSTRIDES @NIHDataScience @Bioconductor pic.twitter.com/HyWVLBJxGU ‚Äî Sean Davis (@seandavis12) January 10, 2021 Talleres de la CDSB, como los talleres de CDSB 2020: https://comunidadbioinfo.github.io/post/cdsb2020-building-workflows-with-rstudio-and-scrnaseq-with-bioconductor/#.XmJT-Z-YU1I 3.1.6 Comunidad Slack: https://bioc-community.herokuapp.com/ Sitio web de ayuda: https://support.bioconductor.org/ Usa la(s) etiqueta(s) adecuada(s) para que lxs autores de los paquetes reciban email de forma autom√°tica Pueden revisar ese sitio web y usarlo para aprender c√≥mo en https://lcolladotor.github.io/bioc_team_ds/helping-others.html#bioconductor-support-practice-grounds Twitter: https://twitter.com/bioconductor 3.2 Introducci√≥n a RNA-seq de c√©lula √∫nica (scRNA-seq) con Bioconductor y al libro de OSCA link a diapositivas 3.3 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:15:48 UTC&quot; proc.time() ## user system elapsed ## 0.395 0.118 0.399 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["estructura-e-importe-de-datos.html", "4 Estructura e importe de datos 4.1 Preprocesamiento de datos 4.2 Estructura de SingleCellExperiment 4.3 Ejercicio 1 4.4 Breve repaso de R 4.5 Ejercicio 2 4.6 Import data 4.7 Detalles de la sesi√≥n de R Patrocinadores", " 4 Estructura e importe de datos Instructoras: Elisa M√°rquez Zavala, Citlali Gil Aguillon. Contenido adaptado de CDSB2020: Introducci√≥n a scRNA-seq, estructura e importe de datos de Leonardo Collado Torres. 4.1 Preprocesamiento de datos 4.1.1 Cell Ranger cellranger es un pipeline que provee 10x Genomics para procesar datos de scRNA-seq generados con la tecnolog√≠a de Chromium de 10x Genomics cellranger count procesa los datos crudos de FASTQ y genera los archivos que podemos leer en R usando DropletUtils::read10xCounts(). 4.1.2 scPipe scPipe es otro pipeline para procesar datos crudos (en formato FASTQ) de tecnolog√≠as de scRNA-seq. Funciona para varias tecnolog√≠as y usa Rsubread para el paso de alineamiento. we developed scPipe, an R/Bioconductor package that integrates barcode demultiplexing, read alignment, UMI-aware gene-level quantification and quality control of raw sequencing data generated by multiple protocols that include CEL-seq, MARS-seq, Chromium 10X, Drop-seq and Smart-seq. Fuente: Tian et al, PLoS Comput Biol., 2018. 4.1.3 Etc Hay muchos pipelines para procesar datos de scRNA-seq, porque a diferencia de bulk RNA-seq, en scRNA-seq hay muchas tecnolog√≠as en el mercado. Aunque tal vez la m√°s com√∫n es la de 10x Genomics Chromium. 4.2 Estructura de SingleCellExperiment Dentro del curso -y m√°s ampliamente dentro de los an√°lisis de scRNA-seq en R- emplearemos la clase SingleCellExperiment . Adem√°s recordemos que la interoperabilidad dentro de los paquetes de Bioconductor har√° que facilmente puedas ajustarte m√°s facilmente a otros paquetes que vayamos encontrando √∫tiles (la infraestructura de los dato nos seguir√° sirviendo!). Podr√≠amos dividir esta clase en cuatro categorias: datos primarios y transformados (donde estaran lo) metadata de datos (informaci√≥n de los genes o features, de las c√©lulas y del experimento) reduccion de dimensiones experimentos alternativos Todo lo anterior est√° ligado, por lo que hace m√°s sencillo el manejo de subsets de inter√©s por ejemplo si nos interesa los genes x,y,z podr√≠amos solicitarlos y con ello traer la informaci√≥n de las dem√°s tablas Examinaremos cada una de estas partes a detalle Usaremos las diapositivas de Peter Hickey para explicar la clase SingleCellExperiment en las siguientes diapositivas. A la par se demostrar√° el siguiente c√≥digo. 4.3 Ejercicio 1 The A. T. L. Lun et al.¬†(2017) dataset contains two 96-well plates of 416B cells (an immortalized mouse myeloid progenitor cell line), processed using the Smart-seq2 protocol (Picelli et al.¬†2014). A constant amount of spike-in RNA from the External RNA Controls Consortium (ERCC) was also added to each cell‚Äôs lysate prior to library preparation. High-throughput sequencing was performed and the expression of each gene was quantified by counting the total number of reads mapped to its exonic regions. Similarly, the quantity of each spike-in transcript was measured by counting the number of reads mapped to the spike-in reference sequences. Fragmento obtenido de https://bioconductor.org/books/release/OSCA/lun-416b-cell-line-smart-seq2.html library(&quot;scRNAseq&quot;) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) # Carga el paquete SingleCellExperiment library(&quot;SingleCellExperiment&quot;) &quot;Primera parte aqu√≠ checamos el slot assays&quot; ## [1] &quot;Primera parte\\naqu√≠ checamos el slot assays&quot; # Extrae la matriz de cuentas del set de datos de 416b counts.416b &lt;- counts(sce.416b) # CHEQUEMOS clase y dimensiones class(counts.416b) # es matriz ## [1] &quot;matrix&quot; &quot;array&quot; dim(counts.416b) # indicar√° genes y c√©lulas ## [1] 46604 192 # CONSTRUIR un nuevo objeto SCE de la matriz de cuentas !!!!!! sce &lt;- SingleCellExperiment(assays = list(counts = counts.416b)) # Revisa el objeto que acabamos de crear sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(1): counts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(0): ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 38.26031 B # Accesa la matriz de cuenta del compartimento (slot) &quot;assays&quot; # assays(sce, &quot;counts&quot;) # OJO: ¬°esto puede inundar tu sesi√≥n de R! # 1. El m√©todo general assay(sce, &quot;counts&quot;)[110:115, 1:3] # gene, cell ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 8 ## ENSMUSG00000046334 2 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 63 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 0 ## ENSMUSG00000046334 3 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 21 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 19 ## ENSMUSG00000025915 1 ## ENSMUSG00000046334 15 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 17 # 2. El m√©todo espec√≠fico para accesar la matriz de cuentas &quot;counts&quot; counts(sce)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 8 ## ENSMUSG00000046334 2 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 63 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0 ## ENSMUSG00000025915 0 ## ENSMUSG00000046334 3 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 21 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 19 ## ENSMUSG00000025915 1 ## ENSMUSG00000046334 15 ## ENSMUSG00000088916 0 ## ENSMUSG00000046101 0 ## ENSMUSG00000098234 17 # AGREGAR MAS ASSAYS sce &lt;- scater::logNormCounts(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(1): sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 106.5302 B # 1. El m√©todo general assay(sce, &quot;logcounts&quot;)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 3.557154 ## ENSMUSG00000046334 1.884687 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 6.423258 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 0.000000 ## ENSMUSG00000046334 2.087367 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 4.569735 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 4.3052563 ## ENSMUSG00000025915 0.9912494 ## ENSMUSG00000046334 3.9835488 ## ENSMUSG00000088916 0.0000000 ## ENSMUSG00000046101 0.0000000 ## ENSMUSG00000098234 4.1533513 # 2. El m√©todo espec√≠fico para accesar la matriz de cuentas # transformadas &quot;logcounts&quot; logcounts(sce)[110:115, 1:3] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 3.557154 ## ENSMUSG00000046334 1.884687 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 6.423258 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 0.000000 ## ENSMUSG00000025915 0.000000 ## ENSMUSG00000046334 2.087367 ## ENSMUSG00000088916 0.000000 ## ENSMUSG00000046101 0.000000 ## ENSMUSG00000098234 4.569735 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ## ENSMUSG00000097893 4.3052563 ## ENSMUSG00000025915 0.9912494 ## ENSMUSG00000046334 3.9835488 ## ENSMUSG00000088916 0.0000000 ## ENSMUSG00000046101 0.0000000 ## ENSMUSG00000098234 4.1533513 # agregemos un assay mas, esta vez de manera manual assay(sce, &quot;counts_100&quot;) &lt;- assay(sce, &quot;counts&quot;) + 100 # suma 100 a counts assay # Enumera los &quot;assays&quot; en el objeto assays(sce) # indica num y nombre de assays ## List of length 3 ## names(3): counts logcounts counts_100 assayNames(sce) # solo nos dar√° los nombres de los assays ## [1] &quot;counts&quot; &quot;logcounts&quot; &quot;counts_100&quot; # assay(sce, &quot;counts_100&quot;)[110:115, 1:3] ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 174.7981 B &quot;segunda parte: aqu√≠ checaremos metadata de las c√©lulas&quot; ## [1] &quot;segunda parte:\\naqu√≠ checaremos metadata de las c√©lulas&quot; # Extrae la informaci√≥n de las muestras (metadata) del set de datos de 416b colData.416b &lt;- colData(sce.416b) # podemos checar objeto en la cajita de environment de RStudio!! # explorar datooos table(colData.416b$phenotype) ## ## induced CBFB-MYH11 oncogene expression wild type phenotype ## 96 96 table(colData.416b$block) # fue en varios dias? ## ## 20160113 20160325 ## 96 96 # Agrega algo de esa informaci√≥n a nuestro objeto de SCE colData(sce) &lt;- colData.416b[, c(&quot;phenotype&quot;, &quot;block&quot;)] # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(3): counts logcounts counts_100 ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(0): ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(2): phenotype block ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): # Accesa a la informaci√≥n de las muestras (metadata) en nuestro SCE colData(sce) # usar head? ## DataFrame with 192 rows and 2 columns ## phenotype block ## &lt;character&gt; &lt;integer&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 wild type phenotype 20160113 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. 20160113 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. 20160113 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. 20160325 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 wild type phenotype 20160325 # Accesa una columna espec√≠fica de la informaci√≥n de las muestras (metadata) table(sce$block) ## ## 20160113 20160325 ## 96 96 table(colData(sce)$block) # otra manera ## ## 20160113 20160325 ## 96 96 # Ejemplo de una funci√≥n que agrega columnas nuevas al colData sce &lt;- scater::addPerCellQC(sce.416b) # a√±ade datos de control de calidad # Accesa a la informaci√≥n de las muestras (metadata) en nuestro SCE actualizado colData(sce) ## DataFrame with 192 rows and 18 columns ## Source Name cell line ## &lt;character&gt; &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S502.C.. 416B ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C.. 416B ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S504.C.. 416B ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C.. 416B ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S506.C.. 416B ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S505... 416B ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S506... 416B ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S507... 416B ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S508... 416B ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 SLX-11312.N712_S517... 416B ## cell type ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 embryonic stem cell ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 embryonic stem cell ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 embryonic stem cell ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 embryonic stem cell ## single cell well quality ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 OK ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 OK ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 OK ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 OK ## genotype ## &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 Doxycycline-inducibl.. ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 Doxycycline-inducibl.. ## phenotype strain ## &lt;character&gt; &lt;character&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 wild type phenotype B6D2F1-J ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 induced CBFB-MYH11 o.. B6D2F1-J ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 wild type phenotype B6D2F1-J ## spike-in addition block sum ## &lt;character&gt; &lt;integer&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 865936 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1076277 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1180138 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1342593 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 ERCC+SIRV 20160113 1668311 ## ... ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 Premixed 20160325 776622 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 Premixed 20160325 1299950 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 Premixed 20160325 1800696 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 Premixed 20160325 46731 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 Premixed 20160325 1866692 ## detected altexps_ERCC_sum ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 7618 65278 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 7521 74748 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 8306 60878 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 8143 60073 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7154 136810 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 8174 61575 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 8956 94982 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 9530 113707 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 6649 7580 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 10964 48664 ## altexps_ERCC_detected ## &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 39 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 40 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 42 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 42 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 44 ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 39 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 41 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 40 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 44 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 39 ## altexps_ERCC_percent altexps_SIRV_sum ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 6.80658 27828 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 6.28030 39173 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 4.78949 30058 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 4.18567 32542 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7.28887 71850 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 7.17620 19848 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 6.65764 31729 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 5.81467 41116 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 13.48898 1883 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 2.51930 16289 ## altexps_SIRV_detected ## &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 7 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 7 ## ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 7 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 7 ## altexps_SIRV_percent total ## &lt;numeric&gt; &lt;numeric&gt; ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 2.90165 959042 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 3.29130 1190198 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 2.36477 1271074 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 2.26741 1435208 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 3.82798 1876971 ## ... ... ... ## SLX-11312.N712_S505.H5H5YBBXX.s_8.r_1 2.313165 858045 ## SLX-11312.N712_S506.H5H5YBBXX.s_8.r_1 2.224004 1426661 ## SLX-11312.N712_S507.H5H5YBBXX.s_8.r_1 2.102562 1955519 ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 3.350892 56194 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 0.843271 1931645 # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(0): ## assays(1): counts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(18): Source Name cell line ... altexps_SIRV_percent total ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 39.47633 B ## Agrega las cuentas normalizadas (lognorm) de nuevo sce &lt;- scater::logNormCounts(sce) ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 107.7463 B # Ejemplo: obt√©n el subconjunto de c√©lulas de fenotipo &quot;wild type&quot; # Acu√©rdate que las c√©lulas son columnas del SCE !!!! sce[, sce$phenotype == &quot;wild type phenotype&quot;] ## class: SingleCellExperiment ## dim: 46604 96 ## metadata(0): ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(96): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S504.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV &quot;Tercera parte: examinaremos metadata de features (rowData)&quot; ## [1] &quot;Tercera parte:\\nexaminaremos metadata de features (rowData)&quot; # Accesa la informaci√≥n de los genes de nuestro SCE # ¬°Est√° vaci√≥ actualmente! rowData(sce) ## DataFrame with 46604 rows and 1 column ## Length ## &lt;integer&gt; ## ENSMUSG00000102693 1070 ## ENSMUSG00000064842 110 ## ENSMUSG00000051951 6094 ## ENSMUSG00000102851 480 ## ENSMUSG00000103377 2819 ## ... ... ## ENSMUSG00000094621 121 ## ENSMUSG00000098647 99 ## ENSMUSG00000096730 3077 ## ENSMUSG00000095742 243 ## CBFB-MYH11-mcherry 2998 # Ejemplo de una funci√≥n que agrega campos nuevos en el rowData sce &lt;- scater::addPerFeatureQC(sce) # Accesa a la informaci√≥n de las muestras (metadata) en nuestro SCE actualizado rowData(sce) ## DataFrame with 46604 rows and 3 columns ## Length mean detected ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSMUSG00000102693 1070 0.0000000 0.000000 ## ENSMUSG00000064842 110 0.0000000 0.000000 ## ENSMUSG00000051951 6094 0.0000000 0.000000 ## ENSMUSG00000102851 480 0.0000000 0.000000 ## ENSMUSG00000103377 2819 0.0104167 0.520833 ## ... ... ... ... ## ENSMUSG00000094621 121 0.0 0 ## ENSMUSG00000098647 99 0.0 0 ## ENSMUSG00000096730 3077 0.0 0 ## ENSMUSG00000095742 243 0.0 0 ## CBFB-MYH11-mcherry 2998 50375.7 100 ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.4578 B # Descarga los archivos de anotaci√≥n de la base de datos de Ensembl # correspondientes usando los recursos disponibles v√≠a AnnotationHub library(&quot;AnnotationHub&quot;) ah &lt;- AnnotationHub() query(ah, c(&quot;Mus musculus&quot;, &quot;Ensembl&quot;, &quot;v97&quot;)) ## AnnotationHub with 1 record ## # snapshotDate(): 2021-05-18 ## # names(): AH73905 ## # $dataprovider: Ensembl ## # $species: Mus musculus ## # $rdataclass: EnsDb ## # $rdatadateadded: 2019-05-02 ## # $title: Ensembl 97 EnsDb for Mus musculus ## # $description: Gene and protein annotations for Mus musculus based on Ensem... ## # $taxonomyid: 10090 ## # $genome: GRCm38 ## # $sourcetype: ensembl ## # $sourceurl: http://www.ensembl.org ## # $sourcesize: NA ## # $tags: c(&quot;97&quot;, &quot;AHEnsDbs&quot;, &quot;Annotation&quot;, &quot;EnsDb&quot;, &quot;Ensembl&quot;, &quot;Gene&quot;, ## # &quot;Protein&quot;, &quot;Transcript&quot;) ## # retrieve record with &#39;object[[&quot;AH73905&quot;]]&#39; # Obt√©n la posici√≥n del cromosoma para cada gen ensdb &lt;- ah[[&quot;AH73905&quot;]] chromosome &lt;- mapIds(ensdb, keys = rownames(sce), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) rowData(sce)$chromosome &lt;- chromosome # Accesa a la informaci√≥n de las muestras (metadata) en nuestro SCE actualizado rowData(sce) ## DataFrame with 46604 rows and 4 columns ## Length mean detected chromosome ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;character&gt; ## ENSMUSG00000102693 1070 0.0000000 0.000000 1 ## ENSMUSG00000064842 110 0.0000000 0.000000 1 ## ENSMUSG00000051951 6094 0.0000000 0.000000 1 ## ENSMUSG00000102851 480 0.0000000 0.000000 1 ## ENSMUSG00000103377 2819 0.0104167 0.520833 1 ## ... ... ... ... ... ## ENSMUSG00000094621 121 0.0 0 GL456372.1 ## ENSMUSG00000098647 99 0.0 0 GL456381.1 ## ENSMUSG00000096730 3077 0.0 0 JH584292.1 ## ENSMUSG00000095742 243 0.0 0 JH584295.1 ## CBFB-MYH11-mcherry 2998 50375.7 100 NA ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.8135 B # Ejemplo: obt√©n el subconjunto de datos donde los genes est√°n en el # cromosoma 3 # NOTA: which() fue necesario para lidear con los nombres de cromosoma # que son NA sce[which(rowData(sce)$chromosome == &quot;3&quot;), ] ## class: SingleCellExperiment ## dim: 2876 192 ## metadata(0): ## assays(2): counts logcounts ## rownames(2876): ENSMUSG00000098982 ENSMUSG00000098307 ... ## ENSMUSG00000105990 ENSMUSG00000075903 ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV &quot;Cuarta parte: examinamos slot metadata&quot; ## [1] &quot;Cuarta parte:\\nexaminamos slot metadata&quot; # Accesa la informaci√≥n de nuestro experimento usando metadata() # ¬°Est√° vaci√≥ actualmente! metadata(sce) ## list() # La informaci√≥n en el metadata() es como Vegas - todo se vale metadata(sce) &lt;- list( favourite_genes = c(&quot;Shh&quot;, &quot;Nck1&quot;, &quot;Diablo&quot;), analyst = c(&quot;Pete&quot;) ) # Accesa la informaci√≥n de nuestro experimento usando metadata() de # nuestro objeto actualizado metadata(sce) ## $favourite_genes ## [1] &quot;Shh&quot; &quot;Nck1&quot; &quot;Diablo&quot; ## ## $analyst ## [1] &quot;Pete&quot; &quot;Quinta parte: examinamos slot de reducci√≥n de dimensiones&quot; ## [1] &quot;Quinta parte:\\nexaminamos slot de reducci√≥n de dimensiones&quot; # Ejemplo: agrega los componentes principales (PCs) de las logcounts # NOTA: aprenderemos m√°s sobre an√°lisis de componentes principales (PCA) despu√©s sce &lt;- scater::runPCA(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(1): PCA ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV # Accesa la matriz de PCA del componente (slot) reducedDims reducedDim(sce, &quot;PCA&quot;)[1:6, 1:3] ## PC1 PC2 PC3 ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -18.717668 27.598132 -5.939654 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -2.480705 27.564583 -4.916567 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -42.034018 7.552435 -12.126964 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 8.494303 -31.833727 -15.760853 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 49.737390 -4.226795 -6.123169 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 44.528081 3.215503 -10.384939 # Ejemplo, agrega una representaci√≥n de los logcounts en t-SNE # NOTA: aprenderemos m√°s sobre t-SNE despu√©s sce &lt;- scater::runTSNE(sce) # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(2): PCA TSNE ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV # Accesa a la matriz de t-SNE en el componente (slot) de reducedDims head(reducedDim(sce, &quot;TSNE&quot;)) ## [,1] [,2] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -7.3181642 2.2840490 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -3.6464118 -0.8207964 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -7.6479076 4.6719923 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 0.7775377 4.4127326 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 8.0179911 -6.4277429 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 7.8965473 -7.8963465 # Ejemplo: agrega una representaci√≥n &#39;manual&#39; de los logcounts en UMAP # NOTA: aprenderemos m√°s sobre UMAP despu√©s y de una forma m√°s sencilla de # calcularla u &lt;- uwot::umap(t(logcounts(sce)), n_components = 2) # Agrega la matriz de UMAP al componente (slot) reducedDims reducedDim(sce, &quot;UMAP&quot;) &lt;- u # Accesa a la matriz de UMAP desde el componente (slot) reducedDims head(reducedDim(sce, &quot;UMAP&quot;)) ## [,1] [,2] ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 -2.9007656 -1.724959 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 -1.9364034 -1.711854 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 -3.2449543 -1.109732 ## SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 -0.3859376 -1.198746 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 0.2112636 -1.497831 ## SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 -0.1741835 -1.455346 # Enumera los resultados de reducci√≥n de dimensiones en nuestro objeto SCE reducedDims(sce) ## List of length 3 ## names(3): PCA TSNE UMAP &quot;Sexta parte: experimentos alternativos&quot; ## [1] &quot;Sexta parte:\\nexperimentos alternativos&quot; # Extrae la informaci√≥n de ERCC de nuestro SCE para el set de datos de 416b ercc.sce.416b &lt;- altExp(sce.416b, &quot;ERCC&quot;) # Inspecciona el SCE para los datos de ERCC ercc.sce.416b ## class: SingleCellExperiment ## dim: 92 192 ## metadata(0): ## assays(1): counts ## rownames(92): ERCC-00002 ERCC-00003 ... ERCC-00170 ERCC-00171 ## rowData names(7): Length subgroup ... log2(Mix 1/Mix 2) molecules ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(0): ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): # Agrega el SCE de ERCC como un experimento alternativo a nuestro SCE altExp(sce, &quot;ERCC&quot;) &lt;- ercc.sce.416b # Revisa el objeto que acabamos de actualizar sce ## class: SingleCellExperiment ## dim: 46604 192 ## metadata(2): favourite_genes analyst ## assays(2): counts logcounts ## rownames(46604): ENSMUSG00000102693 ENSMUSG00000064842 ... ## ENSMUSG00000095742 CBFB-MYH11-mcherry ## rowData names(4): Length mean detected chromosome ## colnames(192): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-11312.N712_S508.H5H5YBBXX.s_8.r_1 ## SLX-11312.N712_S517.H5H5YBBXX.s_8.r_1 ## colData names(19): Source Name cell line ... total sizeFactor ## reducedDimNames(3): PCA TSNE UMAP ## mainExpName: endogenous ## altExpNames(2): ERCC SIRV ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce) / 1024^2 ## En MB ## 108.8965 B # Enumera los experimentos alternativos almacenados en nuestro objeto altExps(sce) ## List of length 2 ## names(2): ERCC SIRV # El crear un subconjunto del SCE por muestra (c√©lula) autom√°ticamente # obtiene el subconjunto de los experimentos alternativos sce.subset &lt;- sce[, 1:10] ncol(sce.subset) ## [1] 10 ncol(altExp(sce.subset)) ## [1] 10 ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce.subset) / 1024^2 ## En MB ## 11.99544 B &quot;Septima parte: sizefactores&quot; ## [1] &quot;Septima parte:\\nsizefactores&quot; # Extrae los factores de tama√±o (size factors) # Estos fueron a√±adidos a nuestro objeto cuando corrimos # scater::logNormCounts(sce) head(sizeFactors(sce)) ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## 0.7427411 0.9231573 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ## 1.0122422 1.1515851 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 ## 1.4309639 0.8713409 # &quot;Autom√°ticamente&quot; reemplaza los factores de tama√±o sce &lt;- scran::computeSumFactors(sce) head(sizeFactors(sce)) ## [1] 0.6961756 0.8834223 0.9704247 0.9804890 1.2446699 0.7922620 # &quot;Manualmente&quot; reemplaza los factores de tama√±o sizeFactors(sce) &lt;- scater::librarySizeFactors(sce) head(sizeFactors(sce)) ## SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ## 0.7427411 0.9231573 ## SLX-9555.N701_S504.C89V9ANXX.s_1.r_1 SLX-9555.N701_S505.C89V9ANXX.s_1.r_1 ## 1.0122422 1.1515851 ## SLX-9555.N701_S506.C89V9ANXX.s_1.r_1 SLX-9555.N701_S507.C89V9ANXX.s_1.r_1 ## 1.4309639 0.8713409 NOTA: La clase SingleCellExperimentest√° basada en SummarizedExperiment, por lo que ya estamos un poco familiarizados con esta nueva clase. Una de las diferencias es que no contiene ranuras para an√°lisis de reducci√≥n de dimensiones. (ser√° solo datos y metadata de ellos) 4.3.1 Preguntas: ¬øCu√°les son los tipos de tablas que debe siempre contenter el objeto sce? ¬øDonde usamos los colnames(sce)? ¬ødonde usamos los rownames(sce)? 4.4 Breve repaso de R # Creamos un data.frame df &lt;- data.frame(x = c(TRUE, FALSE, NA, NA), y = c(12, 34, 56, 78)) row.names(df) &lt;- letters[1:4] df ## x y ## a TRUE 12 ## b FALSE 34 ## c NA 56 ## d NA 78 # Para acceder a los nombres de las columnas colnames(df) ## [1] &quot;x&quot; &quot;y&quot; # Para acceder a los nombres de las filas rownames(df) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; # Podemos sacar informaci√≥n booleana df$y &lt; 20 ## [1] TRUE FALSE FALSE FALSE # Y podemos acceder al mismo data.frame con la informaci√≥n booleana df[df$y &lt; 40, ] ## x y ## a TRUE 12 ## b FALSE 34 ## %in% (dentro de) bool_info &lt;- rownames(df) %in% c(&quot;a&quot;, &quot;c&quot;, &quot;z&quot;) df[bool_info, ] ## x y ## a TRUE 12 ## c NA 56 ## &amp; (y) bool_info &lt;- df$y &lt; 50 &amp; df$y &gt; 20 df[bool_info, ] ## x y ## b FALSE 34 ## | (o) bool_info &lt;- df$y &lt; 20 | df$y &gt; 60 df[bool_info, ] ## x y ## a TRUE 12 ## d NA 78 4.5 Ejercicio 2 library(&quot;SingleCellExperiment&quot;) library(&quot;scRNAseq&quot;) # Mini muestreo del set de datos usado en: https://bioconductor.org/books/release/OSCA/zeisel-mouse-brain-strt-seq.html#introduction-5 archivo_cuentas &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/min_sce.csv&quot; archivo_rowData &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/rowD.csv&quot; archivo_colData &lt;- &quot;https://raw.githubusercontent.com/emarquezz/minidataset_osca/main/colD.csv&quot; counts &lt;- read.csv(archivo_cuentas, row.names = 1, header = TRUE, check.names = F) col.data &lt;- DataFrame(read.csv(archivo_colData, row.names = 1, header = TRUE, check.names = F)) row.data &lt;- read.csv(archivo_rowData, row.names = 1, header = TRUE, check.names = F) Crea un objeto SingleCellExperiment ¬øCu√°ntos genes tenemos? ¬øQu√© informaci√≥n tenemos en el rowData()? Extraigan los datos de los genes que nos interesan (objeto int_gen) Pasen el mouse sobre los siguientes textos para ver recomendaciones: Recomendaci√≥n 1 Recomendaci√≥n 2 Recomendaci√≥n 3 int_gen &lt;- c(&quot;Angpt1&quot;, &quot;Chic2&quot;, &quot;Mir503&quot;, &quot;Magee2&quot;, &quot;Nenf&quot;, &quot;Eps15l1&quot;, &quot;Hsf2bp&quot;, &quot;Gnptg&quot;, &quot;Vegfb&quot;, &quot;Atmin&quot;, &quot;Gad1&quot;, &quot;Gad2&quot;, &quot;Slc32a1&quot;, &quot;Dner&quot;, &quot;Slc2a13&quot;, &quot;Slc6a1&quot;, &quot;Nrxn3&quot;) Creen un objeto llamado min_sce con los datos de solo esos genes ¬øCu√°les son parte del tejido interneurons o del tejido pyramidal CA1 ? (del objeto min_sce) Recomendaci√≥n 1 Recomendaci√≥n 2 Recomendaci√≥n 3 Con este subconjunto, crea el objeto tej_min_sce Una vez que tengan el objeto ¬¥SingleCellExperiment¬¥ llamado ¬¥tej_min_sce¬¥, corran el siguiente c√≥digo. library(&quot;scater&quot;) plotHeatmap(object = tej_min_sce, features = rownames(tej_min_sce), order_columns_by = &quot;level1class&quot;) 4.5.1 Respuestas sce &lt;- SingleCellExperiment( assays = list(counts = counts), colData = col.data, rowData = row.data ) sce &lt;- scater::logNormCounts(sce) sce ## class: SingleCellExperiment ## dim: 100 30 ## metadata(0): ## assays(2): counts logcounts ## rownames(100): Olfr1219 Angpt1 ... Slc6a1 Nrxn3 ## rowData names(2): featureType Ensembl ## colnames(30): 1772066102_E02 1772067073_F10 ... 1772066096_G11 ## 1772066101_E11 ## colData names(11): tissue group.. ... level2class sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): bool_data &lt;- rownames(rowData(sce)) min_sce &lt;- sce[bool_data %in% int_gen, ] tej_int &lt;- min_sce$level1class == &quot;interneurons&quot; tej_pyr &lt;- min_sce$level1class == &quot;pyramidal CA1&quot; tej_min_sce &lt;- min_sce[, tej_int | tej_pyr] library(&quot;scater&quot;) ## Loading required package: scuttle ## Loading required package: ggplot2 plotHeatmap(object = tej_min_sce, features = rownames(tej_min_sce), order_columns_by = &quot;level1class&quot;) 4.5.2 Extra Realiza los mismos pasos, pero ahora los genes que buscamos no tienen el nombre usual de gen (Gad1), sino su Ensembl gene IDs int_gen &lt;- c(&quot;ENSMUSG00000071076&quot;, &quot;ENSMUSG00000002076&quot;, &quot;ENSMUSG00000024962&quot;, &quot;ENSMUSG00000031224&quot;, &quot;ENSMSG00000036560&quot;, &quot;ENSMUSG00000037499&quot;, &quot;ENSMUSG00000006276&quot;, &quot;ENSMUSG00000035521&quot;, &quot;ENSMUSG00000047388&quot;, &quot;ENSMUSG0000051079&quot;, &quot;ENSMUSG00000076122&quot;, &quot;ENSMUSG00000029229&quot;, &quot;ENSMUSG00000022309&quot;, &quot;ENSMUSG00000036766&quot;, &quot;ENSMUSG00000070880&quot;, &quot;ENSMUSG00000026787&quot;, &quot;ENSMUSG00000066392&quot;, &quot;ENSMUSG00000036298&quot;, &quot;ENSMUSG00000037771&quot;, &quot;ENSMUSG00000030310&quot;) 4.6 Import data Diapositivas de Peter Hickey Ve las diapositivas aqu√≠. # Descarga datos de ejemplo procesados con CellRanger # Par√©ntesis: al usar BiocFileCache solo tenemos que descargar # los datos una vez. library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() pbmc.url &lt;- paste0( &quot;http://cf.10xgenomics.com/samples/cell-vdj/&quot;, &quot;3.1.0/vdj_v1_hs_pbmc3/&quot;, &quot;vdj_v1_hs_pbmc3_filtered_feature_bc_matrix.tar.gz&quot; ) pbmc.data &lt;- bfcrpath(bfc, pbmc.url) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell-vdj/3.1.0/vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_filtered_feature_bc_matrix.tar.gz&#39; # Extrae los archivos en un directorio temporal untar(pbmc.data, exdir = tempdir()) # Enumera los archivos que descargamos y que extrajimos # Estos son los archivos t√≠picos de CellRanger pbmc.dir &lt;- file.path( tempdir(), &quot;filtered_feature_bc_matrix&quot; ) list.files(pbmc.dir) ## [1] &quot;barcodes.tsv.gz&quot; &quot;features.tsv.gz&quot; &quot;matrix.mtx.gz&quot; # Importa los datos como un objeto de tipo SingleCellExperiment library(&quot;DropletUtils&quot;) sce.pbmc &lt;- read10xCounts(pbmc.dir) # Revisa el objeto que acabamos de construir sce.pbmc ## class: SingleCellExperiment ## dim: 33555 7231 ## metadata(1): Samples ## assays(1): counts ## rownames(33555): ENSG00000243485 ENSG00000237613 ... CD127 CD15 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce.pbmc) / 1024^2 ## En MB ## 124.191 B # Almacena la informaci√≥n de CITE-seq como un experimento alternativo sce.pbmc &lt;- splitAltExps(sce.pbmc, rowData(sce.pbmc)$Type) # Revisa el objeto que acabamos de actualizar sce.pbmc ## class: SingleCellExperiment ## dim: 33538 7231 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: Gene Expression ## altExpNames(1): Antibody Capture ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce.pbmc) / 1024^2 ## En MB ## 124.4871 B # Descarga datos de ejemplo procesados con scPipe library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() sis_seq.url &lt;- &quot;https://github.com/LuyiTian/SIS-seq_script/archive/master.zip&quot; sis_seq.data &lt;- bfcrpath(bfc, sis_seq.url) ## adding rname &#39;https://github.com/LuyiTian/SIS-seq_script/archive/master.zip&#39; # Extrae los archivos en un directorio temporal unzip(sis_seq.data, exdir = tempdir()) # Enumera (algunos de) los archivos que descargamos y extrajimos # Estos son los archivos t√≠picos de scPipe sis_seq.dir &lt;- file.path( tempdir(), &quot;SIS-seq_script-master&quot;, &quot;data&quot;, &quot;BcorKO_scRNAseq&quot;, &quot;RPI10&quot; ) list.files(sis_seq.dir) ## [1] &quot;gene_count.csv&quot; &quot;stat&quot; # Importa los datos como un objeto de tipo SingleCellExperiment library(&quot;scPipe&quot;) ## ## ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 sce.sis_seq &lt;- create_sce_by_dir(sis_seq.dir) ## organism/gene_id_type not provided. Make a guess: mmusculus_gene_ensembl / ensembl_gene_id # Revisa el objeto que acabamos de construir sce.sis_seq ## class: SingleCellExperiment ## dim: 19232 383 ## metadata(2): scPipe Biomart ## assays(1): counts ## rownames(19232): ENSMUSG00000079140 ENSMUSG00000081587 ... ## ENSMUSG00000036880 ENSMUSG00000106872 ## rowData names(0): ## colnames(383): A1 A10 ... P8 P9 ## colData names(7): unaligned aligned_unmapped ... mapped_to_ERCC ## mapped_to_MT ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(sce.sis_seq) / 1024^2 ## En MB ## 29.84988 B # Descarga un ejemplo de un mont√≥n de archivos library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() lun_counts.url &lt;- paste0( &quot;https://www.ebi.ac.uk/arrayexpress/files/&quot;, &quot;E-MTAB-5522/E-MTAB-5522.processed.1.zip&quot; ) lun_counts.data &lt;- bfcrpath(bfc, lun_counts.url) ## adding rname &#39;https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-5522/E-MTAB-5522.processed.1.zip&#39; lun_coldata.url &lt;- paste0( &quot;https://www.ebi.ac.uk/arrayexpress/files/&quot;, &quot;E-MTAB-5522/E-MTAB-5522.sdrf.txt&quot; ) lun_coldata.data &lt;- bfcrpath(bfc, lun_coldata.url) ## adding rname &#39;https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-5522/E-MTAB-5522.sdrf.txt&#39; # Extrae los archivos en un directorio temporal lun_counts.dir &lt;- tempfile(&quot;lun_counts.&quot;) unzip(lun_counts.data, exdir = lun_counts.dir) # Enumera los archivos que descargamos y extrajimos list.files(lun_counts.dir) ## [1] &quot;counts_Calero_20160113.tsv&quot; &quot;counts_Calero_20160325.tsv&quot; ## [3] &quot;counts_Liora_20160906.tsv&quot; &quot;counts_Liora_20170201.tsv&quot; # Lee la matriz de cuentas (para una placa) lun.counts &lt;- read.delim( file.path(lun_counts.dir, &quot;counts_Calero_20160113.tsv&quot;), header = TRUE, row.names = 1, check.names = FALSE ) # Almacena la informaci√≥n de la longitud de los genes para despu√©s gene.lengths &lt;- lun.counts$Length # Convierte los datos de cuentas de genez a una matriz (quitamos las longitudes) lun.counts &lt;- as.matrix(lun.counts[, -1]) # Lee la informaci√≥n de las muestras (c√©lulas) lun.coldata &lt;- read.delim(lun_coldata.data, check.names = FALSE, stringsAsFactors = FALSE ) library(&quot;S4Vectors&quot;) lun.coldata &lt;- as(lun.coldata, &quot;DataFrame&quot;) # Pon en orden la informaci√≥n de las muestras para que # sea id√©ntico al orden en la matriz de cuentas m &lt;- match( colnames(lun.counts), lun.coldata$`Source Name` ) lun.coldata &lt;- lun.coldata[m, ] # Construye la tabla de informaci√≥n de los genes lun.rowdata &lt;- DataFrame(Length = gene.lengths) # Construye el objeto de SingleCellExperiment lun.sce &lt;- SingleCellExperiment( assays = list(assays = lun.counts), colData = lun.coldata, rowData = lun.rowdata ) # Revisa el objeto que acabamos de construir lun.sce ## class: SingleCellExperiment ## dim: 46703 96 ## metadata(0): ## assays(1): assays ## rownames(46703): ENSMUSG00000102693 ENSMUSG00000064842 ... SIRV7 ## CBFB-MYH11-mcherry ## rowData names(1): Length ## colnames(96): SLX-9555.N701_S502.C89V9ANXX.s_1.r_1 ## SLX-9555.N701_S503.C89V9ANXX.s_1.r_1 ... ## SLX-9555.N712_S508.C89V9ANXX.s_1.r_1 ## SLX-9555.N712_S517.C89V9ANXX.s_1.r_1 ## colData names(50): Source Name Comment[ENA_SAMPLE] ... Factor ## Value[phenotype] Factor Value[block] ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## ¬øQu√© tan grande es el objeto de R? lobstr::obj_size(lun.sce) / 1024^2 ## En MB ## 21.49744 B 4.7 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:17:33 UTC&quot; proc.time() ## user system elapsed ## 75.942 4.503 105.138 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scPipe * 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["control-de-calidad.html", "5 Control de calidad 5.1 Diapositivas de Peter Hickey 5.2 Ejercicio: entendiendo addPerCellQC 5.3 Gr√°ficas sobre medidas de control de calidad (QC) 5.4 Eliminar c√©lulas de baja calidad 5.5 Ejercicio: filtrado de c√©lulas 5.6 Datos de Grun et al 5.7 Gr√°ficas de QC extra 5.8 Ejercicio: ERCC Grun et al 5.9 Identificando droplets vac√≠os con datos de PBMC 5.10 Ejercicio: detecci√≥n de droplets vac√≠os 5.11 Filtrado de expresi√≥n mitocondrial adicional 5.12 Ejercicio avanzado 5.13 Discusi√≥n ¬øConviene eliminar datos? 5.14 Explorando datos de forma interactiva con iSEE 5.15 Detalles de la sesi√≥n de R Patrocinadores", " 5 Control de calidad Instructor: Leonardo Collado Torres ## Paquetes de este cap√≠tulo library(&quot;scRNAseq&quot;) ## para descargar datos de ejemplo library(&quot;AnnotationHub&quot;) ## para obtener informaci√≥n de genes library(&quot;scater&quot;) ## para gr√°ficas y control de calidad library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;DropletUtils&quot;) ## para detectar droplets library(&quot;Matrix&quot;) ## para leer datos en formatos comprimidos 5.1 Diapositivas de Peter Hickey Ve las diapositivas aqu√≠ 5.2 Ejercicio: entendiendo addPerCellQC ## Datos library(&quot;scRNAseq&quot;) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache ## snapshotDate(): 2021-05-18 ## loading from cache ## require(&quot;ensembldb&quot;) sce.416b$block &lt;- factor(sce.416b$block) # Descarga los archivos de anotaci√≥n de la base de datos de Ensembl # correspondientes usando los recursos disponibles v√≠a AnnotationHub library(&quot;AnnotationHub&quot;) ah &lt;- AnnotationHub() ## snapshotDate(): 2021-05-18 query(ah, c(&quot;Mus musculus&quot;, &quot;Ensembl&quot;, &quot;v97&quot;)) ## AnnotationHub with 1 record ## # snapshotDate(): 2021-05-18 ## # names(): AH73905 ## # $dataprovider: Ensembl ## # $species: Mus musculus ## # $rdataclass: EnsDb ## # $rdatadateadded: 2019-05-02 ## # $title: Ensembl 97 EnsDb for Mus musculus ## # $description: Gene and protein annotations for Mus musculus based on Ensem... ## # $taxonomyid: 10090 ## # $genome: GRCm38 ## # $sourcetype: ensembl ## # $sourceurl: http://www.ensembl.org ## # $sourcesize: NA ## # $tags: c(&quot;97&quot;, &quot;AHEnsDbs&quot;, &quot;Annotation&quot;, &quot;EnsDb&quot;, &quot;Ensembl&quot;, &quot;Gene&quot;, ## # &quot;Protein&quot;, &quot;Transcript&quot;) ## # retrieve record with &#39;object[[&quot;AH73905&quot;]]&#39; # Obt√©n la posici√≥n del cromosoma para cada gen ens.mm.v97 &lt;- ah[[&quot;AH73905&quot;]] ## loading from cache location &lt;- mapIds( ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) ## Warning: Unable to map 563 of 46604 requested IDs. # Identifica los genes mitocondriales is.mito &lt;- which(location == &quot;MT&quot;) library(&quot;scater&quot;) sce.416b &lt;- addPerCellQC(sce.416b, subsets = list(Mito = is.mito) ) ## Si quieres guarda los resultados de addPerCellQC() para responder ## las preguntas del ejercicio. Eventualmente si necesitaremos los ## resultados de addPerCellQC() para las secciones posteriores a este ## ejercicio. ¬øQu√© cambi√≥ en nuestro objeto sce despu√©s de addPerCellQC? 1 Haz una gr√°fica de boxplots del n√∫mero de genes por bloque (block) de c√©lulas. 2 5.3 Gr√°ficas sobre medidas de control de calidad (QC) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) + scale_y_log10() plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) 5.3.1 Ejercicio: gr√°ficas QC ERCC Adapta el c√≥digo de las gr√°ficas anteriores para otra variable de control de calidad. Por ejemplo, escribe el c√≥digo para reproducir las siguientes gr√°ficas. Basado en las gr√°ficas encuentra la variable de colData(sce.416b) que contiene la informaci√≥n que queremos gr√°ficar. ¬°No hay que reemplazar todo lo que diga phenotype Tengo cuidado con las transformaciones de valores en el eje Y. No aplican para todo tipo de datos. 5.4 Eliminar c√©lulas de baja calidad # Valores de l√≠mite ejemplo qc.lib &lt;- sce.416b$sum &lt; 100000 qc.nexprs &lt;- sce.416b$detected &lt; 5000 qc.spike &lt;- sce.416b$altexps_ERCC_percent &gt; 10 qc.mito &lt;- sce.416b$subsets_Mito_percent &gt; 10 discard &lt;- qc.lib | qc.nexprs | qc.spike | qc.mito # Obtenemos un resumen del n√∫mero de c√©lulas # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib), NExprs = sum(qc.nexprs), SpikeProp = sum(qc.spike), MitoProp = sum(qc.mito), Total = sum(discard) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 3 0 19 14 33 ## Usando isOutlier() para determinar los valores de corte qc.lib2 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;) qc.nexprs2 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot; ) qc.spike2 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot; ) qc.mito2 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot; ) discard2 &lt;- qc.lib2 | qc.nexprs2 | qc.spike2 | qc.mito2 # Extraemos los l√≠mites de valores (thresholds) attr(qc.lib2, &quot;thresholds&quot;) ## lower higher ## 434082.9 Inf attr(qc.nexprs2, &quot;thresholds&quot;) ## lower higher ## 5231.468 Inf # Obtenemos un resumen del n√∫mero de c√©lulas # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib2), NExprs = sum(qc.nexprs2), SpikeProp = sum(qc.spike2), MitoProp = sum(qc.mito2), Total = sum(discard2) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 4 0 1 2 6 ## M√°s pruebas plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) ## Determino el bloque (batch) de muestras batch &lt;- paste0(sce.416b$phenotype, &quot;-&quot;, sce.416b$block) ## Versi√≥n de isOutlier() que toma en cuenta los bloques de muestras qc.lib3 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.nexprs3 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.spike3 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot;, batch = batch ) qc.mito3 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot;, batch = batch ) discard3 &lt;- qc.lib3 | qc.nexprs3 | qc.spike3 | qc.mito3 # Extraemos los l√≠mites de valores (thresholds) attr(qc.lib3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 461073.1 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 399133.7 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 599794.9 370316.5 ## higher Inf Inf attr(qc.nexprs3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 5399.24 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 6519.74 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 7215.887 7586.402 ## higher Inf Inf # Obtenemos un resumen del n√∫mero de c√©lulas # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib3), NExprs = sum(qc.nexprs3), SpikeProp = sum(qc.spike3), MitoProp = sum(qc.mito3), Total = sum(discard3) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 5 4 6 2 9 5.5 Ejercicio: filtrado de c√©lulas ¬øFue necesario qc.lib para crear discard? 3 ¬øC√∫al filtro fue m√°s estricto? ¬ødiscard o discard2? 4 Al considerar el grupo de cada muestra (batch), ¬ødescartamos m√°s c√©lulas usando un valor de l√≠mite autom√°tico? 5 5.6 Datos de Grun et al ¬øQu√© patr√≥n revela esta gr√°fica? sce.grun &lt;- GrunPancreasData() ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache sce.grun &lt;- addPerCellQC(sce.grun) ## ¬øQu√© patr√≥n revela esta gr√°fica? plotColData(sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ¬øC√∫al de las siguientes gr√°ficas identifica mejor las c√©lulas de baja calidad? ## isOutlier() puede ayudarnos cuando un grupo de muestras ## tuvo m√°s problemas que el resto discard.ercc &lt;- isOutlier(sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection discard.ercc2 &lt;- isOutlier( sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor, subset = sce.grun$donor %in% c(&quot;D17&quot;, &quot;D2&quot;, &quot;D7&quot;) ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection ## isOutlier() tomando en cuenta el batch plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ## isOutlier() tomando en cuenta batch y muestras que fallaron plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc2) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). 5.7 Gr√°ficas de QC extra Otras gr√°ficas que podemos hacer. # Agregamos informaci√≥n sobre que c√©lulas # tienen valores extremos sce.416b$discard &lt;- discard2 # Haz esta gr√°fica para cada medida de # control de calidad (QC) plotColData( sce.416b, x = &quot;block&quot;, y = &quot;sum&quot;, colour_by = &quot;discard&quot;, other_fields = &quot;phenotype&quot; ) + facet_wrap(~phenotype) + scale_y_log10() # Otra gr√°fica de diagn√≥stico √∫til plotColData( sce.416b, x = &quot;sum&quot;, y = &quot;subsets_Mito_percent&quot;, colour_by = &quot;discard&quot;, other_fields = c(&quot;block&quot;, &quot;phenotype&quot;) ) + facet_grid(block ~ phenotype) 5.8 Ejercicio: ERCC Grun et al Adapta el c√≥digo de sce.416b para los datos de Grun et al y reproduce la imagen siguiente. F√≠jate en que variables de colData() estamos graficando. ¬øExiste la variable discard en colData()? ¬øQu√© variable tiene valores de D10, D17, D2, D3 y D7? 5.9 Identificando droplets vac√≠os con datos de PBMC Descripci√≥n gr√°fica la tecnolog√≠a Next GEM de 10x Genomics. Fuente: 10x Genomics. Opciones algor√≠tmicas para detecar los droplets vac√≠os. Fuente: Lun et al, Genome Biology, 2019. ## Descarguemos los datos library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath( bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; ) ) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) ## Leamos los datos en R library(&quot;DropletUtils&quot;) library(&quot;Matrix&quot;) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) bcrank &lt;- barcodeRanks(counts(sce.pbmc)) # Mostremos solo los puntos √∫nicos para acelerar # el proceso de hacer esta gr√°fica uniq &lt;- !duplicated(bcrank$rank) plot( bcrank$rank[uniq], bcrank$total[uniq], log = &quot;xy&quot;, xlab = &quot;Rank&quot;, ylab = &quot;Total UMI count&quot;, cex.lab = 1.2 ) ## Warning in xy.coords(x, y, xlabel, ylabel, log): 1 y value &lt;= 0 omitted from ## logarithmic plot abline( h = metadata(bcrank)$inflection, col = &quot;darkgreen&quot;, lty = 2 ) abline( h = metadata(bcrank)$knee, col = &quot;dodgerblue&quot;, lty = 2 ) legend( &quot;bottomleft&quot;, legend = c(&quot;Inflection&quot;, &quot;Knee&quot;), col = c(&quot;darkgreen&quot;, &quot;dodgerblue&quot;), lty = 2, cex = 1.2 ) Encontremos los droplets vac√≠os usando emptyDrops(). ## Usemos DropletUtils para encontrar los droplets set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) # Revisa ?emptyDrops para una explicaci√≥n de porque hay valores NA summary(e.out$FDR &lt;= 0.001) ## Mode FALSE TRUE NA&#39;s ## logical 989 4300 731991 set.seed(100) limit &lt;- 100 all.out &lt;- emptyDrops(counts(sce.pbmc), lower = limit, test.ambient = TRUE) # Idealmente, este histograma deber√≠a verse uniforme. # Picos grandes cerca de cero indican que los _barcodes_ # con un n√∫mero total de cuentas menor a &quot;lower&quot; no son # de origen ambiental. hist(all.out$PValue[all.out$Total &lt;= limit &amp; all.out$Total &gt; 0], xlab = &quot;P-value&quot;, main = &quot;&quot;, col = &quot;grey80&quot; ) 5.10 Ejercicio: detecci√≥n de droplets vac√≠os ¬øPor qu√© emptyDrops() regresa valores NA? 6 ¬øLos valores p son iguales entre e.out y all.out? 7 ¬øSon iguales si obtienes el subconjunto de valores que no son NA? 8 5.11 Filtrado de expresi√≥n mitocondrial adicional Despu√©s de filtar los droplets, el filtrado por expresi√≥n mitocondrial nos va a ayudar a eliminar c√©lulas de baja calidad. sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] is.mito &lt;- grep(&quot;^MT-&quot;, rowData(sce.pbmc)$Symbol) sce.pmbc &lt;- addPerCellQC(sce.pbmc, subsets = list(MT = is.mito)) discard.mito &lt;- isOutlier(sce.pmbc$subsets_MT_percent, type = &quot;higher&quot;) plot( sce.pmbc$sum, sce.pmbc$subsets_MT_percent, log = &quot;x&quot;, xlab = &quot;Total count&quot;, ylab = &quot;Mitochondrial %&quot; ) abline(h = attr(discard.mito, &quot;thresholds&quot;)[&quot;higher&quot;], col = &quot;red&quot;) 5.12 Ejercicio avanzado Volvamos a crear sce.pbmc para poder usar plotColData() y visualizar la relaci√≥n entre total y los niveles de expresi√≥n mitocondrial (en porcentaje) separando lo que pensamos que son droplets vac√≠os y las c√©lulas de acuerdo a los resultados que ya calculamos de emptyDrops(). El resultado final se ver√° como en la siguiente imagen. No podemos usar nuestro objeto sce.pbmc porque ya eliminamos los droplets vac√≠os al correr sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)]. Por eso tendremos que volver a usar sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE). Una vez que hayamos vuelto a hacer sce.pbmc, tenemos que guardar en ese objeto los resultados de emptyDrops(). Por ejemplo, con sce.pbmc$is_cell &lt;- e.out$FDR &lt;= 0.001. Como e.out$FDR tiene muchos NA, nos conviene filtrar esos datos. Tendremos que volver a correr addPerCellQC() y guardar los resultados en nuestro objeto sce.pbmc. Al final usaremos plotColData() junto con facet_grid(~ sce.pbmc$is_cell). 5.13 Discusi√≥n ¬øConviene eliminar datos? # Eliminemos las c√©lulas de calidad baja # al quedarnos con las columnas del objeto sce que NO # queremos descartar (eso hace el !) filtered &lt;- sce.416b[, !discard2] # Alternativamente, podemos marcar # las c√©lulas de baja calidad marked &lt;- sce.416b marked$discard &lt;- discard2 ¬øC√∫al de estos objetos es m√°s grande? 9 ¬øC√∫al prefieres usar? 10 5.13.1 Un nuevo paquete: ExperimentSubset En BioC2021 presentaron ExperimentSubset que provee otro camino para resolver este dilema. Descripci√≥n gr√°fica de ExperimentSubset. Fuente: vignette ExperimentSubset. 5.14 Explorando datos de forma interactiva con iSEE #rstats / @Bioconductor congrats winners of the 1st Shiny Contest: iSEE https://t.co/oHgGkWqRsJ https://t.co/vZLFvcMBIS ! ‚Äî Bioconductor (@Bioconductor) April 7, 2019 http://bioconductor.org/packages/release/bioc/html/iSEE.html http://bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html ## Hagamos un objeto sencillo de tipo RangedSummarizedExperiment library(&quot;SummarizedExperiment&quot;) ## ?SummarizedExperiment ## De los ejemplos en la ayuda oficial ## Creamos los datos para nuestro objeto de tipo SummarizedExperiment ## para 200 genes a lo largo de 6 muestras nrows &lt;- 200 ncols &lt;- 6 ## N√∫meros al azar de cuentas set.seed(20210223) counts &lt;- matrix(runif(nrows * ncols, 1, 1e4), nrows) ## Informaci√≥n de nuestros genes rowRanges &lt;- GRanges( rep(c(&quot;chr1&quot;, &quot;chr2&quot;), c(50, 150)), IRanges(floor(runif(200, 1e5, 1e6)), width = 100), strand = sample(c(&quot;+&quot;, &quot;-&quot;), 200, TRUE), feature_id = sprintf(&quot;ID%03d&quot;, 1:200) ) names(rowRanges) &lt;- paste0(&quot;gene_&quot;, seq_len(length(rowRanges))) ## Informaci√≥n de nuestras muestras colData &lt;- DataFrame( Treatment = rep(c(&quot;ChIP&quot;, &quot;Input&quot;), 3), row.names = LETTERS[1:6] ) ## Juntamos ahora toda la informaci√≥n en un solo objeto de R rse &lt;- SummarizedExperiment( assays = SimpleList(counts = counts), rowRanges = rowRanges, colData = colData ) ## Exploremos el objeto resultante rse ## class: RangedSummarizedExperiment ## dim: 200 6 ## metadata(0): ## assays(1): counts ## rownames(200): gene_1 gene_2 ... gene_199 gene_200 ## rowData names(1): feature_id ## colnames(6): A B ... E F ## colData names(1): Treatment ## Explora el objeto rse de forma interactiva library(&quot;iSEE&quot;) if (interactive()) { iSEE::iSEE(rse) } 5.14.1 Ejercicio iSEE con sce.416b Repitamos la imagen que hicimos anteriormente. ## Explora el objeto sce.416b de forma interactiva if (interactive()) { iSEE::iSEE(sce.416b, appTitle = &quot;sce.416b&quot;) } 5.14.2 Datos de LIBD de Tran et al Datos de Tran et al, bioRxiv, 2020. C√≥digo de R para el sitio web: https://github.com/LieberInstitute/10xPilot_snRNAseq-human/tree/master/shiny_apps/tran2021_AMY. 5.14.3 M√°s detalles de iSEE Notas en ingl√©s. 5.15 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:20:48 UTC&quot; proc.time() ## user system elapsed ## 187.698 4.011 194.295 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE * 2.4.0 2021-05-19 [1] Bioconductor ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Ahora tenemos m√°s informaci√≥n en colData(sce.416b)‚Ü©Ô∏é with(colData(sce.416b), boxplot(detected ~ block))‚Ü©Ô∏é S√≠, usando table(qc.lib , qc.spike) y table(qc.lib , qc.mito).‚Ü©Ô∏é discard de table(discard, discard2)‚Ü©Ô∏é S√≠, usando table(discard, discard2, discard3)‚Ü©Ô∏é Debajo de lower son considerados droplets vac√≠os. Solo se usan para la correci√≥n estad√≠stica de pruebas m√∫ltiples.‚Ü©Ô∏é No, debido a los NAs.‚Ü©Ô∏é S√≠: identical(e.out$PValue[!is.na(e.out$FDR)], all.out$PValue[!is.na(e.out$FDR)]).‚Ü©Ô∏é marked es m√°s grande que filtered‚Ü©Ô∏é Yo prefiero usar marked si tengo suficiente memoria para usarlo.‚Ü©Ô∏é "],["normalizaci√≥n-de-datos.html", "6 Normalizaci√≥n de datos 6.1 Material 6.2 Motivaci√≥n 6.3 Datos 6.4 Normalizaci√≥n por escalamiento (scaling normalization) 6.5 Normalizaci√≥n por decircunvoluci√≥n (deconvolution) 6.6 Transformaci√≥n logar√≠tmica 6.7 Otras normalizaciones 6.8 Notas finales 6.9 Adicionales 6.10 Agradecimientos 6.11 Detalles de la sesi√≥n de R Patrocinadores", " 6 Normalizaci√≥n de datos Instructora: Ana Beatriz Villase√±or Altamirano 6.1 Material Diapositivas de Peter Hickey: Ve las diapositivas aqu√≠ Cap√≠tulo de OSCA: Ve el cap√≠tulo del libro OSCA aqu√≠ 6.2 Motivaci√≥n Al igual que otras tecnolog√≠as, single-cell RNA-seq (scRNA-seq) tiene errores sistem√°ticos y es importante conocerlos. Dentro de los m√°s comunes se encuentran la captura de cDNA y la amplificaci√≥n de PCR que se lleva acabo por c√©lula. Tener poco material de inicio dificulta lograr una preparaci√≥n de libreria consistente dando lugar a errores sistem√°ticos. Figura tomada de [1] La normalizaci√≥n tiene como objetivo remover est√°s diferencias sistem√°ticas para que no interfieran cuando comparamos los perfiles de expresi√≥n entre c√©lulas. Al normalizar los datos, las diferencias observadas entre poblaciones c√©lulares o condiciones son debido a la biolog√≠a y no por factores t√©cnicos. 6.2.1 Ejercicio: Conceptos b√°sicos Da ejemplos de sesgos t√©cnicos (TIP: ¬øQu√© es RPKM?). ¬øQu√© es correci√≥n por lote (batch effect correction)? Da un ejemplo. ¬øCu√°les son las diferencias entre correci√≥n por lote y normalizaci√≥n? 6.3 Datos Usaremos el dataset de Zeisel. Tipos celulares en cerebro de rat√≥n (oligodendrocitos, microglias, neuronas, etc.) Procesado con STRT-seq (similar a CEL-seq), un sistema de microfluio. 3005 c√©lulas y 18441 genes Contiene UMIs library(&quot;scRNAseq&quot;) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) sce.zeisel ## class: SingleCellExperiment ## dim: 18441 3005 ## metadata(0): ## assays(1): counts ## rownames(18441): ENSMUSG00000029669 ENSMUSG00000046982 ... ## ENSMUSG00000064337 ENSMUSG00000065947 ## rowData names(2): featureType originalName ## colnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12 ## 1772058148_F03 ## colData names(10): tissue group # ... level1class level2class ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC repeat 6.3.1 Ejercicio: QC ¬øCu√°ntos genes son mitocondriales? (TIP: is.mito) ¬øCu√°ntos genes tienen: bajas cuentas de librer√≠a, bajos features, alto porcentaje de expresi√≥n de ERCC, alto porcentaje de genes MT? ¬øCu√°ntas c√©lulas descartamos? (TIP: perCellQCMetrics y quickPerCellQC) Gr√°fica los resultados 6.4 Normalizaci√≥n por escalamiento (scaling normalization) La normalizaci√≥n por escalamiento es la estrategia m√°s simple y usada. Representa el estimado del sesgo relativo en cada c√©lula. Se realiza dividiendo todas las cuentas de cada c√©lula por un factor de escalamiento espec√≠fico para cada una. Este factor de escalamiento se le conoce como Library Size factor. \\[ CuentasNormalizadas = Cuentas / Library Size factor\\] Suposici√≥n: Cualquier sesgo espec√≠fico en cada c√©lula (e.j. eficiencia en la captura o en la amplificaci√≥n) afecta a todos los genes de igual manera a trav√©s de escalar por el promedio esperado de cuentas para dicha c√©lula. Los valores de expresi√≥n normalizados pueden ser usados por an√°lisis posteriores como clustering o reducci√≥n de dimenciones. 6.4.1 Tama√±o de biblioteca (Library Size) Tama√±o de biblioteca (Library Size): La suma total de las cuentas a tr√°ves de todos los genes en una c√©lula. \\[Library Size_{cell} = \\sum_{n=1}^{j} gene\\] Donde \\(j\\) es el n√∫mero total de genes y \\(gene\\) es el n√∫mero de cuentas por gen para cada c√©lula. El valor de library size es el que asumimos que escala con cualquier sesgo espec√≠fico en cada c√©lula. Para escalar los datos ocuparemos un factor de escalamiento llamado Library Size factor. \\[ Library Size \\propto Library Size factor \\] Se calcula usando library size: \\[ Library Size factor = {Library Size} / {mean(Library Size)}\\] Y se define de tal manera que el promedio de Library Size factor en todas las c√©lulas es igual a 1. \\[ mean(Library Size factor) = 1 \\] Lo que nos permite que los valores normalizados est√°n en la misma escala y pueden ser √∫tiles para la interpretaci√≥n. # Estimar tama√±os de librer√≠as lib.sf.zeisel &lt;- librarySizeFactors(sce.zeisel) # Examina la distribuci√≥n de los tama√±os de librer√≠as # que acabamos de estimar summary(lib.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 hist(log10(lib.sf.zeisel), xlab = &quot;Log10[Library Size factor]&quot;, col = &quot;grey80&quot;) 6.4.2 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library Size ls.zeisel ¬øSon id√©nticos ls.zeisel y lib.sf.zeisel? ¬øSon proporcionales? Calcula lib.sf.zeisel de forma manual. TIP: Checa el c√≥digo fuente 6.4.3 Puntos finales Normalizar por Library Size factor asume que no hay desigualdad en la cantidad de genes differencialmente expresados (DE) entre dos c√©lulas. Es decir, que para cada grupo de genes sobre-expresados, debe existir un grupo de genes sub-expresados en la misma magnitud, cuando esto no pasa se le conoce como sesgo de composici√≥n (Ve√°se a continuaci√≥n). Para an√°lisis exploratorios, la precisi√≥n de la normalizaci√≥n no es un punto mayor a considerar. El sesgo por composici√≥n normalmente no afecta la separaci√≥n de los clusters, solo la magnitud. La normalizaci√≥n por Library Size factor suele ser suficiente en algunas ocasiones donde se busca identificar clusters y los marcadores de los clusters. 6.5 Normalizaci√≥n por decircunvoluci√≥n (deconvolution) Un sesgo t√©cnico que es importante considerar es el sesgo de composici√≥n de RNA (transcriptoma). Supongamos que un gen X (o grupo de genes) se expresa en mayor cantidad en la c√©lula A comparado a la c√©lula B. Esto significa que m√°s recursos fueron tomados por el gen X, disminuyendo la covertura de los dem√°s. ¬øQu√© pasa si escalamos por tama√±o de biblioteca? Figura tomada de [2] Este problema ha sido estudiado en bulk RNA-seq, DESeq2::estimateSizeFactorsFromMatrix() y edgeR::calcNormFactors(), contemplan este sesgo. Se assume que la mayor√≠a de genes no estar√°n DE entre las muestras (en nuestro caso c√©lulas) y cualquier diferencia entre los genes non-DE representa un sesgo el cual se remueve (calculando un factor de normalizaci√≥n). Sin embargo, single-cell RNA-seq tiene muchas cuentas bajas y ceros debido a limitaciones en la tecnolog√≠a y no necesariamente indica ausencia de expresi√≥n. El m√©todo de scran resuelve este problema juntando las cuentas de varias c√©lulas (pool) para incrementar el tama√±o de las cuentas y obtener un factor de estimaci√≥n que remueva el sesgo de composici√≥n de manera m√°s precisa. Este factor calculado con las cuentas pool se les regresa individualmente a cada c√©lula mediante decircunvoluci√≥n (deconvolution). Utilizando este factor se normalizan los datos con scran::calculateSumFactors(). # Normalizaci√≥n por decircunvoluci√≥n (deconvolution) library(&quot;scran&quot;) # Pre-clustering set.seed(100) clust.zeisel &lt;- quickCluster(sce.zeisel) # Calcula factores de tama√±o para la decircunvoluci√≥n (deconvolution) deconv.sf.zeisel &lt;- calculateSumFactors(sce.zeisel, clusters = clust.zeisel, min.mean = 0.1) # Examina la distribuci√≥n de los factores de tama√±o summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 hist(log10(deconv.sf.zeisel), xlab = &quot;Log10[Deconvolution size factor]&quot;, col = &quot;grey80&quot; ) plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16 ) abline(a = 0, b = 1, col = &quot;red&quot;) 6.5.1 Ejercicios: deconvolution ¬øC√∫antos clusters r√°pidos obtuvimos? ¬øC√∫antas c√©lulas por cluster obtuvimos? ¬øC√∫antos clusters r√°pidos obtendr√≠amos si cambiamos el tama√±o m√≠nimo a 200? Usa 100 como la semilla (seed). ¬øC√∫antas l√≠neas ves en la gr√°fica? 6.5.2 Puntos finales La normalizaci√≥n por decircunvoluci√≥n (deconvolution) mejora los resultados para an√°lisis posteriores de una manera m√°s precisa que los m√©todos para bulk RNA-seq. scran algunas veces alcula factores negativos o ceros lo cual altera la matrix de expresi√≥n normalizada. ¬°Checa los factores que calculas! summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 Si obtienes factores negativos intenta variar el n√∫mero de clusters, checa si incrementar el n√∫mero de c√©lulas por cluster te dan factores positivos. 6.6 Transformaci√≥n logar√≠tmica 6.6.1 Motivaci√≥n ¬øQu√© gen es m√°s interesante? Gen X: el promedio de expresi√≥n en el tipo celular A: 50 y B: 10 Gen Y: el promedio de expresi√≥n en el tipo celular A: 1100 y B: 1000 50 - 10 ## [1] 40 1100 - 1000 ## [1] 100 log(50) - log(10) ## [1] 1.609438 log(1100) - log(1000) ## [1] 0.09531018 Una vez calculados los factores de normalizaci√≥n con computeSumFactors(), podemos calular las cuentas en escala logaritmica usando logNormCounts(). Estos valores resultantes son valores de expresi√≥n normalizados transformados en escala logar√≠tmica. # Normalization # set.seed(100) # clust.zeisel &lt;- quickCluster(sce.zeisel) # sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster=clust.zeisel, min.mean=0.1) # Log transformation sce.zeisel &lt;- scater::logNormCounts(sce.zeisel) assayNames(sce.zeisel) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.6.2 Ejercicio: Transformaci√≥n logar√≠tmica ¬øQu√© es una pseudo-cuenta? ¬øPorqu√© se usa? ¬øQu√© valor de pseudo-cuenta usa logNormCounts()? ¬øQu√© es la opci√≥n downsample=TRUE? 6.7 Otras normalizaciones Te invitamos a leer m√°s sobre otras formas de normalizar, un lugar para empezar lo puedes encontrar en el curso del Sanger Institute. Si estas interesad@ en diferencias en el contenido total de RNA en cada c√©lula checa la normalizaci√≥n por spike-ins. La cual asume que los spike-ins fueron a√±adidos en un nivel constante en cada c√©lula. Si tienes resultados donde el library size est√° asociado a tus datos a pesar de haber normalizado checa la opci√≥n de downsample=TRUE dentro de la funci√≥n de logNormCounts(). 6.7.1 Seurat La normalizaci√≥n de Seurat con NormalizeData() (tomado de aqu√≠): Dividir cada c√©lula por el n√∫mero total de mol√©culas medidas en la c√©lula. - ¬øSer√° library size? Multiplicar ese n√∫mero por un scaling factor (e.j. 10000) Sumar 1 y tomar el logaritmo natural. library(&quot;Seurat&quot;) # Create a Seurat obj sce &lt;- sce.zeisel sce &lt;- removeAltExps(sce) seurat.zeisel &lt;- as.Seurat(sce, counts = &quot;counts&quot;, data = NULL) seurat.zeisel ## An object of class Seurat ## 18441 features across 2815 samples within 1 assay ## Active assay: endogenous (18441 features, 0 variable features) # Normalize using Seurat function seurat.zeisel &lt;- NormalizeData(seurat.zeisel, normalization.method = &quot;LogNormalize&quot;) # Compare Total counts per cell after normalization ls.seurat &lt;- colSums(seurat.zeisel[[SingleCellExperiment::mainExpName(x = sce)]]@data) ## Relacionado a ## https://github.com/satijalab/seurat/blob/9b3892961c9e1bf418af3bbb1bc79950adb481d7/R/objects.R#L1041-L1046 ## donde podemos ver como Seurat convierte el objeto de SingleCellExperiment ## a un objeto de Seurat summary(ls.seurat) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 hist(ls.seurat) # Trying to replicate it ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 step1 &lt;- t(counts(sce.zeisel)) / ls.zeisel # matrix(2,2,2,2) /c(1,2) step2 &lt;- step1 * 10000 step3 &lt;- t(log1p(step2)) ls.steps &lt;- colSums(step3) summary(ls.steps) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 plot(ls.seurat, ls.steps) # Compare with deconv normalization ls.log &lt;- colSums(logcounts(sce.zeisel)) plot(ls.seurat, ls.log) Nota: scanpy ocupa un factor de normalizaci√≥n igual que Seurat. 6.8 Notas finales 6.8.1 Ejercicio: Conceptos b√°sicos Da ejemplos de sesgos t√©cnicos (TIP: ¬øQu√© es RPKM?). ‚ÄúTechnical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content)‚Äù - hbctraining Algunos ejemplos de los sesgos t√©cnicos que se contemplan son la profundidad de secuenciaci√≥n y la longitud del gen. Profundidad de secuenciaci√≥n: Es necesario contemplarlo para comparar entre muestras, en este caso c√©lulas. Figura tomada de [2] Longitud del gen: Es necesario contemplarlo para comparar entre genes. Figura tomada de [2] ¬øQu√© es correci√≥n por lote (batch effect correction)? Da un ejemplo. ‚ÄúLarge single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints. However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality. This results in systematic differences in the observed expression in cells from different batches, which we refer to as ‚Äúbatch effects‚Äù. Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results\" -OSCA ¬øCu√°les son las diferencias entre correci√≥n por lote y normalizaci√≥n? ‚ÄúNormalization occurs regardless of the batch structure and only considers technical biases, while batch correction - as the name suggests - only occurs across batches and must consider both technical biases and biological differences. Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content), while biological differences between batches can be highly unpredictable‚Äù -OSCA 6.8.2 Ejercicio: QC ¬øCu√°ntos genes son mitocondriales? (recuerdas is.mito) length(is.mito) ## [1] 34 ¬øCu√°ntos genes tienen: bajas cuentas de librer√≠a, bajos features, alto porcentaje de expresi√≥n de ERCC, alto porcentaje de genes MT? ¬øCu√°ntas c√©lulas descartamos? (TIP: perCellQCMetrics y quickPerCellQC) colSums(as.data.frame(qc)) ## low_lib_size low_n_features high_altexps_ERCC_percent ## 0 3 66 ## high_subsets_Mt_percent discard ## 128 190 Gr√°fica los resultados # Plots colData(unfiltered) &lt;- cbind(colData(unfiltered), stats) unfiltered$discard &lt;- qc$discard gridExtra::grid.arrange( plotColData(unfiltered, y = &quot;sum&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Cuentas Totales&quot;), plotColData(unfiltered, y = &quot;detected&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Features (genes) detectados&quot;), plotColData(unfiltered, y = &quot;altexps_ERCC_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;ERCC %&quot;), plotColData(unfiltered, y = &quot;subsets_Mt_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;Mito %&quot;), ncol = 2 ) 6.8.3 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library size ls.zeisel ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 hist(log10(ls.zeisel), xlab = &quot;Log10[Library size]&quot;, col = &quot;grey80&quot;) ¬øSon id√©nticos ls.zeisel y lib.sf.zeisel? identical(lib.sf.zeisel, ls.zeisel) ## [1] FALSE ¬øSon proporcionales? # Checamos proporcionalidad plot( ls.zeisel, lib.sf.zeisel, log = &quot;xy&quot;, main = &quot;Proporcionalidad&quot;, xlab = &quot;Library size&quot;, ylab = &quot; Library size factor&quot; ) Calcula lib.sf.zeisel de forma manual. TIP: Checa el c√≥digo fuente ## Ahora asegurate que su media sea 1 (unity mean) lib_size_factors &lt;- ls.zeisel / mean(ls.zeisel) summary(lib_size_factors) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 identical(lib_size_factors, lib.sf.zeisel) ## [1] TRUE 6.8.4 Ejercicios: deconvolution ¬øC√∫antos clusters r√°pidos obtuvimos? levels(clust.zeisel) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ¬øC√∫antas c√©lulas por cluster obtuvimos? cells_cluster &lt;- sort(table(clust.zeisel)) cells_cluster ## clust.zeisel ## 12 7 4 6 10 1 3 11 2 8 5 9 ## 113 123 140 224 231 243 252 259 281 300 324 325 barplot(cells_cluster) ¬øC√∫antos clusters r√°pidos obtendr√≠amos si cambiamos el tama√±o m√≠nimo a 200? Usa 100 como la semilla (seed). set.seed(100) sort(table(quickCluster(sce.zeisel, min.size = 200))) ## ## 5 9 6 1 3 10 2 4 8 7 ## 224 231 236 243 252 259 281 324 325 440 ¬øC√∫antas l√≠neas ves en la gr√°fica? plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16, col = as.integer(factor(sce.zeisel$level1class)) ) abline(a = 0, b = 1, col = &quot;red&quot;) abline(a = -.2, b = 0.95, col = &quot;red&quot;) abline(a = 0.08, b = 1, col = &quot;red&quot;) 6.8.5 Ejercicio: Transformaci√≥n logar√≠tmica ¬øQu√© es una pseudo-cuenta? Un n√∫mero que se agrega para poder sacar el logar√≠tmo ¬øPorqu√© se usa? Por que log(0) = -Inf y produce error m√°s adelante. ¬øQu√© valor de pseudo-cuenta usa logNormCounts()? pseudo.count = 1 ¬øQu√© es la opci√≥n downsample=TRUE? OSCA: Downsampling. Para cuando existe un efecto en los valores que se asocia a la library size a pesar de haber nomalizado. Funciones interesantes para despu√©s de normalizar # sce.zeisel &lt;- runPCA(sce.zeisel) # plotPCA(sce.zeisel, colour_by = &quot;level1class&quot;) # plotRLE(sce.zeisel, exprs_values = &quot;logcounts&quot;, colour_by = &quot;level1class&quot;) 6.9 Adicionales [1] 2018 BioInfoSummer Workshop [2] HBC training 6.10 Agradecimientos Este curso est√° basado en el libro Orchestrating Single Cell Analysis with Bioconductor de Aaron Lun, Robert Amezquita, Stephanie Hicks y Raphael Gottardo, adem√°s del curso de scRNA-seq para WEHI creado por Peter Hickey. Y en el material de la comunidadbioinfo/cdsb2020 con el permiso de Leonardo Collado-Torres. 6.11 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:22:12 UTC&quot; proc.time() ## user system elapsed ## 77.657 5.369 83.845 options(width = 120) sessioninfo::session_info() ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["selecci√≥n-de-genes.html", "7 Selecci√≥n de genes 7.1 Diapositivas de Peter Hickey 7.2 Motivaci√≥n 7.3 Selecci√≥n de features (genes) 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.5 Dataset ilustrativo: 416B 7.6 Cuantificando la varianza por gen 7.7 Coeficiente de variaci√≥n de las cuentas 7.8 Varianza de los log-counts vs coeficiente de variaci√≥n 7.9 Cuantificando el ruido t√©cnico 7.10 En la ausencia de spike-ins 7.11 Recordemos propiedades de los datos de sce.416b 7.12 Considerando factores experimentales 7.13 Seleccionando genes altamante variables (high-variable genes, HVGs) 7.14 Poniendo todo junto 7.15 Resumen y recomendaciones 7.16 Recomendaciones para empezar 7.17 Detalles de la sesi√≥n de R Patrocinadores", " 7 Selecci√≥n de genes Instructora: Yalbi I. Balderas-Mart√≠nez Instructora: Laura G√≥mez-Romero 7.1 Diapositivas de Peter Hickey Ver las diapositivas originales aqu√≠ 7.2 Motivaci√≥n Usualmente usamos datos scRNA-seq para caracterizar la heterogeneidad entre c√©lulas Para hacer esto, usamos m√©todos como el clustering y la reducci√≥n de dimensionalidad Esto involucra resumir las diferencias por gen en una sola medida de (dis)similitud entre un par de c√©lulas ¬øCu√°les genes deber√≠amos usar para calcular esta medida de (dis)similitud? 7.3 Selecci√≥n de features (genes) La elecci√≥n de los features tiene un mayor impacto en qu√© tan similares decidimos que son las c√©lulas ‚ûï Features que contienen informaci√≥n √∫til biol√≥gica ‚ûñ Features que contienen ruido aleatorio üëâ Efectos laterales al reducir la dimensionalidad de los datos Deseamos seleccionar los genes altamente variables (High Variable Genes HVGs). Genes con una variaci√≥n incrementada en comparaci√≥n con otros genes que est√°n siendo afectados por ruido t√©cnico u otra variaci√≥n biol√≥gica que no es de nuestro inter√©s. 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.4.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) sce.pbmc ## class: SingleCellExperiment ## dim: 33694 737280 ## metadata(1): Samples ## assays(1): counts ## rownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(2): ID Symbol ## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ... ## TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Dataset ‚ÄúC√©lulas mononucleares humanas de sangre perif√©rica‚Äù de 10X Genomics Descripci√≥n aqu√≠ 11 7.4.2 Anotaci√≥n # Anotaci√≥n de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detecci√≥n de _droplets_ con c√©lulas set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 7.4.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalizaci√≥n de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 7.4.4 Preguntas de repaso ¬øC√≥mo determinamos cu√°les eran los genes mitocondriales? 12 ¬øC√≥mo decidimos filtrar las c√©lulas? 13 ¬øPuedes explicar como normalizamos los datos? 14 7.5 Dataset ilustrativo: 416B library(scRNAseq) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) sce.416b$block &lt;- factor(sce.416b$block) L√≠nea celular de c√©lulas mieloides progenitoras inmortalizadas de rat√≥n usando SmartSeq2 https://osca.bioconductor.org/lun-416b-cell-line-smart-seq2.html 15 # gene-annotation library(AnnotationHub) ens.mm.v97 &lt;- AnnotationHub()[[&quot;AH73905&quot;]] rowData(sce.416b)$ENSEMBL &lt;- rownames(sce.416b) rowData(sce.416b)$SYMBOL &lt;- mapIds(ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SYMBOL&quot; ) rowData(sce.416b)$SEQNAME &lt;- mapIds(ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) library(scater) rownames(sce.416b) &lt;- uniquifyFeatureNames( rowData(sce.416b)$ENSEMBL, rowData(sce.416b)$SYMBOL ) # quality-control mito &lt;- which(rowData(sce.416b)$SEQNAME == &quot;MT&quot;) stats &lt;- perCellQCMetrics(sce.416b, subsets = list(Mt = mito)) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;subsets_Mt_percent&quot;, &quot;altexps_ERCC_percent&quot;), batch = sce.416b$block ) sce.416b &lt;- sce.416b[, !qc$discard] # normalization library(scran) sce.416b &lt;- computeSumFactors(sce.416b) sce.416b &lt;- logNormCounts(sce.416b) 7.5.1 Preguntas de repaso ¬øC√≥mo determinamos cu√°les eran los genes mitocondriales? ¬øC√≥mo decidimos filtrar las c√©lulas ¬øPuedes explicar c√≥mo normalizamos los datos? 7.6 Cuantificando la varianza por gen 7.6.1 Varianza de los log-counts El enfoque m√°s simple para cuantificar la variaci√≥n per-feature es simplemente calcular la varianza de los log-counts ‚ûï Selecci√≥n del feature basado en los log-counts (que ser√°n usadas en los an√°lisis m√°s adelante) ‚ö†Ô∏è La transformaci√≥n log no logra la estabilizaci√≥n de la varianza perfecta, as√≠ que se requiere modelar la relaci√≥n de la varianza-media de los features. 7.6.2 Enfoque simple Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Ordenar los genes del m√°s-al-menos variable 7.6.3 Un enfoque m√°s sofisticado Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Modelar la relaci√≥n entre la media y la varianza de los log-counts para estimar la variaci√≥n t√©cnica Estimar la varianza biol√≥gica sustrayendo la varianza t√©cnica de la varianza total Ordenar los genes de la variable de mayor-a-menor biol√≥gicamente 7.6.4 Supuestos # Varianza de las log-counts library(scran) dec.pbmc &lt;- modelGeneVar(sce.pbmc) ü§ì El supuesto es que a cualquier abundancia dada, la abundancia de los perfiles de expresi√≥n de la mayor√≠a de los genes est√°n dominados por el ruido aleatorio t√©cnico ü§ì Por lo consiguiente, una tendencia representa un estimado del ruido t√©cnico como una funci√≥n de la abundancia ü§ì Podemos entonces descomponer la varianza total de cada gen en un componente t√©cnico y uno biol√≥gico ü§ì Genes con una gran varianza biol√≥gica son considerados interesantes 7.6.5 Visualizando la media y varianza # Visualicemos la relaci√≥n entre la media y la varianza fit.pbmc &lt;- metadata(dec.pbmc) plot(fit.pbmc$mean, fit.pbmc$var, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) curve(fit.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) 7.6.5.1 Ejercicios ¬øQu√© tipo de objeto nos regres√≥ modelGeneVar()? 16 ¬ødec.pbmc es una tabla? ¬øO contiene mayor informaci√≥n? 17 ¬øQu√© tipo de objeto es fit.pbmc y que objetos con nombres contiene? 18 ¬øQu√© tipo de objeto es fit.pbmc$trend? 19 ¬øDonde podemos encontrar m√°s detalles de esta funci√≥n? 20 7.6.6 Ordenando genes interesantes # Ordenemos por los genes m√°s interesantes para checar # los datos dec.pbmc[order(dec.pbmc$bio, decreasing = TRUE), ] ## DataFrame with 33694 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## LYZ 1.95605 5.05854 0.835343 4.22320 1.10538e-270 2.17417e-266 ## S100A9 1.93416 4.53551 0.835439 3.70007 2.71043e-208 7.61593e-205 ## S100A8 1.69961 4.41084 0.824342 3.58650 4.31581e-201 9.43197e-198 ## HLA-DRA 2.09785 3.75174 0.831239 2.92050 5.93950e-132 4.86767e-129 ## CD74 2.90176 3.36879 0.793188 2.57560 4.83937e-113 2.50488e-110 ## ... ... ... ... ... ... ... ## TMSB4X 6.08142 0.441718 0.679215 -0.237497 0.992447 1 ## PTMA 3.82978 0.486454 0.731275 -0.244821 0.990002 1 ## HLA-B 4.50032 0.486130 0.739577 -0.253447 0.991376 1 ## EIF1 3.23488 0.482869 0.768946 -0.286078 0.995135 1 ## B2M 5.95196 0.314948 0.654228 -0.339280 0.999843 1 7.7 Coeficiente de variaci√≥n de las cuentas El coeficiente de variaci√≥n de las cuentas al cuadrado (CV2) es una alternativa a la varianza de los log-counts üëâ Se calcula usando las cuentas en lugar de los log-counts ü§ì CV es el ratio de la desviaci√≥n est√°ndar a la media y est√° muy relacionada con el par√°metro de dispersi√≥n de la distribuci√≥n binomial negativa usada en edgeR y DESeq2 7.7.1 Coeficiente de variaci√≥n # Coeficiente de variaci√≥n dec.cv2.pbmc &lt;- modelGeneCV2(sce.pbmc) ü§ì Modela la relaci√≥n de la media de la varianza cuando se considera la relevancia de cada gen ü§ì Asume que la mayor√≠a de los genes contienen ruido aleatorio y que la tendencia captura la mayor√≠a de la variaci√≥n t√©cnica ü§ì Genes con un gran CV2 que se desv√≠an fuertemente de la tendencia es probable que representen genes afectados por la estructura biol√≥gica ü§ì Usa la tasa (en lugar de la diferencia) del CV2 a la tendencia 7.7.2 Visualizando el coeficiente de variaci√≥n # Visualicemos la relaci√≥n con la media fit.cv2.pbmc &lt;- metadata(dec.cv2.pbmc) plot(fit.cv2.pbmc$mean, fit.cv2.pbmc$cv2, log = &quot;xy&quot; ) curve(fit.cv2.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2 ) 7.7.3 Genes por coeficiente de variaci√≥n # Ordenemos por los genes m√°s interesantes para checar # los datos dec.cv2.pbmc[order(dec.cv2.pbmc$ratio, decreasing = TRUE ), ] ## DataFrame with 33694 rows and 6 columns ## mean total trend ratio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## PPBP 2.2437397 132.364 0.803689 164.696 0 0 ## PRTFDC1 0.0658743 3197.564 20.266829 157.773 0 0 ## HIST1H2AC 1.3731487 175.035 1.176934 148.721 0 0 ## FAM81B 0.0477082 3654.419 27.902078 130.973 0 0 ## PF4 1.8333127 109.451 0.935484 116.999 0 0 ## ... ... ... ... ... ... ... ## AC023491.2 0 NaN Inf NaN NaN NaN ## AC233755.2 0 NaN Inf NaN NaN NaN ## AC233755.1 0 NaN Inf NaN NaN NaN ## AC213203.1 0 NaN Inf NaN NaN NaN ## FAM231B 0 NaN Inf NaN NaN NaN 7.8 Varianza de los log-counts vs coeficiente de variaci√≥n Generalmente se usa la varianza de los log-counts Ambas son medidas efectivas para cuantificar la variaci√≥n en la expresi√≥n g√©nica CV2 tiende a tener otorgar rangos altos a genes altamente variables (HGVs) con bajos niveles de expresi√≥n √âstos son dirigidos por una sobreregulaci√≥n en subpoblaciones raras Puede asignar un alto rango a genes que no son de nuestro inter√©s con varianza baja absoluta La variaci√≥n descrita por el CV2 de las cuentas es menos relevante para los procedimientos que operan en los log-counts 7.9 Cuantificando el ruido t√©cnico Previamente, ajustamos una l√≠nea de tendencia a todos los genes end√≥genos y asumimos que la mayor√≠a de los genes no est√°n dominados por ruido t√©cnico En la pr√°ctica, todos los genes expresados tienen alg√∫n nivel de variabilidad biol√≥gica diferente de cero (e.g., transcriptional bursting) Esto sugiere que nuestros estimados de los componentes t√©cnicos estar√°n inflados probablemente üëâ Es mejor que pensemos estos estimados como una variaci√≥n t√©cnica m√°s la variaci√≥n biol√≥gica que no es interesante ü§î Pero que tal si un grupo de genes a una abundancia particular es afectado por un proceso biol√≥gico? E.g., fuerte sobre regulaci√≥n de genes espec√≠ficos de un tipo celular podr√≠an conllevar a un enriquecimiento de HVGs en abundancias altas. Esto inflar√≠a la tendencia y compromete la detecci√≥n de los genes relevantes ¬øC√≥mo podemos evitar este problema? Podemos revisar dos enfoques: Cuando tenemos spike-ins Cuando no tenemos spike-ins 7.9.1 En la presencia de spike-ins dec.spike.416b &lt;- modelGeneVarWithSpikes( sce.416b, &quot;ERCC&quot; ) # Ordering by most interesting genes for # inspection. dec.spike.416b[order(dec.spike.416b$bio, decreasing = TRUE ), ] ## DataFrame with 46604 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Lyz2 6.61097 13.8497 1.57131 12.2784 1.48993e-186 1.54156e-183 ## Ccl9 6.67846 13.1869 1.50035 11.6866 2.21856e-185 2.19979e-182 ## Top2a 5.81024 14.1787 2.54776 11.6310 3.80016e-65 1.13040e-62 ## Cd200r3 4.83180 15.5613 4.22984 11.3314 9.46221e-24 6.08574e-22 ## Ccnb2 5.97776 13.1393 2.30177 10.8375 3.68706e-69 1.20193e-66 ## ... ... ... ... ... ... ... ## Rpl5-ps2 3.60625 0.612623 6.32853 -5.71590 0.999616 0.999726 ## Gm11942 3.38768 0.798570 6.51473 -5.71616 0.999459 0.999726 ## Gm12816 2.91276 0.838670 6.57364 -5.73497 0.999422 0.999726 ## Gm13623 2.72844 0.708071 6.45448 -5.74641 0.999544 0.999726 ## Rps12l1 3.15420 0.746615 6.59332 -5.84670 0.999522 0.999726 üëâ Ajusta la tendencia solo con los spike-ins (que deber√≠an estar afectados solamente por variaci√≥n t√©cnica) plot(dec.spike.416b$mean, dec.spike.416b$total, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) fit.spike.416b &lt;- metadata(dec.spike.416b) points(fit.spike.416b$mean, fit.spike.416b$var, col = &quot;red&quot;, pch = 16 ) curve(fit.spike.416b$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2 ) 7.10 En la ausencia de spike-ins set.seed(0010101) dec.pois.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) # Ordering by most interesting genes for inspection. dec.pois.pbmc[order(dec.pois.pbmc$bio, decreasing = TRUE), ] ## DataFrame with 33694 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## LYZ 1.95605 5.05854 0.631190 4.42735 0 0 ## S100A9 1.93416 4.53551 0.635102 3.90040 0 0 ## S100A8 1.69961 4.41084 0.671491 3.73935 0 0 ## HLA-DRA 2.09785 3.75174 0.604448 3.14730 0 0 ## CD74 2.90176 3.36879 0.444928 2.92386 0 0 ## ... ... ... ... ... ... ... ## ATP5J 0.614027 0.454754 0.502701 -0.0479473 0.943718 1.000000 ## NEDD8 0.841407 0.561295 0.609895 -0.0486003 0.907530 0.997441 ## NDUFA1 0.860049 0.560222 0.616330 -0.0561074 0.935049 1.000000 ## SAP18 0.763057 0.515764 0.578890 -0.0631264 0.965173 1.000000 ## SUMO2 1.359514 0.619811 0.693247 -0.0734360 0.960991 1.000000 üëâ Realiza algunas asunciones estad√≠sticas acerca del ruido ü§ì Las cuentas UMI t√≠picamente muestran una variaci√≥n cercana a Poisson si solo consideramos ruido t√©cnico de la preparaci√≥n de las librer√≠as y la secuenciaci√≥n ‚ö†Ô∏è modelGeneVarByPoisson() realiza simulaciones, por lo que necesitamos ‚Äúajustar la ‚Äúsemilla‚Äù para obtener resultados reproducibles ü§ì modelGeneVarByPoisson() pueden tambi√©n simular una variaci√≥n binomial negativa (variaci√≥n de Poisson sobredispersada) plot(dec.pois.pbmc$mean, dec.pois.pbmc$total, pch = 16, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) curve(metadata(dec.pois.pbmc)$trend(x), col = &quot;dodgerblue&quot;, add = TRUE ) ü§ì La l√≠nea de tendencia basada puramente en ruido t√©cnico tiende a producir componentes ‚Äúbiol√≥gicos‚Äù m√°s grandes por los genes altamente expresados, que frecuentemente incluyen los genes ‚Äúhouse-keeping‚Äù ü§î Necesitas considerar si tales genes son ‚Äúinteresantes‚Äù o no en tu dataset de inter√©s 7.11 Recordemos propiedades de los datos de sce.416b Este dataset consiste de c√©lulas de una l√≠nea celular de c√©lulas inmortalizadas mieloides progenitoras de rat√≥n utilizando SmartSeq2 Una cantidad constante de spike-in ERCC RNA se agreg√≥ a cada lisado celular antes de la prepataci√≥n de la librer√≠a Descripci√≥n aqu√≠ Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., G√∂ttgens, B. &amp; Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795‚Äì1806 (2017) 7.12 Considerando factores experimentales Los datos que contienen m√∫ltiples batches muy seguido presentan efecto de bloque que pueden crear HGVs artificiales Se debe identificar los HGVs en cada batch y combinarlos en una √∫nica lista de HGVs # calculando la variacion por bloque dec.block.416b &lt;- modelGeneVarWithSpikes(sce.416b, &quot;ERCC&quot;, block = sce.416b$block ) dec.block.416b[order( dec.block.416b$bio, decreasing = TRUE ), ] ## DataFrame with 46604 rows and 7 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Lyz2 6.61235 13.8619 1.58416 12.2777 0.00000e+00 0.00000e+00 ## Ccl9 6.67841 13.2599 1.44553 11.8143 0.00000e+00 0.00000e+00 ## Top2a 5.81275 14.0192 2.74571 11.2734 3.89855e-137 8.43398e-135 ## Cd200r3 4.83305 15.5909 4.31892 11.2719 1.17783e-54 7.00721e-53 ## Ccnb2 5.97999 13.0256 2.46647 10.5591 1.20380e-151 2.98405e-149 ## ... ... ... ... ... ... ... ## Gm12816 2.91299 0.842574 6.67730 -5.83472 0.999989 0.999999 ## Gm5786 2.90717 0.879485 6.71686 -5.83738 0.999994 0.999999 ## Rpl9-ps4 3.26421 0.807057 6.64932 -5.84226 0.999988 0.999999 ## Gm13623 2.72788 0.700296 6.63875 -5.93845 0.999998 0.999999 ## Rps12l1 3.15425 0.750775 6.70033 -5.94955 0.999995 0.999999 ## per.block ## &lt;DataFrame&gt; ## Lyz2 6.35652:13.3748:2.08227:...:6.86819:14.3490:1.08605:... ## Ccl9 6.68726:13.0778:1.65923:...:6.66956:13.4420:1.23184:... ## Top2a 5.34891:17.5972:3.91642:...:6.27659:10.4411:1.57501:... ## Cd200r3 4.60115:15.7870:5.55587:...:5.06496:15.3948:3.08197:... ## Ccnb2 5.56701:15.4150:3.46931:...:6.39298:10.6362:1.46362:... ## ... ... ## Gm12816 2.86995:0.624143:7.43036:...:2.95604:1.061004:5.92424:... ## Gm5786 2.96006:0.902872:7.49911:...:2.85427:0.856098:5.93462:... ## Rpl9-ps4 3.60690:0.543276:7.36805:...:2.92151:1.070839:5.93058:... ## Gm13623 2.83129:0.852901:7.39442:...:2.62447:0.547692:5.88308:... ## Rps12l1 3.14399:0.716670:7.57246:...:3.16452:0.784881:5.82819:... Al calcular tendencias espec√≠ficas por batch se tomar√°n en cuenta las diferencias en la relaci√≥n media-varianza entre batches Se deben obtener estimados de los componentes biol√≥gico y t√©cnico para cada gene espec√≠ficos de cada batch, los cuales se promedian entre los batches para crear una √∫nica lista de HVGs Factor experimental. 7.13 Seleccionando genes altamante variables (high-variable genes, HVGs) Hasta ahora hemos ordenado los genes del m√°s al menos interesantemente variable ¬øQu√© tanto debemos de bajar en la lista para seleccionar nuestros HVGs? Para responder esta pregunta debemos tomar en cuenta lo siguiente: elegir un subset m√°s grande: Reduce el riesgo de desechar se√±al biol√≥gica Incrementa el ruido por la inclusi√≥n de genes irrelevantes Es dif√≠cil determinar el balance √≥ptimo porque el rudio en un contexto podr√≠a ser una se√±al √∫til en otro contexto Discutiremos algunas estrategias para seleccionar HVGs 7.13.1 Seleccionando HVGs sobre la m√©trica de varianza La estrategia m√°s simple es seleccionar los top-X genes con los valores m√°s grandes para la m√©trica relevante de varianza, por ejemplo, la varianza biol√≥gica m√°s grande calculada con scran::modelGeneVar() Pro: El usuario puede controlar directamente el n√∫mero de HVGs Contra: ¬øQu√© valor de X se debe usar? # Works with modelGeneVar() output hvg.pbmc.var &lt;- getTopHVGs(dec.pbmc, n = 1000) str(hvg.pbmc.var) ## chr [1:1000] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var &lt;- getTopHVGs(dec.spike.416b, n = 1000) str(hvg.416b.var) ## chr [1:1000] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` hvg.pbmc.cv2 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, n = 1000 ) str(hvg.pbmc.cv2) ## chr [1:1000] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.1.1 Estrategias para seleccionar X Asume que, por ejemplo, no m√°s del 5% de los genes est√°n diferencialmente expresados entre las c√©lulas de nuestra poblaci√≥n: Establece X como el 5% de los genes Normalmente no conocemos el n√∫mero de genes diferencialmente expresados desde antes, por lo tanto, solo hemos cambiado un n√∫mero arbitrario por otro n√∫mero arbitrario RECOMENDACI√ìN: Si decides utilizar los top-X HGVs, elige un valor de X y procede con el resto del an√°lisis con la intenci√≥n de regresar m√°s adelante y probar otros valores, en vez de dedicarle mucho esfuerzo a encontrar el valor √≥ptimo 7.13.2 Seleccionando HVGs de acuerdo a su significancia estad√≠stica Establece un l√≠mite fijo en alguna m√©trica de significancia estad√≠stica. Por ejemplo: algunos de los m√©todos reportan un p-valor para cada gene, entonces selecciona todos los genes con un p-valor ajustado menor que 0.05 Recuerda que las pruebas estad√≠sticas siempre dependen del tama√±o de la muestra Ventajas: * F√°cil de implementar * Menos predecible que la estrategia de los top-X Desventajas: * Podr√≠a priorizar genes con significancia estad√≠stica fuerte en vez de significancia biol√≥gica fuerte # Works with modelGeneVar() output hvg.pbmc.var.2 &lt;- getTopHVGs(dec.pbmc, fdr.threshold = 0.05) str(hvg.pbmc.var.2) ## chr [1:813] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var.2 &lt;- getTopHVGs(dec.spike.416b, fdr.threshold = 0.05 ) str(hvg.416b.var.2) ## chr [1:2568] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` hvg.pbmc.cv2.2 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, fdr.threshold = 0.05 ) str(hvg.pbmc.cv2.2) ## chr [1:1972] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.3 Seleccionando genes por arriba de la tendencia media-varianza Selecciona todos los genes con una varianza biol√≥gica positiva Este es un extremo del equilibrio sesgo-varianza que minimiza el sesgo con el costo de maximizar el ruido Si seguimos esta aproximaci√≥n, estamos: D√°ndole a la estructura secundaria de la poblaci√≥n una oportunidad de manifestarse Capturando m√°s ruido, lo cual puede reducir la resoluci√≥n de poblaciones bien separadas enmascarando la se√±al secundaria que intentamos preservar Funciona mejor si tenemos datasets altamente heterogeneos que contienen muchos tipos celulares diferentes # Works with modelGeneVar() output hvg.pbmc.var.3 &lt;- getTopHVGs(dec.pbmc, var.threshold = 0) str(hvg.pbmc.var.3) ## chr [1:12745] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... # Works with modelGeneVarWithSpikes() output hvg.416b.var.3 &lt;- getTopHVGs(dec.spike.416b, var.threshold = 0 ) str(hvg.416b.var.3) ## chr [1:11087] &quot;Lyz2&quot; &quot;Ccl9&quot; &quot;Top2a&quot; &quot;Cd200r3&quot; &quot;Ccnb2&quot; &quot;Gm10736&quot; &quot;Hbb-bt&quot; ... # Also works with modelGeneCV2() but note `var.field` and # value of `var.threshold` hvg.pbmc.cv2.3 &lt;- getTopHVGs(dec.cv2.pbmc, var.field = &quot;ratio&quot;, var.threshold = 1 ) str(hvg.pbmc.cv2.2) ## chr [1:1972] &quot;PPBP&quot; &quot;PRTFDC1&quot; &quot;HIST1H2AC&quot; &quot;FAM81B&quot; &quot;PF4&quot; &quot;GNG11&quot; ... 7.13.4 EJERCICIO: Dibujando los HVGs Para este ejercicio tendr√°s que repetir la gr√°fica que muestra la tendencia de la relaci√≥n media-varianza (ejeX: media de la expresi√≥n, ejeY: varianza de la expresi√≥n) incluyendo la l√≠nea de tendencia obtenida con alguna de las funciones vistas en la primer parte de la clase (modelGeneVar, modelGeneVarWithSpikes, modelGeneCV2). En esta gr√°fica, deber√°s colorear los puntos que corresponden a los HGVs obtenidos con algunos de los enfoques revisados RESPUESTA plot(fit.pbmc$mean, fit.pbmc$var, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) points(fit.pbmc$mean[hvg.pbmc.var], fit.pbmc$var[hvg.pbmc.var], col = &quot;orange&quot;) curve(fit.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) 7.13.5 Seleccionando genes de inter√©s a priori Una estrategia contundente es usar sets predefinidos de genes de inter√©s. No hay verg√ºenza en aprovechar el conocimiento biol√≥givo previo Sin embargo, limita nuestra capacidad de descubrir aspectos nuevos o inesperados de la variaci√≥n. Por lo tanto, considera esta como una estrategia complementaria a otros tipo de estrategias de selecci√≥n de HGVs Tambi√©n podr√≠as eliminar listas pre-definidas de genes: Genes de prote√≠nas ribosomales o genes mitocondriales son conocidos por encontrarse dentro de los genes m√°s variables y por interferir con an√°lisis posteriores Sin embargo, tampoco hay que pecar de prevacido, espera a que estos genes demuestren ser problem√°ticos para removerlos 7.14 Poniendo todo junto # Elegimos el 10% de los genes con con componente biologico de variacion mayor dec.pbmc &lt;- modelGeneVar(sce.pbmc) chosen &lt;- getTopHVGs(dec.pbmc, prop = 0.1) str(chosen) ## chr [1:1274] &quot;LYZ&quot; &quot;S100A9&quot; &quot;S100A8&quot; &quot;HLA-DRA&quot; &quot;CD74&quot; &quot;CST3&quot; &quot;TYROBP&quot; ... Despu√©s de esto tenemos varias opciones para imponer nuestra selecci√≥n de HGVs durante el resto del an√°lisis: Hacer un subset de SCE para quedarnos √∫nicamente con los HGVs Especificar los HGVs en funciones posteriores Magia (altExps) 7.14.1 Qued√°ndonos s√≥lo con los HGVs sce.pbmc.hvg &lt;- sce.pbmc[chosen, ] sce.pbmc.hvg ## class: SingleCellExperiment ## dim: 1274 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(1274): LYZ S100A9 ... TNNT1 TMEM55A ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): PRO: Te aseguras de que los m√©todos posteriores s√≥lo usen estos genes para sus c√°lculos CONTRA: Los genes no-HGVs son eliminados del nuevo objeto SingleCellExperiment, lo cual hace menos conveniente la interrogaci√≥n del dataset completo sobre genes que no son HGVs 7.14.2 Especificando los HGVs # Example of specifying HVGs in a downstream function # Performing PCA only on the chosen HVGs. library(scater) sce.pbmc &lt;- runPCA(sce.pbmc, subset_row = chosen) sce.pbmc ## class: SingleCellExperiment ## dim: 33694 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Mantiene el objeto SingleCellExperiment original y especifica los genes para usar en funciones posteriores mediante un argumento adicional como subset_row PRO: Es √∫til si el an√°lisis usa varios conjuntos de HGVs en diferentes pasos CONTRA: Podr√≠a ser inconveniente especificar repetidamente el mismo conjunto de HGVs en diferentes pasos 7.14.3 Witchcraft (Brujer√≠a) # Add the full SCE to the subsetted data SCE altExp(sce.pbmc.hvg, &quot;original&quot;) &lt;- sce.pbmc sce.pbmc.hvg ## class: SingleCellExperiment ## dim: 1274 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(1274): LYZ S100A9 ... TNNT1 TMEM55A ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(1): original altExp(sce.pbmc.hvg, &quot;original&quot;) ## class: SingleCellExperiment ## dim: 33694 3985 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B ## rowData names(2): ID Symbol ## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ... ## TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1 ## colData names(3): Sample Barcode sizeFactor ## reducedDimNames(1): PCA ## mainExpName: NULL ## altExpNames(0): Utilizando el sistema de ‚Äúexperimento alternartivo‚Äù en la clase SingleCellExperiment PRO: Evita algunos problemas a largo plazo cuando el dataset original no est√° sincronizado con el conjunto filtrado por HVGs CONTRA: Ralentiza todos los an√°lisis subsecuentes 7.15 Resumen y recomendaciones Es f√°cil atorarse en este paso debido a la variedad de opciones disponibles Elige un conjunto de HVGs y contin√∫a con el an√°lisis, recuerda regresar para probar la robustez de tus resultados usando una forma diferente para seleccionar los HVGs Si tienes spike-ins, trata de usarlos. No obstante, recuerda que los spike-ins no pueden capturar todas las fuentes de variaci√≥n t√©cnica 7.16 Recomendaciones para empezar Para CEL-Seq2: scran::modelGeneVarWithSpikes() Para 10X: scran::modelGeneVarByPoisson() Si quieres irte por el lado de conservar demasiados genes: scran::getTopHVGs(dec, var.threshold=0) Y realiza una comparaci√≥n r√°pida con, por lo menos, el top-1000 HVGs Regresa al paso de selecci√≥n de HVG para eliminar genes problem√°ticos tantas veces como sea necesario 7.17 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:24:40 UTC&quot; proc.time() ## user system elapsed ## 144.102 4.190 147.148 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al.¬†Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).‚Ü©Ô∏é Usando Ensembl v86 para humano‚Ü©Ô∏é Usamos los resultados de emptyDrops() con un l√≠mite de 0.1% FDR y el filtro de 3 desviaciones sobre la mediana (MAD) en la expresi√≥n mitocondrial.‚Ü©Ô∏é Encontramos unos clusters r√°pidos para las c√©lulasy usamos esa informaci√≥n para calcular los factores de tama√±o.‚Ü©Ô∏é Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., G√∂ttgens, B. &amp; Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795‚Äì1806 (2017)).‚Ü©Ô∏é Es un DFrame‚Ü©Ô∏é No, contiene m√°s informaci√≥n dentro de metadata(dec.pbmc)‚Ü©Ô∏é class(metadata(dec.pbmc)) y sapply(metadata(dec.pbmc), class)‚Ü©Ô∏é Una funci√≥n‚Ü©Ô∏é Checa ?fitTrendVar y si quieres tambi√©n checa el c√≥digo fuente (para m√≠ es muy √∫til este paso) https://github.com/MarioniLab/scran/blob/master/R/fitTrendVar.R‚Ü©Ô∏é "],["reducci√≥n-de-dimensiones.html", "8 Reducci√≥n de dimensiones 8.1 Diapositivas de Peter Hickey 8.2 Motivaci√≥n 8.3 Reducci√≥n de dimensionalidad 8.4 Dataset ilustrativo: Zeisel 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas 8.6 An√°lisis de Componentes Principales 8.7 Reducci√≥n de dimensionalidad para visualizaci√≥n 8.8 Donde estamos 8.9 Detalles de la sesi√≥n de R Patrocinadores", " 8 Reducci√≥n de dimensiones Instructora: Laura G√≥mez-Romero 8.1 Diapositivas de Peter Hickey Contenido adaptado de: aqu√≠ 8.2 Motivaci√≥n El siguiente paso en el an√°lisis de scRNA-seq usualmente consiste en identificar grupos de c√©lulas ‚Äúsimilares‚Äù Por ejemplo: un an√°lisis de clustering busca identificar c√©lulas con un perfil transcript√≥mico similar al calcular distancias entre ellas Si tuvi√©ramos un dataset con dos genes podr√≠amos hacer una gr√°fica de dos dimensiones para identificar clusters de c√©lulas Pero‚Ä¶ tenemos decenas de miles de genes : Reducci√≥n de dimensionalidad 8.3 Reducci√≥n de dimensionalidad Es posible porque la expresi√≥n de diferentes genes estar√≠a correlacionada si estos genes son afectados por el mismo proceso biol√≥gico. Por lo tanto, no necesitamos almacenar informaci√≥n independiente para genes individuales. Podemos comprimir m√∫ltiples ‚Äúfeatures‚Äù (genes) en una √∫nica dimensi√≥n. Ventajas: Reduce trabajo computacional en an√°lisis posteriores Reduce el ruido al ‚Äúpromediar‚Äù m√∫tiples genes obteniendo una representaci√≥n m√°s precisa de los patrones en los datos Permite una graficaci√≥n efectiva en dos dimensiones 8.4 Dataset ilustrativo: Zeisel library(scRNAseq) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) # Estos datos contienen tipos celulares previamente anotados table(sce.zeisel$level1class) ## ## astrocytes_ependymal endothelial-mural interneurons ## 224 235 290 ## microglia oligodendrocytes pyramidal CA1 ## 98 820 939 ## pyramidal SS ## 399 Estudio de tipos celulares en el cerebro de rat√≥n (oligodendrocitos, microglia, neuronas, etc) procesados con el sistema STRT-seq (similar a CEL-Seq) Descripci√≥n aqu√≠ Zeisel, A. et al.¬†Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq. Science 347, 1138-1142 (2015) # Quality control # Descartar celulas con alto contenido mitocondrial o con alto porcentaje de spike-ins library(scater) is.mito &lt;- which(rowData(sce.zeisel)$featureType == &quot;mito&quot;) stats &lt;- perCellQCMetrics(sce.zeisel, subsets = list(Mt = is.mito) ) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;altexps_ERCC_percent&quot;, &quot;subsets_Mt_percent&quot;) ) sce.zeisel &lt;- sce.zeisel[, !qc$discard] # normalization # encontramos unos clusters r√°pidos para las c√©lulas y usamos esa informaci√≥n para calcular los factores de tama√±o library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.zeisel) sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster = clusters ) sce.zeisel &lt;- logNormCounts(sce.zeisel) # variance-modelling dec.zeisel &lt;- modelGeneVarWithSpikes( sce.zeisel, &quot;ERCC&quot; ) top.zeisel &lt;- getTopHVGs(dec.zeisel, n = 2000) ¬øC√≥mo se est√° modelando la relaci√≥n media varianza? ¬øC√≥mo se est√°n obteniendo los HGVs? 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset ‚ÄúC√©lulas mononucleares humanas de sangre perif√©rica‚Äù de 10X Genomics Descripci√≥n aqu√≠ Zheng, G. X. Y. et al.¬†Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) ¬øC√≥mo se est√° modelando la relaci√≥n media varianza? ¬øC√≥mo se est√°n obteniendo los HGVs? 8.6 An√°lisis de Componentes Principales PCA es el arma principal de la reducci√≥n de dimensionalidad PCA descubre las combinaciones (lineales) de ‚Äúfeatures‚Äù que capturan la cantidad m√°s grande de variaci√≥n En un PCA, la primer combinaci√≥n lineal (componente principal) se elige tal que permite capturar la mayor varianza a trav√©s de las c√©lulas. El siguiente PC se elige tal que es ‚Äúortogonal‚Äù al primero y captura la cantidad m√°s grande de la variaci√≥n restante, y as√≠ sucesivamente‚Ä¶ 8.6.1 PCA aplicado a datos de scRNA-seq Podemos realizar reducci√≥n de dimensionalidad al aplicar PCA en la matriz de cuentas transformadas (log-counts matrix) y restringiendo los an√°lisis posteriores a los primeros PCs (top PCs) Esto puede reducir nuestro dataset de 20,000 dimensiones a, digamos, 10, sin perder demasiada informaci√≥n La t√©cnica de PCA tiene muchas propiedades te√≥ricas bien estudiadas. Hay varias formas r√°pidas de realizar PCA en datasets grandes. 8.6.2 Suposiciones de PCA aplicadas a los datos de scRNA-seq Los procesos biol√≥gicos afectan m√∫ltiples genes en una manera coordinada Los primeros PCs probablemente representan la estructura biol√≥gica dado que m√°s variaci√≥n puede ser capturada considerando el comportamiento correlacionado de muchos genes Se espera que el ruido t√©cnico azaroso afecte cada gen independientemente Consideraci√≥n: Los primeros PCs capturar√≥n ‚Äúbatch effects‚Äù (efectos de lote) que afectan muchos genes en una manera coordinada library(scran) library(scater) set.seed(100) sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel ) ¬øEstamos corriendo el an√°lisis sobre todos los genes de nuestro dataset? Por default, runPCA() usa un m√©todo r√°pido aproximado que realiza simulaciones, por lo tanto, es necesario ‚Äòconfigurar la semilla‚Äô para obtener resultados reproducibles 8.6.3 Eligiendo el n√∫mero de PCs Esta elecci√≥n en an√°loga a la elecci√≥n del numero de HVGs. Elegir m√°s PCs evitar√° descartar se√±al biol√≥gica a expensas de retener m√°s ruido Es com√∫n seleccionar un n√∫mero de PCs ‚Äúrazonable‚Äù pero arbitrario (10-50), continuar con el an√°lisis y regresar para checar la robustez de los resultados en cierto rango de valores Ahora exploraremos algunas estrategias guiadas por los datos (data-driven) para hacer esta selecci√≥n 8.6.3.1 Usando el punto del codo library(PCAtools) percent.var &lt;- attr(reducedDim(sce.zeisel), &quot;percentVar&quot;) chosen.elbow &lt;- PCAtools::findElbowPoint(percent.var) plot(percent.var, xlab = &quot;PC&quot;, ylab = &quot;Variance explained (%)&quot;) abline(v = chosen.elbow, col = &quot;red&quot;) Una heur√≠stica simple es elegir el n√∫mero de PCs basado en el porcentaje de varianza explicado por PCs sucesivos 8.6.3.2 Basados en la estructura de la poblaci√≥n choices &lt;- getClusteredPCs(reducedDim(sce.zeisel)) chosen.clusters &lt;- metadata(choices)$chosen plot(choices$n.pcs, choices$n.clusters, xlab = &quot;Number of PCs&quot;, ylab = &quot;Number of clusters&quot; ) abline(a = 1, b = 1, col = &quot;red&quot;) abline(v = chosen.clusters, col = &quot;grey80&quot;, lty = 2) Esta es una aproximaci√≥n heur√≠stica m√°s sofisticada que usa el n√∫mero de clusters como un proxy del n√∫mero de subpoblaciones Supongamos que esperamos d subpoblaciones de c√©lulas, en ese caso, necesitamos d-1 dimensiones para garantizar la separaci√≥n de todas las subpoblaciones Pero‚Ä¶ en un escenario real realmente no sabes cu√°ntas poblaciones hay‚Ä¶ Intenta con un rango para d y √∫nicamente considera valores que produzcan a lo m√°s d+1 clusters Cuando se seleccionan m√°s clusters con menos dimensiones se produce ‚Äòoverclustering‚Äô Elige una d que maximice el n√∫mero de clusters sin caer en ‚Äòoverclustering‚Äô Ventaja: Es una soluci√≥n pragm√°tica que soluciona el equilibrio sesgo-varianza en los an√°lisis posteriores (especialmente clustering) Desventaja: Hace suposiciones fuertes sobre la naturaleza de las diferencias biol√≥gicas entre los clusters, y de hecho supone la existencia de clusters, los cuales podr√≠an no existir en procesos biol√≥gicos como la diferenciaci√≥n 8.6.4 Juntando todo set.seed(100) # Compute and store the &#39;full&#39; set of PCs sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel) # Can also select d and store the reduced set of PCs # e.g., using the elbow point reducedDim(sce.zeisel, &quot;PCA_elbow&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.elbow] # e.g., based on population structure reducedDim(sce.zeisel, &quot;PCA_clusters&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.clusters] 8.6.5 EJERCICIO Realiza un PCA para los datos sce.pbmc. Elige el n√∫mero de PCs a conservar utilizando el m√©todo del codo Elige el n√∫mero de PCs a conservar utilizando la estructura de la poblaci√≥n Agrega esta informaci√≥n al objeto sce.pbmc 8.6.6 Usando el ruido t√©cnico library(scran) set.seed(111001001) denoised.pbmc &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc, subset.row = top.pbmc ) Conserva todos los PCs hasta que el % de variaci√≥n explicado alcance algun l√≠mite (por ejemplo, basado en la estimaci√≥n de la variaci√≥n t√©cnica) denoisePCA() autom√°ticamente selecciona el n√∫mero de PCs Por default, denoisePCA() realiza algunas simulaciones, por lo tanto necesitamos ‚Äòconfigurar la semilla‚Äô para obtener resultados reproducibles dim(reducedDim(denoised.pbmc, &quot;PCA&quot;)) ## [1] 3985 9 La dimensionalidad del output es el l√≠mite inferior para el n√∫mero de PCs requeridos para explicar toda la variaci√≥n biol√≥gica. Lo que significa que cualquier n√∫mero menor de PCs definitivamente descartar√° alg√∫n aspecto de la se√±al biol√≥gica Esto no grantiza que los PCs retenidos capturen toda la se√±al biol√≥gica Esta t√©cnica usualmente retiene m√°s PCs que el m√©todo del punto del codo scran::denoisePCA() internamente limita el numero de PCs, por default 5-50, para evitar la selecci√≥n de excesivamente pocos PCs (cuando el ruido t√©cnico es alto relativo al ruido biol√≥gico) o excesivamente muchos PCs (cuando el ruido t√©cnico es demasiado bajo) 8.6.6.1 ¬øQu√© pasa si calculamos la relaci√≥n media-varianza con la funci√≥n modelGeneVar para el dataset sce.pbmc? dec.pbmc2 &lt;- modelGeneVar(sce.pbmc) denoised.pbmc2 &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc2, subset.row = top.pbmc ) dim(reducedDim(denoised.pbmc2)) ## [1] 3985 5 scran::denoisePCA() tiende a funcionar mejor cuando la relaci√≥n media-varianza refleja el ruiudo t√©cnico verdadero, i.e estimado por scran::modelGeneVarByPoisson() o scran::modelGeneVarWithSpikes() en vez de scran::modelGeneVar() El dataset PBMC est√° cerca de este l√≠mite inferior: el ruido t√©cnico es alto relativo al ruido biol√≥gico 8.6.6.2 ¬øQu√© pasa si calculamos el n√∫mero de PCs usando el ruido t√©cnico para el dataset sce.pbmc? set.seed(001001001) denoised.zeisel &lt;- denoisePCA(sce.zeisel, technical = dec.zeisel, subset.row = top.zeisel ) dim(reducedDim(denoised.zeisel)) ## [1] 2815 50 Los datos de cerebro de Zeisel est√°n cerca de este l√≠mite superior: el ruido t√©cnico es demasiado bajo 8.7 Reducci√≥n de dimensionalidad para visualizaci√≥n 8.7.1 Motivaci√≥n Clustering y otros algoritmos operaran f√°cilmente sobre 10-50 (a lo m√°s) PCs, pero ese n√∫mero es a√∫n demasiado para la visualizaci√≥n Por lo tanto, necesitamos estrategias adicionales para la reducci√≥n de dimensionalidad si queremos visualizar los datos 8.7.2 Visualizando con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, colour_by = &quot;level1class&quot; ) PCA es una t√©cnica lineal, por lo tanto, no es eficiente para comprimir diferencias en m√°s de 2 dimensiones en los primeros 2 PCs 8.7.3 Retos y resumen de la visualizaci√≥n con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, ncomponents = 4, colour_by = &quot;level1class&quot; ) Ventajas: PCA es predecible y no introducir√° estructura aritficial en los datos Es determ√≠nistico y robusto a cambios peque√±os en los valores de entrada Desventajas: Usualmente no la visualizaci√≥n no es suficiente para visualizar la naturaleza compleja de los datos de scRNA-seq 8.7.4 Visualizaci√≥n con t-SNE set.seed(00101001101) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) t-stochastic neighbour embedding (t-SNE) es la visualizaci√≥n por excelencia de datos de scRNA-seq. Intenta encontrar una representaci√≥n (no-lineal) de los datos usando pocas dimensiones que preserve las distancias entre cada punto y sus vecinos en el espacio multi-dimensional 8.7.4.1 Retos de la visualizaci√≥n con t-SNE set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 30 ) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot; ) 8.7.4.2 Preguntas ¬øQu√© pasa si vuelves a correr runTSNE() sin especificar la semilla? ¬øQu√© pasa si especificas la semilla pero cambias el valor del par√°metro perplexity? 8.7.4.3 Continuando Baja perplejidad favorece la resoluci√≥n de la estructura fina, posiblemente al grado de que la visualizaci√≥n parece rudio random. set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 5) p1 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 20) p2 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 80) p3 &lt;- plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) library(&quot;patchwork&quot;) p1 + p2 + p3 El siguiente foro discute la selecci√≥n de par√°metros para t-SNE con cierta profundidad No sobreinterpretes los resultados de t-SNE como un ‚Äòmapa‚Äô de las identidades de las c√©lulas individuales Algunos componentes aleatorios y la selecci√≥n de par√°metros cambiar√°n la visualizaci√≥n La interpretaci√≥n puede ser enga√±ada por el tama√±o y posici√≥n de los clusters t-SNE infla clusters densos y comprime clusters escasos t-SNE no est√° obligado a preservar las localizaciones relativas de clusters no-vecinos (no puedes interpretar distancias no locales) A√∫n as√≠: t-SNE es una herramienta probada para visualizaci√≥n general de datos de scRNA-seq y sigue siendo muy popular 8.7.5 Visualizaci√≥n con UMAP Uniform manifold approximation and project (UMAP) es una alternativa a t-SNE As√≠ como t-SNE, UMAP intenta encontrar una representaci√≥n (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional t-SNE y UMAP est√°n basados en diferentes teor√≠as matem√°ticas set.seed(1100101001) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) Comparado con t-SNE: UMAP tiende a encontrar clusters visualmente m√°s compactos Intenta preservar m√°s de la estructura global que t-SNE Tiende a ser m√°s r√°pido que t-SNE, lo cual puede ser importante para datasets grandes. La diferencia desaparece cuando se aplican sobre los primeros PCs 8.7.5.1 Retos de la visualizaci√≥n con UMAP set.seed(100) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;, n_neighbors = 15 ) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) 8.7.5.2 Preguntas ¬øQu√© pasa si vuelves a correr runUMAP() sin especificar la semilla? ¬øQu√© pasa si especificas la semilla pero cambias el valor del par√°metro n_neighbors? 8.7.5.3 Continuando Igual que para t-SNE, es necesario configurar una semilla y diferentes valores para los par√°metros cambiar√≥n la visualizaci√≥n Si el valor para los par√°metros n_neighbors o min_dist es demasiado bajo entonces el ruido aleatorio se interpretar√° como estructura de alta-resoluci√≥n, si son demasiado altos entonces se perder√° la estructura fina TIP: Trata un rango de valores para cada par√°metro para asegurarte de que no comprometen ninguna de las conclusiones derivadas de la gr√°fica UMAP o t-SNE 8.7.6 Interpretando las gr√°ficas Recuerda: Reducci√≥n de dimensionalidad para la visualizaci√≥n de los datos necesariamente involucra descartar informaci√≥n y distorsionar las distancias entre las c√©lulas No sobre interpretes las gr√°ficas bonitas 8.7.7 Resumen y recomendaciones Las gr√°ficas de t-SNE y UMAP son herramientas diagn√≥stico importantes, por ejemplo: para checar si dos clusters son realmente subclusters vecinos o si un cluster puede ser dividido en m√°s de un cluster Es debatible cual visualizaci√≥n, t-SNE o UMAP, es m√°s √∫til o est√°ticamente agradable. Est√° bien elegir aquella que funcione mejor para tu an√°lisis (tomando en cuenta que tratar√°s la gr√°fica √∫nicamente como una herramienta de visualizaci√≥n/diagn√≥stico y que no llegar√°s a ninguna conclusi√≥n fuerte basado √∫nicamente en la gr√°fica ) 8.8 Donde estamos 8.9 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:29:32 UTC&quot; proc.time() ## user system elapsed ## 290.224 6.757 291.613 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel * 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## PCAtools * 2.4.0 2021-05-19 [1] Bioconductor ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["clustering.html", "9 Clustering 9.1 Dataset ilustrativo: 10X PBMC4k no filtrado 9.2 Motivaci√≥n 9.3 ¬øPor qu√© no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? 9.4 ¬øCu√°l es el verdadero clustering? 9.5 Clustering basado en grafos 9.6 Evaluando la separaci√≥n de los clusters 9.7 Otros m√©todos de clustering 9.8 Evaluando la estabilidad de los clusters 9.9 Subclustering 9.10 Resumen y recomendaciones 9.11 Donde estamos 9.12 Detalles de la sesi√≥n de R Patrocinadores", " 9 Clustering Instructora: Laura G√≥mez-Romero Este contenido est√° basado en las diapositivas de Peter Hickey. Ve las diapositivas aqu√≠. Y en el curso de OSCA, lee el material aqu√≠ 9.1 Dataset ilustrativo: 10X PBMC4k no filtrado library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset de c√©lulas mononucleares de sangre perif√©rica humana (PBMC) de 10X Genomics Descripci√≥n aqu√≠ Zheng, G. X. Y. et al.¬†Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) # dimensionality-reduction set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) ¬øAlquien me puede explicar que hace el m√©todo que etamos usando para reducir la dimensionalidad de los datos? ¬øLos HGVs est√°n almacenados en nuestro objeto sce.pbmc? 9.2 Motivaci√≥n Clustering es un procedimiento no supervisado par definir grupos de c√©lulas con perfiles de expresi√≥n similares Su prop√≥sito principal es resumir los datos en un formato digerido susceptible a interpretaci√≥n humana Nos permite asignar etiquetas (por ejemplo, tipos celulares) a las c√©lulas 9.3 ¬øPor qu√© no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? Las t√©cnicas de t-SNE/UMAP han comprimido datos altamente multi-dimensionales en dos dimensiones Esta compresi√≥n inevitablemente ha provocado la perdida de informaci√≥n Por lo tanto, agrupamos sobre los PCs y despu√©s visualizamos las identidades de los clusters en la gr√°fica t-SNE/UMAP 9.4 ¬øCu√°l es el verdadero clustering? Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que m√°s nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cu√°l es la mejor magnificaci√≥n en un microscopio sin contenido 9.5 Clustering basado en grafos 9.5.1 Antecedentes El clustering basado en grafos fue popularizado (m√°s no inventado) por su uso en Seurat Objetivo: Construir un grafo en el que cada nodo es una c√©lula que est√° conectada a sus vecinos m√°s cercanos en el espacio multidimensional 9.5.2 Gr√°fica de los k vecinos m√°s cercanos (k-nearest neighbour -KNN- graph) Ilustremos como funciona para 20 c√©lulas 9.5.3 Gr√°fica de los vecinos m√°s pr√≥ximos compartidos (SNN) De una gr√°fica KNN se puede construir una grafica SNN En este tipo de grago, dos c√©lulas estar√°n conectadas por una arista si comparten alguno de sus vecinos m√°s pr√≥ximos. Podemos asignar pesos a cada arista del grafo, bas√°ndonos en la similaridad de las c√©lulas involucradas, d√°ndole pesos m√°s altos a c√©lulas que est√°n m√°s cercanamente relacionadas 9.5.4 Gr√°fica SNN con pesos en las aristas Para ver los distintos esquemas de pesado puedes consultar la documentaci√≥n de la funci√≥n makeSNNGraph del paquete bluster. Algunos ejemplos son: -Rango: El peso entre dos nodos est√° dado por k-r/2 donde r es la suma m√°s peque√±a de los rangos (de proximidad, el vecino m√°s cercano tiene el rango 1) para cualquiera de los vecinos compartidos -N√∫mero: el peso entre dos nodos es igual al n√∫mero de vecinos m√°s pr√≥ximos compartidos -Jaccard: el peso entre dos nodos es igual a la similaridad de Jaccard entre los conjuntos de vecinos de estos nodos 9.5.5 Obteniendo comunidades a partir de una gr√°fica SNN pesada mediante un algoritmo de clustering A partir de una gr√°fica SNN pesada podemos aplicar algoritmos para identificar comunidades de c√©lulas Comunidades son grupos de c√©lulas que est√°n m√°s conectadas a c√©lulas en el mismo grupo que lo que est√°n a c√©lulas de un grupo diferente Cada comunidad representa un cluster 9.5.6 Resumen de clustering basado en grafos La construcci√≥n y b√∫squeda de una red KNN es r√°pida, por lo tanto, es escalable para datasets grandes Debes evitar obtener conclusiones fuertes acerca de la forma de los clusters o la distribuci√≥n de c√©lulas dentro de cada cluster El algoritmo, conecta cada c√©lula con un n√∫mero m√≠nimo de c√©lulas vecinas, lo cual reduce el riesgo de clusters no informativos con unos pocos outliers Despu√©s de la construcci√≥n del grafo, no se almacena informaci√≥n adicional m√°s alla de las c√©lulas vecinas. Esto puede producir subclusters artificiales en regiones con muchas c√©lulas 9.5.7 Detalles a considerar en la implementaci√≥n ¬øCu√°ntas c√©ulas vecinas debo considerar durante la construcci√≥n del grafo? ¬øC√≥mo debo pesar las aristas? ¬øCu√°l algoritmo de detecci√≥n de comunidades se debe usar para definir los clusters? 9.5.8 Implementaci√≥n library(scran) # Build graph using k = 10 nearest neighbours in PCA-space g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust &lt;- igraph::cluster_walktrap(g)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster &lt;- factor(clust) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) ¬øQu√© pasa si utilizas una k m√°s grande o m√°s peque√±a? library(scran) # Build graph using k = 50 nearest neighbours in PCA-space g50 &lt;- buildSNNGraph(sce.pbmc, k = 50, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust50 &lt;- igraph::cluster_walktrap(g50)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster50 &lt;- factor(clust50) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster50&quot;) En esta implementaci√≥n: La construcci√≥n de la red KNN se baso en la distancia Euclideana entre c√©lulas La construcci√≥n de la red KNN implica que las aristas se crean entre todos los pares de c√©lulas que comparten por lo menos un vecino Se utiliz√≥ el esquema de peso de: Xu and Su (2015) 9.5.9 Eligiendo un valor de k El valor de k puede ser toscamente interpretado como el tama√±o anticipado de la subpoblaci√≥n m√°s peque√±a Si una subpoblaci√≥n tiene menos que (k+1) c√©lulas entonces el m√©todo ser√° forzado a construir aristas entre c√©lulas de esa subpoblaci√≥n y c√©lulas de otras subpoblaciones Esto incrementa el riesgo de que la subpoblaci√≥n en cuesti√≥n no forme su propio cluster 9.5.10 Una implementaci√≥n diferente: estilo Seurat # Jaccard-based weights followed by Louvain clustering # aka &#39;Seurat-style&#39; clustering g2 &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) clust2 &lt;- igraph::cluster_louvain(g2)$membership sce.pbmc$cluster2 &lt;- factor(clust2) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) 9.5.11 Detalles de las implementaciones m√°s comunes Pipelines basados en Seurat: Pesos basados en Jacard Clustering Louvain Pipelines basados en Scran: Pesos basados en Randos Clustering Walktrap Para detalles sobre la seleccion de par√°metros y comparaciones: visitar esta p√°gina. library(&quot;patchwork&quot;) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) + plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) Estilo scran vs estilo Seurat. 9.5.12 Otras implementaciones Distintas m√©tricas de distancia g.num &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;, type = &quot;number&quot;) g.jaccard &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) g.none &lt;- buildKNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) Distintos m√©todos de clustering clust.louvain &lt;- igraph::cluster_louvain(g)$membership clust.infomap &lt;- igraph::cluster_infomap(g)$membership clust.fast &lt;- igraph::cluster_fast_greedy(g)$membership clust.labprop &lt;- igraph::cluster_label_prop(g)$membership clust.eigen &lt;- igraph::cluster_leading_eigen(g)$membership 9.6 Evaluando la separaci√≥n de los clusters Modularidad es una m√©trica natural para evaluar la separaci√≥n entre comunidades/clusters La modularidad se define como la diferencia (escalada) entre el peso total observado de las aristas entre los nodos en el mismo cluster y el peso total esperado si los pesos fueran distribuidos aleatoriamente entre todos los pares de nodos Nosotros calcularemos un score de modularidad para cada cluster usando las tasas en vez de las diferencias, debido a que las tasas no se ven tan fuertemente influenciadas por el tama√±o de los clusters library(bluster) # obteniendo la m√©trica de modularidad ratio &lt;- pairwiseModularity(g, clust, as.ratio = TRUE) dim(ratio) ## [1] 16 16 library(pheatmap) pheatmap(log2(ratio + 1), cluster_rows = FALSE, cluster_cols = FALSE, color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(100) ) Un dataset que contiene clusters bien separados deber√≠a contener la mayor√≠a del peso total observado en las entradas diagonales, i.e la mayor√≠a de las aristas ocurren entre c√©lulas del mismo cluster Para m√°s detalles sobre evaluaci√≥n de la separaci√≥n entre clusters visite esta p√°gina 9.7 Otros m√©todos de clustering Clustering por k-means PRO: R√°pido Se debe especificar el n√∫mero de clusters de antemano Favorece clusters esf√©ricos Clustering jer√°rquico Produce un dendograma (√°rbol) representando las c√©lulas y la similaridad entre subpoblaciones a varias resoluciones Demasiado lento para correrse en algo m√°s grande que los datasets m√°s peque√±os de scRNA-seq 9.8 Evaluando la estabilidad de los clusters Una propiedad deseable de un cluster dado es que √©ste sea estable a las perturbaciones en los datos de entrada, de esta manera: Peque√±os cambios al procesamiento no cambiar√°n el resultado Se incrementa la probabilidad de que las conclusiones puedan ser replicadas en un estudio independiente Uno puede hacer un proceso de bootstrap para evaluar la estabilidad de un algoritmo de clustering en un dataset dado y calcular la coasignaci√≥n. La coasignaci√≥n es la probabilidad de que c√©lulas elegidas al azar del cluster X y Y sean asignadas al mismo cluster en la r√©plica del proceso de bootstrap myClusterFUN &lt;- function(x) { g &lt;- buildSNNGraph(x, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) igraph::cluster_louvain(g)$membership } originals &lt;- myClusterFUN(sce.pbmc) set.seed(0010010100) coassign &lt;- bootstrapStability(sce.pbmc, FUN = myClusterFUN, clusters = originals ) pheatmap(coassign, cluster_row = FALSE, cluster_col = FALSE, color = rev(viridis::magma(100)) ) Probabilidad alta de coasignaci√≥n indica que X no es estable con respecto a su separaci√≥n de Y. Queremos altas probabilidades de coasignaci√≥n en la diagonal Debes considerar que el bootstraping solo considera el efecto del ruido de muestreo e ignora otros factores que pueden afectar la reproducibilidad (como efectos de batch o variaci√≥n entre los donadores) Adem√°s, una pobre separaci√≥n puede ser altamente estable 9.9 Subclustering Mejora la resoluc√≥n al repetir el proceso de feature selection y clustering dentro de un √∫nico cluster Se enfoca en los HGVs y PCs que son los m√°s relevantes para un cluster espec√≠fico g.full &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) clust.full &lt;- igraph::cluster_walktrap(g.full)$membership sce.pbmc$clust.full &lt;- factor(clust.full) plotExpression(sce.pbmc, features = c(&quot;CD3E&quot;, &quot;CCR7&quot;, &quot;CD69&quot;, &quot;CD44&quot;), x = &quot;clust.full&quot;, colour_by = &quot;clust.full&quot; ) CD3E, CCR7, CD69, y CD44 son marcadores de c√©lulas T de memoria. Dentro de las c√©lulas T de memoria, ¬ød√≥nde est√°n las subpoblaciones CD4+ y CD8+? # Repeating modelling and PCA on the subset of cells we have # identified as memory T-cells (cluster 6). memory &lt;- 10 sce.memory &lt;- sce.pbmc[, clust.full == memory] dec.memory &lt;- modelGeneVar(sce.memory) sce.memory &lt;- denoisePCA(sce.memory, technical = dec.memory, subset.row = getTopHVGs(dec.memory, prop = 0.1) ) # Repeating clustering on the subset. g.memory &lt;- buildSNNGraph(sce.memory, use.dimred = &quot;PCA&quot;) clust.memory &lt;- igraph::cluster_walktrap(g.memory)$membership sce.memory$clust.memory &lt;- factor(clust.memory) plotExpression(sce.memory, features = c(&quot;CD8A&quot;, &quot;CD4&quot;), x = &quot;clust.memory&quot; ) Expresi√≥n de CD4 es bajo, por lo tanto, su cambio es modesto, pero la interpretaci√≥n es clara scran::quickSubCluster() ciclar√° sobre los clusters y realizar√° el proceso de subclustering de acuerdo a una funci√≥n especificada por el usuario. Esto asume que la misma funci√≥n es apropiada para todos los clusters Si tipos celulares o estados celulares se extienden sobre las fronteras de los clusters, entonces un subcluster podr√≠a representar contaminaci√≥n de un tipo celular en un cluster separado 9.10 Resumen y recomendaciones Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que m√°s nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cu√°l es la mejor magnificaci√≥n en un microscopio sin contenido Clustering basado en grafos es r√°pido y evita tener que hacer suposiciones fuertes sobre la forma de los clusters o la distribuci√≥n de las c√©lulas dentro de cada cluster: scran::buildSNNGraph() igraph::cluster_walktrap() o igraph::cluster_louvain() Modularidad y estabilidad de los clusters son diagn√≥sticos √∫tiles El proceso de subclustering podr√≠a mejorar la resoluci√≥n dentro de clusters grandes 9.11 Donde estamos 9.12 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:33:26 UTC&quot; proc.time() ## user system elapsed ## 231.410 5.774 233.696 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster * 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["identificaci√≥n-de-genes-marcadores.html", "10 Identificaci√≥n de genes marcadores 10.1 Diapositivas de Peter Hickey 10.2 Motivaci√≥n 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.4 Motivaci√≥n - continuaci√≥n 10.5 Prueba t modificada de Welch pareada 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.7 Aplicaci√≥n est√°ndar 10.8 Usando el log-fold change 10.9 Encontrando marcadores espec√≠ficos de cl√∫steres 10.10 Pruebas alternas 10.11 Prueba de rangos de Wilcoxon 10.12 Prueba binomial 10.13 M√©todos de expresi√≥n diferencial personalizados 10.14 Problemas estad√≠sticos 10.15 Resumen y recomendaciones 10.16 Detalles de la sesi√≥n de R Patrocinadores", " 10 Identificaci√≥n de genes marcadores Instructora: Yalbi I. Balderas-Mart√≠nez. 10.1 Diapositivas de Peter Hickey Ver las diapositivas originales aqu√≠ 10.2 Motivaci√≥n Ahora que hemos obtenido los cl√∫steres, nos preguntamos, pero qu√© son? (e.g.¬†¬øqu√© tipo celular es el cl√∫ster 1?) ¬øCu√°les genes est√°n dirigiendo el agrupamiento (e.g., ¬øcu√°les son los genes diferencialmente expresados entre los cl√∫steres 1 y 2?) Idea: Mirar las diferencias en los perfiles de expresi√≥n de las c√©lulas de los diferentes cl√∫steres 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.3.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset ‚ÄúC√©lulas mononucleares humanas de sangre perif√©rica‚Äù de 10X Genomics Descripci√≥n aqu√≠ 21 10.3.2 Anotaci√≥n # Anotaci√≥n de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detecci√≥n de _droplets_ con c√©lulas set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 10.3.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalizaci√≥n de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 10.3.4 Genes variables ## Identificaci√≥n de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 10.3.5 Reducci√≥n de dimensiones ## Reducci√≥n de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 10.3.6 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 10.4 Motivaci√≥n - continuaci√≥n ¬øAlgunos de estos genes est√°n asociados con los resultados de clustering? # Is gene 1 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[1], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene 2 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[2], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene 2512 associated with the clustering? plotExpression(sce.pbmc, features = rownames(sce.pbmc)[2512], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) # Is gene CD3E associated with the clustering? plotExpression(sce.pbmc, features = &quot;CD3E&quot;, x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) Ver una gr√°fica como una forma de encontrar los genes marcadores obviamente no nos sirve a gran escala Necesitamos un m√©todo estad√≠stico para identificar estos genes marcadores üëâ La prueba t de Welch es una opci√≥n obvia para probar las diferencias en la expresi√≥n entre cl√∫steres 10.5 Prueba t modificada de Welch pareada ‚ûï R√°pidas y buenas propiedades estad√≠sticas para un gran n√∫mero de c√©lulas (Soneson and Robinson, 2018) ‚ûï Las comparaciones pareadas proveen un log-fold change para indicar cu√°les cl√∫sterse son distinguidos por cada gen ü§î ¬øPor qu√© no comparar cada cl√∫ster con el promedio de todas las otras c√©lulas? Sensible a la composici√≥n poblacional, una subpoblaci√≥n dominante sola que dirige la selecci√≥n de los marcadores top para cualquier otro cl√∫ster 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.6.1 Pruebas pareadas plotExpression(sce.pbmc, features = &quot;CD3E&quot;, x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) comparison logFC Pval 1 vs 2 1.50 1.7e-198 1 vs 3 -0.08 0.11 ‚Ä¶ ‚Ä¶ ‚Ä¶ 2 vs 1 1.39 1.7e-198 ‚Ä¶ ‚Ä¶ ‚Ä¶ 18 vs 17 0.11 0.46 K = 18 cl√∫steres K!/(K-2)! = 306 comparaciones La mitad de ellas son redundantes 10.6.2 Combinando comparaciones del gen CD3E para el cl√∫ster 1 ‚ÄúMe interesa saber si el gen CD3 est√° diferencialmente expresado entre el cl√∫ster 1 y ..‚Äù cualquier (any) otro cl√∫ster = P = 1.3 x 10-205 (Simes adjusted P-value) todos (all) los otros cl√∫steres = P = 0.11 (Berger‚Äôs intersection-union test) algunos (some) de los otros cl√∫steres = P = 2.0 x 10-44 (mediana u otro cuantil, Holm-adjusted P-values) 10.6.2.1 Extendiendo a todos los genes scran::pairwiseTTests() scran::combineMarkers() M = 33,694 genes ü§ì K x M = 10,310,364 pruebas Comparaciones involucrando cl√∫ster 1‚Ä¶ Comparaciones involucrando cl√∫ster ‚Ä¶ Comparaciones involucrando cl√∫ster 18 10.7 Aplicaci√≥n est√°ndar Para cada cl√∫ster, usar pruebas t de Welch para identificar los genes que est√°n diferencialmente expresados entre √©ste y cualquier (any) otro cl√∫ster # scran::findMarkers() library(scran) markers.pbmc &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, pval.type = &quot;any&quot; ) 10.7.1 Explorando los resultados chosen &lt;- &quot;9&quot; interesting &lt;- markers.pbmc[[chosen]] plotExpression(sce.pbmc, rownames(interesting)[1:4], x = &quot;cluster&quot;, colour_by = &quot;cluster&quot; ) 10.7.2 Con un heatmap best.set &lt;- interesting[interesting$Top &lt;= 6, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) library(pheatmap) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) üëâ Usamos el campo Top para identificar un conjunto de genes que distinguen el cl√∫ster 9 de cualquier otro cl√∫ster 10.8 Usando el log-fold change 10.8.1 Sin espeficiar el lfc Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados entre √©ste y cualquier otro cl√∫ster markers.pbmc.up &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.up &lt;- markers.pbmc.up[[chosen]] 10.8.2 Especificando el lfc Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados con un log-fold change (lfc) o al menos 1 entre √©ste y cualquier otro cl√∫ster markers.pbmc.up2 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, lfc = 1, pval.type = &quot;any&quot; ) interesting.up2 &lt;- markers.pbmc.up2[[chosen]] üëâ La prueba t tambi√©n nos permite especificar un log-fold change diferente de cero como la hip√≥tesis nula ü§ì Es m√°s riguroso que simplemente filtrar por log-fold change TREAT 10.8.3 Heatmap best.set &lt;- interesting.up2[interesting.up2$Top &lt;= 5, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) üëâ Los promedios est√°n m√°s centrados en un conjunto de genes marcadores candidatos que est√°n sobreexpresados en el cl√∫ster 9 ‚ö†Ô∏è El incremento del rigor no se da sin costo ‚ö†Ô∏è Si el lfc es muy grande podr√≠a descartar genes √∫tiles E.g., un gen sobreexpresado en una proporci√≥n peque√±a de c√©lulas en un cl√∫ster sigue siendo un marcador efectivo si el foco est√° en la especificidad m√°s que en la sensibilidad 10.9 Encontrando marcadores espec√≠ficos de cl√∫steres üëâ Por defecto, scran::findMarkers() dar√° un alto rango a genes que est√°n DE en cualquier comparaci√≥n pareada ü§î Quiero genes que son espec√≠ficos de cada cl√∫ster üëâ T√∫ quieres genes que son DE en todas las comparaciones pareadas Para cada cl√∫ster, usa pruebas t de Welch para identificar genes que est√°n sobreexpresados entre √©ste y todos los otros cl√∫steres markers.pbmc.up3 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;all&quot; ) interesting.up3 &lt;- markers.pbmc.up3[[chosen]] ü§ì Usa una prueba de uni√≥n-intersecci√≥n para combinar los P-values que es el m√°ximo P-value de todas las comparaciones pareadas 10.9.1 Pros/cons de los genes marcadores espec√≠ficos de los cl√∫steres Poblacion Expresion_CD4 Expresion_CD8 DN(CD4-/CD8-) No No CD4+&gt; Si No CD8+&gt; No Si DP(CD4+/CD8+) Si Si 10.9.2 findMarkers con pval.type some Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados entre √©ste y algunos de los otros cl√∫sters markers.pbmc.up4 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;some&quot; ) interesting.up4 &lt;- markers.pbmc.up4[[chosen]] üëâ Para cuando pval.type=\"all\" es muy estricto todav√≠a pval.type=\"any\" es muy generoso ü§ì Aplica la correcci√≥n Holm-Bonferroni a los P-values y toma el mejor valor de en medio como el P-value combinado ‚ö†Ô∏è Perder√°s algunas garant√≠as ofrecidas por los otros m√©todos 10.10 Pruebas alternas 10.10.1 Motivaci√≥n La prueba t no es la √∫nica forma de comparar dos grupos de mediciones ü§î Quiero una prueba que pueda ser usada perfectamente para distinguir dos cl√∫steres uno del otro üëâ Prueba de rangos Wilcoxon ü§î Quiero identificar genes que son expresados m√°s frecuentemente en un cl√∫ster que en otro üëâ Prueba Binomial 10.11 Prueba de rangos de Wilcoxon Eval√∫a directamente la separaci√≥n entre la distribuci√≥n de la expresi√≥n de los diferentes cl√∫steres ü§ì Es proporcional al √°rea bajo la curva (AUC), que es la probabilidad de que una c√©lula al azar de un cl√∫ster tenga mayor que expresi√≥n que una c√©lula al azar de otro cl√∫ster üëâ AUCs de 1 o 0 indican que los dos cl√∫steres tienen distribuciones de expresi√≥n separadas ü§ì Tambi√©n se conoce como prueba Wilcoxon-Mann-Whitney (WMW) 10.11.1 findMarkers para Wilcoxon Para cada cl√∫ster, usa la prueba de rangos de Wilcoxon para identificar genes que est√°n sobreexpresados entre √©ste y cualquier otro cl√∫ster markers.pbmc.wmw &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;wilcox&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.wmw &lt;- markers.pbmc.wmw[[chosen]] 10.11.2 Heatmap de genes marcadores con Wilcoxon best.set &lt;- interesting.wmw[interesting.wmw$Top &lt;= 5, ] AUCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(AUCs) &lt;- sub(&quot;AUC.&quot;, &quot;&quot;, colnames(AUCs)) pheatmap(AUCs, breaks = seq(0, 1, length.out = 21), color = viridis::viridis(21) ) 10.11.3 Resumen de la prueba de rangos de Wilcoxon ‚ûï Ofrece directamente la propiedad deseable de un gen marcador (i.e.¬†que el gen distinga perfectamente entre dos cl√∫steres) ‚ûï Es sim√©trico con respecto a las diferencias en el tama√±o de los grupos comparados ‚ûñ Es mucho m√°s lento comparado con la prueba t (aunque esto en general no es un problema en la pr√°ctica) 10.12 Prueba binomial Es una prueba que identifica los genes que difieren en la proporci√≥n de c√©lulas que se expresan entre cl√∫steres Una definici√≥n mucho m√°s estricta de genes marcadores ü§ì Convierte la expresi√≥n en una medida binaria de presencia/ausencia, por lo que toda la informaci√≥n cuantitativa es ignorada Desde una perspectiva pr√°ctica, puede ser m√°s f√°cil para validar 10.12.1 findMarkers para binomial Para cada cl√∫ster, usa la prueba Binomial para identificar genes que est√°n m√°s frecuentemente expresados (sobreexpresados) en comparaci√≥n con cualquier otro cl√∫ster markers.pbmc.binom &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;binom&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.binom &lt;- markers.pbmc.binom[[chosen]] ü§ì El efecto en el tama√±o se reporta como el log-fold change en la proporci√≥n de las c√©lulas que se expresan entre cl√∫steres üëâ Log-fold changes grandes positivos, indican que el gen est√° m√°s frecuentemente expresado en un cl√∫ster comparado con otro 10.12.2 Visualizando genes marcadores de la prueba bionomial top.genes &lt;- head(rownames(interesting.binom)) plotExpression(sce.pbmc, x = &quot;cluster&quot;, features = top.genes) 10.12.3 Resumen de la prueba binomial La prueba Binomial no toma en cuenta la normalizaci√≥n ‚ûï Produce genes marcadores que pueden ser m√°s f√°ciles de validar ‚ûñ Ser m√°s estricto puede llevar a la p√©rdida de buenos marcadores candidatos 10.13 M√©todos de expresi√≥n diferencial personalizados ü§î ¬øPor qu√© no usar edgeR/DESeq2/limma-voom u otros m√©todos personalizados (e.g., MAST)? üëâ Claro que puedes! Checa OSCA üëâ Pero √©stos son tal vez algo exagerados para identificar genes marcadores ü§ì Las c√©lulas son nuestras ‚Äúr√©plicas‚Äù para el prop√≥sito de identificar genes marcadores ü§ì edgeR/DESeq2/limma-voom hacen asunciones m√°s fuertes acerca de los datos que es m√°s probable que no se cumplan para c√©lulas individuales en scRNA-seq 10.14 Problemas estad√≠sticos 10.14.1 Invalidez de P-values Todas las estrategias de DE para detectar genes marcadores entre cl√∫steres son estad√≠sticamente defectuosas de alguna manera ü§ì ‚ÄúDragado de datos‚Äù: El an√°lisis DE se realiza usando los mismos datos usados para obtener los cl√∫steres üëâ Las pruebas para genes DE entre cl√∫steres producir√° inevitablemente algunos resultados significativos y as√≠ es como los cl√∫steres ser√°n definidos! üëâ A√∫n cuando los P-values son defectuosos, el efecto no es muy da√±ino para la detecci√≥n de genes ya que los P-values solo son usados para los rangos ü§ì No se pueden usar P-values para definir ‚Äúdiferencias significativas‚Äù entre los cl√∫steres con respecto a un umbral de la tasa de error 10.14.2 Naturaleza de la replicaci√≥n üëâ Idealmente, validar algunos de los marcadores con una poblaci√≥n de c√©lulas independientes (y idealmente usando una t√©cnica diferente, e.g., hibridaci√≥n fluorescente in situ o qPCR) 10.14.3 Comentarios adicionales üëâ La estrategia de an√°lisis DE es que los marcadores son definidos relativo a subpoblaciones en el mismo dataset üëâ Si un gen se expresa uniformemente a trav√©s de la poblaci√≥n no servir√° como un marcador e.g., los marcadores de las c√©lulas T no ser√°n detectados si solamente hay c√©lulas T en los datos usualmente no es un problema, ya que tenemos idea de las c√©lulas que se capturaron üëâ Existen m√©todos de machine learning para hacer la identificaci√≥n de los genes marcadores, pero la humilde prueba t sigue siendo muy buena 10.15 Resumen y recomendaciones üëâ Crea m√∫ltiples listas de genes marcadores con diferentes niveles de rigor üëâ La forma m√°s simple de interpretar los genes marcadores es que son los sobreexpresados de ‚Äúforma √∫nica‚Äù, o son ‚Äúgenes espec√≠ficos de cl√∫steres‚Äù, especialmente si queremos imponer un log-fold change m√≠nimo üëâ Puedes requerir hacer una identificaci√≥n de genes marcadores m√°s enfocada, e.g., subset de los datos de solo 2 cl√∫steres de inter√©s y entonces correr scran::findMarkers() 10.16 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:39:06 UTC&quot; proc.time() ## user system elapsed ## 337.015 4.850 338.857 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra * 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al.¬†Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).‚Ü©Ô∏é "],["anotaci√≥n-de-clusters-de-c√©lulas.html", "11 Anotaci√≥n de clusters de c√©lulas 11.1 Diapositivas de Peter Hickey 11.2 Motivaci√≥n 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.5 SingleR 11.6 Resumen de la anotaci√≥n basada en una referencia (e.g., SingleR) 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores 11.8 Resumen y recomendaciones 11.9 Detalles de la sesi√≥n de R Patrocinadores", " 11 Anotaci√≥n de clusters de c√©lulas Instructora: Yalbi I. Balderas-Mart√≠nez. 11.1 Diapositivas de Peter Hickey Ver las diapositivas originales aqu√≠ 11.2 Motivaci√≥n Ahora estamos a punto de obtener la interpretaci√≥n biol√≥gica de los resultados Esta es la tarea m√°s retadora en los an√°lisis de datos scRNA-seq üëâ La obtenci√≥n de cl√∫steres es m√°s o menos directa ü§î ¬øCu√°l es el estado biol√≥gico que est√° representado por cada uno de los cl√∫steres? üëâ Necesitamos hacer un puente entre el gap del dataset actual y el conocimiento biol√≥gico a priori (no siempre est√° disponible en una forma consistente y cualitativa) ü§î ¬øQu√© es un tipo celular? üî¨ ‚ÄúLo sabr√© cuando lo vea‚Äù üíª ‚ÄúNo‚Äù Aplicaremos varios m√©todos computacionales que explotan la informaci√≥n a priori para asignar el significado a un dataset no caracterizado de scRNA-seq. Algunas fuentes de informaci√≥n a priori Conjuntos de genes curados (e.g.¬†Gene Ontology) Perfiles de expresi√≥n de bases de datos publicadas de referencia Los datos raros que t√∫ hayas escondido en tu cerebro Google 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset ‚ÄúC√©lulas mononucleares humanas de sangre perif√©rica‚Äù de 10X Genomics Descripci√≥n aqu√≠ 22 11.3.1 Anotaci√≥n # Anotaci√≥n de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detecci√≥n de _droplets_ con c√©lulas set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 11.3.2 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalizaci√≥n de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 11.3.3 Genes variables ## Identificaci√≥n de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 11.3.4 Reducci√≥n de dimensiones ## Reducci√≥n de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 11.3.5 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.4.1 Visi√≥n general üëâ Un enfoque directo es comparar los perfiles de expresi√≥n single-cell con datasets previamente anotados üëâ Las etiquetas pueden entonces ser asignadas a cada c√©lula en nuestro dataset no caracterizado de prueba basado en la muestra de referencia m√°s similar, por dar alguna definici√≥n de ‚Äúsimilar‚Äù üëâ Cualquier dataset de expresi√≥n g√©nica etiquetado (microarreglos, RNA-seq bulk, scRNA-seq) puede ser usado como una referencia ‚ö†Ô∏è Sin embargo, su confiabilidad depende enormemente en la calidad de los datos originales y la experiencia de los autores originales quienes asignaron las etiquetas en primer lugar üëâ Asignar las etiquetas a un dataset de ‚Äúprueba‚Äù a partir de un dataset de ‚Äúentrenamiento‚Äù (referencia), es un problema est√°ndar en estad√≠stica / machine learning üëâ Usaremos el m√©todo SingleR (Aran et al.¬†2019) 11.5 SingleR ü§ì Asigna las etiquetas a las c√©lulas basado en las muestras de referencia con las correlaciones de rangos m√°s altas de Spearman ü§ì Para reducir el ruido, identifica genes marcadores entre pares de etiquetas (en la referencia) y calcula la correlaci√≥n usando solamente esos marcadores ü§ì Hace alg√∫n tipo de tuneado fino, repitiendo las correlaciones solamente con los genes marcadores de las etiquetas con el mejor score, ayudando a resolver cualquier ambig√ºedad entre esas etiquetas al eliminar el ruido a partir de marcadores irrelevantes para otras etiquetas 11.5.1 SingleR incluye varias referencias Ver referencias # Human celldex::BlueprintEncodeData() celldex::DatabaseImmuneCellExpressionData() celldex::HumanPrimaryCellAtlasData() celldex::MonacoImmuneData() celldex::NovershternHematopoieticData() # Mice celldex::ImmGenData() celldex::MouseRNASeqData() 11.5.2 Usando las referencias # if needed install celldex # create directory? y library(celldex) ref &lt;- celldex::BlueprintEncodeData() ‚ùì ¬øQu√© tipos celulares est√°n disponibles en este dataset de referencia? 11.5.3 Usando las referencias integradas library(SingleR) pred &lt;- SingleR( test = sce.pbmc, ref = ref, labels = ref$label.main ) ‚ùì ¬øQu√© etiquetas han sido asignadas a los datos single-cell? ‚ùì ¬øC√≥mo usar√≠amos las etiquetas ‚Äúfinas‚Äù con SingleR? plotScoreHeatmap(pred) üëâ Inspeccionamos los resultados usando un heatmap de los scores por c√©lula y por etiqueta üëâ Idealmente, cada c√©lula deber√≠a exhibir un score alto en una etiqueta relativa a todas las otras üëâ Los scores se muestran antes de cualquier tuneado fino y son normalizadas a [0, 1] dentro de cada c√©lula 11.5.4 Podado de etiquetas (Label pruning) total_pruned &lt;- sum(is.na(pred$pruned.labels)) plotScoreHeatmap(pred, show.pruned = TRUE) üëâ SingleR intentar√° podar aquellas asignaciones de baja calidad marc√°ndolas como NA ü§ì El podado se hace calculando la diferencia del score de la etiqueta asignada a partir del score de la mediana dentro de cada c√©lula y entonces podando las c√©lulas con un valor peque√±o de esta diferencia plotScoreDistribution(pred) üëâ Distribuci√≥n de las diferencias del score de la etiqueta asignada a partir del score de la mediana dentro de cada c√©lula 11.5.5 Identificando los genes con anotaci√≥n dirigida ü§î ¬øPor qu√© las c√©lulas en este cl√∫ster se etiquetan como el tipo celular X? üëâ Examina la expresi√≥n de los genes marcadores para cada etiqueta en el dataset de prueba üëâ Si una c√©lula en el dataset de prueba est√° asignado con confianza a una etiqueta en particular, uno esperar√≠a que tenga una fuerte expresi√≥n de los marcadores de esa etiqueta (al menos sobreexpresi√≥n con respecto a las c√©lulas asignadas a otras etiquetas) # install gmp, ClusterR, mbkmeans dependencies if needed sce.pbmc$labels &lt;- pred$labels all.markers &lt;- metadata(pred)$de.genes lab &lt;- &quot;B-cells&quot; # Get top-10 marker genes for B-cells compared to each other cell # type top.markers &lt;- Reduce(union, sapply(all.markers[[lab]], head, 10)) plotHeatmap(sce.pbmc, order_columns_by = &quot;labels&quot;, features = top.markers, center = TRUE, zlim = c(-3, 3), main = lab ) ‚ùì Toma otro tipo celular e identifica los genes que dirigen la anotaci√≥n 11.5.6 Comparando las etiquetas con los cl√∫steres tab &lt;- table(Assigned = pred$pruned.labels, Cluster = sce.pbmc$cluster) library(pheatmap) # Proportion of cells in each cluster assigned to each label pheatmap(prop.table(tab, margin = 2), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) # (log-)number of cells in each cluster assigned to each label # Adding a pseudo-count of 10 to avoid strong color jumps with just # 1 cell. pheatmap(log2(tab + 10), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) 11.5.7 Voil√† plotTSNE(sce.pbmc, colour_by = &quot;labels&quot;, text_by = &quot;labels&quot;) plotTSNE(sce.pbmc, colour_by = &quot;cluster&quot;, text_by = &quot;labels&quot;) 11.5.7.1 Aventura en el tiempo Hmm. We can't figure out why these two plots are different with the same code, though different R versions.BioC 3.11? @PeteHaitch https://t.co/8DJM6pagdjBioC 3.13https://t.co/t8KiPTyU9D@Bioconductor #rstats @yalbi_ibm @AnaBetty2304 pic.twitter.com/P65u7dnVCo ‚Äî üá≤üáΩ Leonardo Collado-Torres (@lcolladotor) August 10, 2021 https://github.com/MarioniLab/DropletUtils/issues/67 Ok, not identical, but not bad with BioC 3.13 onlyLeft: BioC 3.13 with e.out from BioC 3.111Middle: Pete's slides with BioC 3.11Right: BioC 3.13 only#rstats #OSCA @Bioconductor #DropletUtils pic.twitter.com/d41LiuXKWn ‚Äî üá≤üáΩ Leonardo Collado-Torres (@lcolladotor) August 11, 2021 11.6 Resumen de la anotaci√≥n basada en una referencia (e.g., SingleR) ‚ûï Se centra en aspectos de los datos que se sabe son interesantes, simplifica el proceso de la interpretaci√≥n biol√≥gica ‚ûñ Est√° restringido por la diversidad y la resoluci√≥n de las etiquetas disponibles en el dataset de referencia üëâ Se pueden suplir referencias personalizadas a SingleR 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores ü§î ¬øC√≥mo podemos hacer uso de nuestros genes marcadores agrupados? ü•â Revisarlos en hojas de c√°lculo ü•à Observar heatmaps ü•á Realizar un gene set enrichment analysis 11.7.1 Gene set enrichment analysis üëâ Identifica las rutas y procesos que est√°n (relativamente) activos en cada cl√∫ster basado en la sobreexpresi√≥n de los genes asociados en comparaci√≥n con otros cl√∫steres ‚ûï Un m√©todo confiable para determinar si las rutas est√°n sobre- o sub- expresadas entre cl√∫esteres ‚ûï Existen un mont√≥n de herramientas para gene set enrichment analysis ‚ûñ Todas las conclusiones son relativas a otros cl√∫steres, haci√©ndolo m√°s dif√≠cil para determinar la identidad celular si alguno no est√° presente en el mismo estudio m√°s info 11.7.2 Calculando las actividades de los conjuntos de genes üëâ Calcular el promedio de la expresi√≥n en log en todos los genes, en un conjunto de genes para cada c√©lula y examinar los cl√∫steres con valores altos (gene set activities) üëâ Se necesita proveer de conjuntos de genes ‚ûñ No todos los genes en el conjunto pueden exhibir el mismo patr√≥n de diferencia y los genes no-DE a√±adir√°n ruido, ‚Äúdiluyendo‚Äù la fuerza de cualquiera de las diferencias comparadas a un an√°lisis que se centra directamente en genes DE üëâ Es m√°s una visualizaci√≥n √∫til que la base para cualquier an√°lisis estad√≠stico real m√°s info 11.8 Resumen y recomendaciones üëâ La anotaci√≥n de tipos celulares ‚Äúautom√°tica‚Äù, como SingleR, es mejor cuando funciona (i.e.¬†cuando hay un dataset de referencia apropiado) üëâ Usualmente necesitaremos usar un m√©todo manual, como aquellos basados en agrupar los genes marcadores (e.g., gene set enrichment analysis) üëâ La anotaci√≥n del tipo celular ofrecer√° una reconsideraci√≥n inmediata de los par√°metros del agrupamiento y/o algunos retoques manuales a los cl√∫steres 11.9 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:42:29 UTC&quot; proc.time() ## user system elapsed ## 200.819 4.594 202.975 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.3 2021-08-15 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## celldex * 1.2.0 2021-05-20 [1] Bioconductor ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.1 2021-08-15 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.1 2021-08-15 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## SingleR * 1.6.1 2021-05-20 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.7 2021-08-17 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al.¬†Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).‚Ü©Ô∏é "],["an√°lisis-de-expresi√≥n-diferencial.html", "12 An√°lisis de expresi√≥n diferencial 12.1 Diapositivas de Peter Hickey 12.2 Motivaci√≥n 12.3 Datos de ejemplo 12.4 An√°lisis de expresi√≥n diferencial 12.5 An√°lisis de abundancia diferencial 12.6 Comentarios sobre la interpretaci√≥n 12.7 Detalles de la sesi√≥n de R Patrocinadores", " 12 An√°lisis de expresi√≥n diferencial Instructor: Leonardo Collado Torres ## Paquetes de este cap√≠tulo library(&quot;MouseGastrulationData&quot;) ## para descargar datos de ejemplo library(&quot;scater&quot;) ## para gr√°ficas y control de calidad library(&quot;scran&quot;) ## para selecci√≥n de genes, clustering, etc library(&quot;batchelor&quot;) ## para m√©todos de correci√≥n de batch (lote) library(&quot;patchwork&quot;) ## para agrupar gr√°ficas library(&quot;Polychrome&quot;) ## para muchos colores library(&quot;bluster&quot;) ## m√©todos de clustering library(&quot;edgeR&quot;) ## para expresi√≥n diferencial 12.1 Diapositivas de Peter Hickey Ve las diapositivas aqu√≠. Esas diapositivas est√°n basadas en este cap√≠tulo de OSCA. El libro de OSCA tiene algunas partes m√°s actualizadas de lo que vienen en las diapositivas. 12.2 Motivaci√≥n üëâ scRNA-seq nos puede ayudar a estudiar cambios en composici√≥n (cambios en proporciones de c√©lulas) o cambios en niveles de expresi√≥n de genes entre varias condiciones biol√≥gicas El primero se llama cambios de abundancia, Ejemplo: despu√©s de un tratamiento con una droga Ejemplo: despu√©s de modificaciones gen√©ticas üëâ Nos permite obtener mayor resoluci√≥n biol√≥gica que experimentos convencionales de RNA-seq, sobre todo si podemos asociar cambios en poblaciones celulares a manipulaciones experimentales 12.2.1 Dos categor√≠as de an√°lisis üëâ An√°lisis de expresi√≥n diferencial Buscamos cambios en niveles de expresi√≥n entre condiciones para c√©lulas del mismo tipo que est√°n presentes en todas las condiciones üëâ An√°lisis de abundancia diferencial Buscamos cambios en la composici√≥n de los tipos celulares entre condiciones Podr√≠a ser entre estados celulares en vez de tipos celulares Son dos lados de la misma moneda 12.2.1.1 Expresi√≥n diferencial gene condici√≥n celula expresi√≥n gene1 grupo1 celula1 13.31 gene1 grupo2 celula1 6.15 gene2 grupo1 celula1 9.67 gene2 grupo2 celula1 11.53 gene1 grupo1 celula2 10.89 gene1 grupo2 celula2 7.65 gene2 grupo1 celula2 10.97 gene2 grupo2 celula2 9.37 12.2.1.2 Abundancia diferencial condici√≥n celula frecuencia grupo1 celula1 47 grupo2 celula1 32 grupo1 celula2 39 grupo2 celula2 43 12.3 Datos de ejemplo Embriones de rat√≥n quim√©ricos. Chimeric E8.5 mouse embryos td-Tomato+ ESCs injected into WT blastocyst No genetic differences between the injected and background cells (except expression of td-Tomato in the former) 3 replicate batches Each batch contains td-Tomato+ and td-Tomato- cells sorted from a single pool of dissociated cells from 6-7 chimeric embryos 2,000 - 7,000 cells/sample using 10X Genomics Aim is to determine whether the injection procedure itself introduces differences in lineage commitment compared to the background cells https://bioconductor.org/books/release/OSCA/pijuan-sala-chimeric-mouse-embryo-10x-genomics.html Pijuan-Sala, B. et al.¬†A single-cell molecular map of mouse gastrulation and early organogenesis. Nature 566, 490‚Äì495 (2019). 12.3.1 Descarguemos los datos de ejemplo #--- loading ---# library(&quot;MouseGastrulationData&quot;) sce.chimera &lt;- WTChimeraData(samples = 5:10) sce.chimera ## class: SingleCellExperiment ## dim: 29453 20935 ## metadata(0): ## assays(1): counts ## rownames(29453): ENSMUSG00000051951 ENSMUSG00000089699 ... ## ENSMUSG00000095742 tomato-td ## rowData names(2): ENSEMBL SYMBOL ## colnames(20935): cell_9769 cell_9770 ... cell_30702 cell_30703 ## colData names(11): cell barcode ... doub.density sizeFactor ## reducedDimNames(2): pca.corrected.E7.5 pca.corrected.E8.5 ## mainExpName: NULL ## altExpNames(0): ## Exploremos los datos sapply(colData(sce.chimera)[, -(1:2)], function(x) { x &lt;- if (is.character(x) || is.integer(x)) factor(x) else x summary(x) }) ## $sample ## 5 6 7 8 9 10 ## 2411 1047 3007 3097 4544 6829 ## ## $stage ## E8.5 ## 20935 ## ## $tomato ## Mode FALSE TRUE ## logical 10973 9962 ## ## $pool ## 3 4 5 ## 3458 6104 11373 ## ## $stage.mapped ## E7.0 E7.25 E7.5 E7.75 E8.0 E8.25 E8.5 ## 55 39 255 1224 1641 6998 10723 ## ## $celltype.mapped ## Allantois Blood progenitors 1 ## 955 56 ## Blood progenitors 2 Cardiomyocytes ## 245 601 ## Caudal epiblast Caudal Mesoderm ## 71 71 ## Caudal neurectoderm Def. endoderm ## 19 91 ## Doublet Endothelium ## 1509 350 ## Erythroid1 Erythroid2 ## 448 1115 ## Erythroid3 ExE ectoderm ## 3173 156 ## ExE endoderm ExE mesoderm ## 14 1003 ## Forebrain/Midbrain/Hindbrain Gut ## 1803 701 ## Haematoendothelial progenitors Intermediate mesoderm ## 518 397 ## Mesenchyme Mixed mesoderm ## 1495 4 ## Neural crest NMP ## 615 606 ## Notochord Paraxial mesoderm ## 11 1059 ## Parietal endoderm PGC ## 61 25 ## Pharyngeal mesoderm Rostral neurectoderm ## 1109 198 ## Somitic mesoderm Spinal cord ## 328 713 ## Stripped Surface ectoderm ## 47 1357 ## Visceral endoderm ## 11 ## ## $closest.cell ## cell_71220 cell_132352 cell_37581 cell_38398 cell_133630 cell_75985 ## 180 179 135 123 102 78 ## cell_74615 cell_96860 cell_134438 cell_38140 cell_36067 cell_98277 ## 76 72 59 59 54 51 ## cell_40210 cell_133739 cell_69452 cell_137250 cell_40746 cell_74744 ## 46 43 42 41 41 40 ## cell_37295 cell_139027 cell_76775 cell_98128 cell_97456 cell_132412 ## 39 38 37 37 36 34 ## cell_69071 cell_70906 cell_133892 cell_40183 cell_132070 cell_133063 ## 34 34 33 32 30 30 ## cell_133712 cell_38655 cell_40388 cell_131552 cell_39059 cell_66392 ## 28 27 27 26 26 25 ## cell_66974 cell_102032 cell_131092 cell_67212 cell_98050 cell_39343 ## 25 24 24 24 24 23 ## cell_40527 cell_74684 cell_100899 cell_130659 cell_133721 cell_134638 ## 23 23 22 22 22 22 ## cell_38244 cell_39903 cell_70218 cell_76927 cell_137879 cell_27132 ## 22 22 22 22 21 21 ## cell_65563 cell_101969 cell_38451 cell_40571 cell_91221 cell_125957 ## 21 20 20 20 20 19 ## cell_40143 cell_40412 cell_65386 cell_66720 cell_70671 cell_96014 ## 19 19 19 19 19 19 ## cell_97435 cell_131123 cell_133876 cell_134544 cell_136737 cell_138771 ## 19 18 18 18 18 18 ## cell_65700 cell_70110 cell_72521 cell_102689 cell_132918 cell_133005 ## 18 18 18 17 17 17 ## cell_133481 cell_37978 cell_38407 cell_65580 cell_134191 cell_136502 ## 17 17 17 17 16 16 ## cell_25052 cell_40387 cell_40844 cell_71754 cell_74962 cell_76390 ## 16 16 16 16 16 16 ## cell_96412 cell_96512 cell_96673 cell_98024 cell_99878 cell_101054 ## 16 16 16 16 16 15 ## cell_102334 cell_102822 cell_103120 (Other) ## 15 15 15 17749 ## ## $doub.density ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00000 0.00294 0.02468 0.14791 0.09480 43.64080 ## ## $sizeFactor ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1199 0.5500 0.7545 0.9091 1.1114 5.4110 B√°sicamente: sample: 6 ratones diferentes tomato: inyectados o no con td-Tomato pool: lote de secuenciaci√≥n, cada lote con 1 con y otro sin inyecci√≥n celltype.mappped: 35 tipos de c√©lulas anotados ## N√∫mero de c√©lulas en nuestras variables principales with(colData(sce.chimera), table(sample, pool, tomato)) ## , , tomato = FALSE ## ## pool ## sample 3 4 5 ## 5 0 0 0 ## 6 1047 0 0 ## 7 0 0 0 ## 8 0 3097 0 ## 9 0 0 0 ## 10 0 0 6829 ## ## , , tomato = TRUE ## ## pool ## sample 3 4 5 ## 5 2411 0 0 ## 6 0 0 0 ## 7 0 3007 0 ## 8 0 0 0 ## 9 0 0 4544 ## 10 0 0 0 ## N√∫mero de tipos celulares length(unique(sce.chimera$celltype.mapped)) ## [1] 35 12.3.2 Procesamiento Usaremos los m√©todos que ya vimos para procesar datos Usaremos batchelor porque tenemos muestras de 3 lotes de muestras y queremos eliminar diferencias entre los lotes Para m√°s detalles, revisar https://bioconductor.org/books/release/OSCA/integrating-datasets.html #--- feature-annotation ---# library(&quot;scater&quot;) rownames(sce.chimera) &lt;- uniquifyFeatureNames( rowData(sce.chimera)$ENSEMBL, rowData(sce.chimera)$SYMBOL ) #--- quality-control ---# drop &lt;- sce.chimera$celltype.mapped %in% c(&quot;stripped&quot;, &quot;Doublet&quot;) sce.chimera &lt;- sce.chimera[, !drop] #--- normalization ---# sce.chimera &lt;- logNormCounts(sce.chimera) #--- variance-modelling ---# library(&quot;scran&quot;) dec.chimera &lt;- modelGeneVar(sce.chimera, block = sce.chimera$sample) chosen.hvgs &lt;- dec.chimera$bio &gt; 0 #--- merging ---# library(&quot;batchelor&quot;) set.seed(01001001) merged &lt;- correctExperiments(sce.chimera, batch = sce.chimera$sample, subset.row = chosen.hvgs, PARAM = FastMnnParam( merge.order = list( list(1, 3, 5), # WT (3 replicates) list(2, 4, 6) # td-Tomato (3 replicates) ) ) ) #--- clustering ---# g &lt;- buildSNNGraph(merged, use.dimred = &quot;corrected&quot;) clusters &lt;- igraph::cluster_louvain(g) colLabels(merged) &lt;- factor(clusters$membership) #--- dimensionality-reduction ---# merged &lt;- runTSNE(merged, dimred = &quot;corrected&quot;, external_neighbors = TRUE) merged &lt;- runUMAP(merged, dimred = &quot;corrected&quot;, external_neighbors = TRUE) 12.3.3 Exploremos los datos de ejemplo Exploremos si tenemos clusters con una diferencia grande en el n√∫mero de celulas entre las muestras sin y con inyecciones de td-Tomato Exploremos el n√∫mero de c√©lulas en cada cluster a lo largo de los 3 lotes de secuenciaci√≥n (batch) ## Clusters vs DE por td-Tomato table(colLabels(merged), merged$tomato) ## ## FALSE TRUE ## 1 546 401 ## 2 60 52 ## 3 470 398 ## 4 469 211 ## 5 335 271 ## 6 258 249 ## 7 1241 967 ## 8 203 221 ## 9 630 629 ## 10 71 181 ## 11 417 310 ## 12 47 57 ## 13 58 0 ## 14 209 214 ## 15 414 630 ## 16 363 509 ## 17 234 198 ## 18 657 607 ## 19 151 303 ## 20 579 443 ## 21 137 74 ## 22 82 78 ## 23 155 1 ## 24 762 878 ## 25 363 497 ## 26 1420 716 ## Clusters vs lotes de muestras (batch) table(colLabels(merged), merged$pool) ## ## 3 4 5 ## 1 224 173 550 ## 2 26 30 56 ## 3 226 172 470 ## 4 78 162 440 ## 5 99 227 280 ## 6 187 116 204 ## 7 300 909 999 ## 8 69 134 221 ## 9 229 423 607 ## 10 114 54 84 ## 11 179 169 379 ## 12 16 31 57 ## 13 2 51 5 ## 14 77 97 249 ## 15 114 289 641 ## 16 183 242 447 ## 17 157 81 194 ## 18 123 308 833 ## 19 106 118 230 ## 20 236 238 548 ## 21 3 10 198 ## 22 27 29 104 ## 23 6 84 66 ## 24 217 455 968 ## 25 132 172 556 ## 26 194 870 1072 Visualizaremos nuestros clusters que son 26 en dimensiones reducidas de t-SNE Queremos que todos los clusters tengan muestras de cada lote de secuenciaci√≥n (batch). Detalles en OSCA Vemos que no parece que haya mucha se√±al en base a td-Tomato library(&quot;patchwork&quot;) plotTSNE(merged, colour_by = &quot;tomato&quot;, text_by = &quot;label&quot;) + plotTSNE(merged, colour_by = data.frame(pool = factor(merged$pool))) Podemos usar facet_wrap() para reducir el over-plotting y ver mejor la informaci√≥n. plotTSNE(merged, colour_by = &quot;tomato&quot;, other_fields = c(&quot;tomato&quot;) ) + facet_wrap(~tomato) plotTSNE(merged, colour_by = data.frame(pool = factor(merged$pool)), other_fields = c(&quot;pool&quot;) ) + facet_wrap(~pool) Tambi√©n podr√≠amos usar Nebulosa. This one is from a while back, but on 2020-11-20 I presented for @LIBDrstats the #Nebulosa @Bioconductor #rstats package by @josealquicirah et al for visualizing sc/snRNA-seq dataüìî https://t.co/vWmT398lXGhttps://t.co/D3TbpOKkwF https://t.co/KFihrSGVUy ‚Äî üá≤üáΩ Leonardo Collado-Torres (@lcolladotor) April 15, 2021 12.3.4 Nuestros clusters vs los originales Las siguientes gr√°ficas nos ayudan a comparar nuestros clusters vs los que encontraron en el estudio original ¬øLes parecen similares? ## Definir colores, si no scater nos los pone en una escala ## continua cols_label &lt;- Polychrome::palette36.colors(length(unique(merged$label))) names(cols_label) &lt;- unique(merged$label) cols_celltype.mapped &lt;- Polychrome::palette36.colors(length(unique(merged$celltype.mapped))) names(cols_celltype.mapped) &lt;- unique(merged$celltype.mapped) ## Nuestros clusters vs anotaci√≥n de c√©lulas por los ## autores originales plotTSNE(merged, colour_by = &quot;label&quot;, text_by = &quot;label&quot;) + theme(legend.position = &quot;none&quot;) + scale_colour_manual(values = cols_label) + plotTSNE(merged, colour_by = &quot;celltype.mapped&quot;) + theme(legend.position = &quot;none&quot;) + scale_colour_manual(values = cols_celltype.mapped) ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. Es dif√≠cil el proceso de comparar clusters Podemos usar bluster para evaluar n√∫mericamente que tanto se parecen los clusters. Entre m√°s cerca de 1, mejor en pairwiseRand() Tambi√©n podemos hacer un heatmap library(&quot;bluster&quot;) pairwiseRand(colLabels(merged), merged$celltype.mapped, &quot;index&quot;) ## [1] 0.5513742 by.label &lt;- table(colLabels(merged), merged$celltype.mapped) pheatmap::pheatmap(log2(by.label + 1), color = viridis::viridis(101)) Por eso es m√°s f√°cil combinar datos de varios lotes de secuenciaci√≥n y hacer un solo clustering en vez de varios y tener que identificar que clusters de una muestra corresponden a los de otra ‚ö†Ô∏è Nos saltaremos el proceso de anotaci√≥n de c√©lulas y usaremos los clusters y etiquetas originales 12.4 An√°lisis de expresi√≥n diferencial En RNA-seq estamos acostumbrados a evaluar si hay diferencias en los niveles de expresi√≥n de genes entre condiciones, as√≠ que es natural que lo hagamos con scRNA-seq tambi√©n ü§î Pero los datos de scRNA-seq tienen muchos ceros 12.4.1 Pseudo-bulking El proceso de pseudo-bulking es un truco que nos permite usar m√©todos de bulk RNA-seq para analizar nuestros datos de scRNA-seq C√≥mo tenemos muchas c√©lulas de cada condici√≥n, para cada gene podemos sumar los niveles de expresi√≥n entre todas las c√©lulas de esa condici√≥n üî•off the press! üëÄ our @biorxivpreprint on human üß†brain @LieberInstitute spatial üååüî¨transcriptomics data üß¨using Visium @10xGenomicsüéâ#spatialLIBDüîçhttps://t.co/RTW0VscUKR üë©üèæ‚Äçüíªhttps://t.co/bsg04XKONrüìöhttps://t.co/FJDOOzrAJ6üì¶https://t.co/Au5jwADGhYhttps://t.co/PiWEDN9q2N pic.twitter.com/aWy0yLlR50 ‚Äî üá≤üáΩ Leonardo Collado-Torres (@lcolladotor) February 29, 2020 Ejemplo de mi trabajo: 12 muestras 7 regiones 47,681 spots (digamos que c√©lulas) Podemos comprimir la informaci√≥n a una matriz de 12 * 7 = 84 columnas Nos quedamos con pocas r√©plicas para nuestro an√°lisis, pero justamente los m√©todos de bulk RNA-seq est√°n dise√±ados para esos escenarios (claro, entre m√°s datos mejor!!!) Ac√° pueden explorar los datos si quieren http://spatial.libd.org/spatialLIBD/ Estas diapositivas son parte de un webinar que di con Kristen R Maynard el 2021-04-27 para BioTuring que pueden ver desde su sitio web o en YouTube. Podemos hacerlo manualmente o de forma m√°s sencilla con la funci√≥n aggregateAcrossCells() # Using &#39;label&#39; and &#39;sample&#39; as our two factors; each column of the output # corresponds to one unique combination of these two factors. summed &lt;- aggregateAcrossCells(merged, id = colData(merged)[, c(&quot;celltype.mapped&quot;, &quot;sample&quot;)] ) summed ## class: SingleCellExperiment ## dim: 14699 186 ## metadata(2): merge.info pca.info ## assays(1): counts ## rownames(14699): Xkr4 Rp1 ... Vmn2r122 CAAA01147332.1 ## rowData names(3): rotation ENSEMBL SYMBOL ## colnames: NULL ## colData names(16): batch cell ... sample ncells ## reducedDimNames(5): corrected pca.corrected.E7.5 pca.corrected.E8.5 ## TSNE UMAP ## mainExpName: NULL ## altExpNames(0): dim(merged) ## [1] 14699 19426 dim(summed) ## [1] 14699 186 with(colData(merged), length(unique(celltype.mapped)) * length(unique(sample))) ## [1] 204 En teor√≠a podr√≠amos tener m√°s columnas, pero no las tenemos todas porque no tenemos datos para todas las combinaciones Esto puede afectar nuestro an√°lisis, y pues afecta cuantas variables podremos usar para ajustar Por ejemplo, si agregamos sexo con 2 opciones, duplicar√≠amos el n√∫mero te√≥rico de columnas pero tal vez no tengamos suficientes datos Si lo llevas al extremo, terminas con los mismos datos de scRNA-seq que con los que empezamos 12.4.2 Convertir a un objeto nuevo Hagamos nuestro an√°lisis de expresi√≥n diferencial Empezaremos con solo un tipo celular: Mesenchyme label &lt;- &quot;Mesenchyme&quot; current &lt;- summed[, label == summed$celltype.mapped] dim(current) ## [1] 14699 6 Vemos que nos quedamos con solo 14,699 genes a lo largo de 6 muestras Esto ser√≠a un experimento peque√±o de bulk RNA-seq Usaremos edgeR de Robinson, McCarthy e Smyth, Bioinformatics, 2010 que es uno de los paquetes m√°s usados para an√°lisis de expresi√≥n diferencial en bulk RNA-seq Aaron Lun, autor de OSCA, se form√≥ por el mismo grupo en Australia # Creating up a DGEList object for use in edgeR: library(&quot;edgeR&quot;) y &lt;- DGEList(counts(current), samples = colData(current)) y ## An object of class &quot;DGEList&quot; ## $counts ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 ## Xkr4 2 0 0 0 3 0 ## Rp1 0 0 1 0 0 0 ## Sox17 7 0 3 0 14 9 ## Mrpl15 1420 271 1009 379 1578 749 ## Rgs20 3 0 1 1 0 0 ## 14694 more rows ... ## ## $samples ## group lib.size norm.factors batch cell barcode sample stage tomato pool ## Sample1 1 4607053 1 5 &lt;NA&gt; &lt;NA&gt; 5 E8.5 TRUE 3 ## Sample2 1 1064970 1 6 &lt;NA&gt; &lt;NA&gt; 6 E8.5 FALSE 3 ## Sample3 1 2494010 1 7 &lt;NA&gt; &lt;NA&gt; 7 E8.5 TRUE 4 ## Sample4 1 1028668 1 8 &lt;NA&gt; &lt;NA&gt; 8 E8.5 FALSE 4 ## Sample5 1 4290221 1 9 &lt;NA&gt; &lt;NA&gt; 9 E8.5 TRUE 5 ## Sample6 1 1950840 1 10 &lt;NA&gt; &lt;NA&gt; 10 E8.5 FALSE 5 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## Sample1 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample2 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample3 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample4 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample5 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample6 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## celltype.mapped.1 sample.1 ncells ## Sample1 Mesenchyme 5 286 ## Sample2 Mesenchyme 6 55 ## Sample3 Mesenchyme 7 243 ## Sample4 Mesenchyme 8 134 ## Sample5 Mesenchyme 9 478 ## Sample6 Mesenchyme 10 299 Listo, ya convertimos nuestros datos al formato que le gusta a edgeR 12.4.3 Pre-procesamiento Antes de poder continuar, vamos a eliminar muestras que construimos con el proceso de pseudo-bulking que no tengan al menos 10 c√©lulas discarded &lt;- current$ncells &lt; 10 y &lt;- y[, !discarded] summary(discarded) ## Mode FALSE ## logical 6 A continuaci√≥n eliminaremos genes que tengan bajos niveles de expresi√≥n keep &lt;- filterByExpr(y, group = current$tomato) y &lt;- y[keep, ] summary(keep) ## Mode FALSE TRUE ## logical 9011 5688 Despu√©s normalizaremos los datos Pero si ya hab√≠amos normalizado los datos de scRNA-seq, ¬øqu√© pas√≥? 23 y &lt;- calcNormFactors(y) y$samples ## group lib.size norm.factors batch cell barcode sample stage tomato pool ## Sample1 1 4607053 1.0683392 5 &lt;NA&gt; &lt;NA&gt; 5 E8.5 TRUE 3 ## Sample2 1 1064970 1.0487418 6 &lt;NA&gt; &lt;NA&gt; 6 E8.5 FALSE 3 ## Sample3 1 2494010 0.9582296 7 &lt;NA&gt; &lt;NA&gt; 7 E8.5 TRUE 4 ## Sample4 1 1028668 0.9774156 8 &lt;NA&gt; &lt;NA&gt; 8 E8.5 FALSE 4 ## Sample5 1 4290221 0.9707300 9 &lt;NA&gt; &lt;NA&gt; 9 E8.5 TRUE 5 ## Sample6 1 1950840 0.9816914 10 &lt;NA&gt; &lt;NA&gt; 10 E8.5 FALSE 5 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## Sample1 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample2 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample3 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample4 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample5 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## Sample6 &lt;NA&gt; Mesenchyme &lt;NA&gt; NA NA &lt;NA&gt; ## celltype.mapped.1 sample.1 ncells ## Sample1 Mesenchyme 5 286 ## Sample2 Mesenchyme 6 55 ## Sample3 Mesenchyme 7 243 ## Sample4 Mesenchyme 8 134 ## Sample5 Mesenchyme 9 478 ## Sample6 Mesenchyme 10 299 calcNormFactors() asume que la mayor√≠a de los genes no est√°n diferencialmente expresados como describen Robinson y Oshlack, Genome Biol., 2010 Podemos visualizar los cambios de expresi√≥n para todos los genes, una muestra a la vez par(mfrow = c(2, 3)) for (i in seq_len(ncol(y))) { plotMD(y, column = i) } Podemos usar t√©cnicas de reducci√≥n de dimensiones como MDS y PCA para explorar la variaci√≥n entre nuestras muestras (ya no c√©lulas) par(mfrow = c(1, 1)) plotMDS(cpm(y, log = TRUE), col = ifelse(y$samples$tomato, &quot;red&quot;, &quot;blue&quot;) ) Podemos repetir el plotMDS() pero con colores por lote (batch) de pool. plotMDS(cpm(y, log = TRUE), col = c(&quot;3&quot; = &quot;darkorchid1&quot;, &quot;4&quot; = &quot;darkblue&quot;, &quot;5&quot; = &quot;tomato4&quot;)[factor(y$samples$pool)] ) Ac√° vemos que si hay diferencias entre lotes, en particular entre el lote de las muestras 1 y 2 y el resto, ya que el eje X explica el 38% de la varianza. 12.4.4 Modelo estad√≠stico Si todo nos parece bien, podemos seguir con definir nuestro modelo estad√≠stico Vamos a ajustar por lote (batch) y encontrar diferencias por la inyecci√≥n de td-Tomato Como empezamos con las cuentas desde cero, tenemos que tomar en cuenta la variaci√≥n por lote de secuenciaci√≥n design &lt;- model.matrix(~ factor(pool) + factor(tomato), y$samples) design ## (Intercept) factor(pool)4 factor(pool)5 factor(tomato)TRUE ## Sample1 1 0 0 1 ## Sample2 1 0 0 0 ## Sample3 1 1 0 1 ## Sample4 1 1 0 0 ## Sample5 1 0 1 1 ## Sample6 1 0 1 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 2 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$`factor(pool)` ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$`factor(tomato)` ## [1] &quot;contr.treatment&quot; Si queremos explorar nuestro modelo estad√≠stico de forma interactiva, podemos usar ExploreModelMatrix por Charlotte Soneson y Michael Love. Charlotte es de las autoras de iSEE. if (interactive()) { ExploreModelMatrix::ExploreModelMatrix(y$samples[, c(&quot;pool&quot;, &quot;tomato&quot;)], ~ factor(pool) + factor(tomato)) } Tal y como en bulk RNA-seq, podemos usar la informaci√≥n de los genes para mejorar nuestros estimados de la varianza para cada gene, de tal forma que mejoramos los resultados estad√≠sticos aunque tengamos pocas muestras y &lt;- estimateDisp(y, design) summary(y$trended.dispersion) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.01026 0.01670 0.02128 0.02020 0.02349 0.02665 plotBCV(y) fit &lt;- glmQLFit(y, design, robust = TRUE) summary(fit$var.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.3179 0.7143 0.8538 0.8045 0.9128 1.0665 summary(fit$df.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.2267 12.6749 12.6749 12.3390 12.6749 12.6749 plotQLDisp(fit) Ahora si podemos correr nuestro modelo est√°distico res &lt;- glmQLFTest(fit, coef = ncol(design)) de_n &lt;- summary(decideTests(res)) de_n ## factor(tomato)TRUE ## Down 8 ## NotSig 5672 ## Up 8 topTags(res) ## Coefficient: factor(tomato)TRUE ## logFC logCPM F PValue FDR ## Phlda2 -4.3873546 9.934130 1638.59469 1.812293e-16 1.030832e-12 ## Erdr1 2.0690698 8.832662 356.36590 1.060836e-11 3.017019e-08 ## Mid1 1.5190728 6.931325 120.14656 1.844351e-08 3.496889e-05 ## H13 -1.0596020 7.540121 80.79795 2.373001e-07 2.526790e-04 ## Kcnq1ot1 1.3762700 7.241651 83.30701 2.392052e-07 2.526790e-04 ## Akr1e1 -1.7205826 5.127802 79.31386 2.665390e-07 2.526790e-04 ## Zdbf2 1.8008336 6.797367 83.66324 6.808994e-07 5.532794e-04 ## Asb4 -0.9234911 7.340648 53.44578 2.918297e-06 2.074909e-03 ## Impact 0.8516300 7.353208 50.31429 4.145416e-06 2.619903e-03 ## Lum -0.6031413 9.274529 41.67104 1.204523e-05 6.851324e-03 Encontramos 16 genes diferencialmente expresados por la inyecci√≥n de td-Tomato. 12.4.5 De forma sencilla Eso fue mucho trabajo, ¬øno? La funci√≥n pseudoBulkDGE() corre todos esos pasos por nosotros # Removing all pseudo-bulk samples with &#39;insufficient&#39; cells. summed.filt &lt;- summed[, summed$ncells &gt;= 10] library(&quot;scran&quot;) de.results &lt;- pseudoBulkDGE(summed.filt, label = summed.filt$celltype.mapped, design = ~ factor(pool) + tomato, coef = &quot;tomatoTRUE&quot;, condition = summed.filt$tomato ) class(de.results) ## [1] &quot;SimpleList&quot; ## attr(,&quot;package&quot;) ## [1] &quot;S4Vectors&quot; length(de.results) ## [1] 23 Nos regresa una lista con los resultados para cada uno de nuestros tipos celulares Podemos extraer los resultados para nuestro tipo celular de inter√©s, por ejemplo Allantois. cur.results &lt;- de.results[[&quot;Allantois&quot;]] cur.results[order(cur.results$PValue), ] ## DataFrame with 14699 rows and 5 columns ## logFC logCPM F PValue FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Phlda2 -2.489508 12.58150 1207.016 3.33486e-21 1.60507e-17 ## Xist -7.978532 8.00166 1092.831 1.27783e-17 3.07510e-14 ## Erdr1 1.947170 9.07321 296.937 1.58009e-14 2.53500e-11 ## Slc22a18 -4.347153 4.04380 117.389 1.92517e-10 2.31647e-07 ## Slc38a4 0.891849 10.24094 113.899 2.52208e-10 2.42776e-07 ## ... ... ... ... ... ... ## Ccl27a_ENSMUSG00000095247 NA NA NA NA NA ## CR974586.5 NA NA NA NA NA ## AC132444.6 NA NA NA NA NA ## Vmn2r122 NA NA NA NA NA ## CAAA01147332.1 NA NA NA NA NA y.allantois &lt;- metadata(cur.results)$y plotBCV(y.allantois) Tambi√©n nos dice que tipos celulares fallaron porque no ten√≠amos suficiente informaci√≥n para hacer el an√°lisis metadata(de.results)$failed ## [1] &quot;Blood progenitors 1&quot; &quot;Caudal epiblast&quot; &quot;Caudal neurectoderm&quot; ## [4] &quot;ExE ectoderm&quot; &quot;Parietal endoderm&quot; &quot;Stripped&quot; Aqu√≠ podemos hacer la misma gr√°fica que hicimos de forma manual para Mesenchyme. cur.results.Mesenchyme &lt;- de.results[[&quot;Mesenchyme&quot;]] y.Mesenchyme &lt;- metadata(cur.results.Mesenchyme)$y plotBCV(y.Mesenchyme) 12.4.6 Ejercicios 12.4.6.1 Pseudo-bulking Hagamos el c√°lculo de pseudo-bulking de forma manual para la primera muestra de summed y el gene con los valores m√°s altos de expresi√≥n para esa muestra. Es decir, trabajaremos con el siguiente gene. colData(summed)[1, ] ## DataFrame with 1 row and 16 columns ## batch cell barcode sample stage tomato pool ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;logical&gt; &lt;integer&gt; ## 1 5 NA NA 5 E8.5 TRUE 3 ## stage.mapped celltype.mapped closest.cell doub.density sizeFactor label ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; ## 1 NA Allantois NA NA NA NA ## celltype.mapped sample ncells ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## 1 Allantois 5 97 which.max(counts(summed)[, 1]) ## Ptma ## 360 Usa el objeto merged para volver a calcular el siguiente valor. counts(summed)[which.max(counts(summed)[, 1]), 1] ## Ptma ## 22802 12.4.6.2 Visualizaci√≥n de resultados de expresi√≥n diferencial Usando los resultados de expresi√≥n diferencial para el tipo celular Mesenchyme, reproduce la siguiente visualizaci√≥n. ## Warning: Removed 9011 rows containing missing values (geom_point). Explora la informaci√≥n que tenemos en cur.results.Mesenchyme. Si usas el paquete ggplot2, tendr√°s que usar as.data.frame() para convertir un objeto DFrame a un data.frame. Revisa que valores salen en cada eje y en los colores. Tal vez algunos valores tiene alguna transformaci√≥n. ¬øPor qu√© sale un warning diciendo que eliminamos 9011 puntos? 24 12.4.7 Respuestas 12.4.7.1 Pseudo-bulking ## Valor esperado counts(summed)[which.max(counts(summed)[, 1]), 1] ## Ptma ## 22802 ## Respuesta sum(counts(merged)[ names(which.max(counts(summed)[, 1])), merged$celltype.mapped == &quot;Allantois&quot; &amp; merged$sample == 5 ]) ## [1] 22802 ## Otra versi√≥n sum(counts(merged)[ &quot;Ptma&quot;, with(colData(merged), celltype.mapped == &quot;Allantois&quot; &amp; sample == 5) ]) ## [1] 22802 12.4.7.2 Visualizaci√≥n de resultados de expresi√≥n diferencial library(&quot;ggplot2&quot;) ## class(cur.results.Mesenchyme) # [1] &quot;DFrame&quot; # attr(,&quot;package&quot;) # [1] &quot;S4Vectors&quot; df &lt;- as.data.frame(cur.results.Mesenchyme) df$label &lt;- rownames(df) p &lt;- ggplot( df, aes( x = logFC, y = -log10(PValue), color = FDR &lt; 0.05, label = label ) ) + geom_point() p ## Warning: Removed 9011 rows containing missing values (geom_point). Este tipo de gr√°fica es un volcano plot donde vemos en el eje X el cambio de expresi√≥n y en el eje Y el valor p transformado con -log10(p). Usamos colores para marcar los genes con un FDR &lt; 0.05. 12.4.7.3 Con etiquetas Podemos agregarle etiquetas usando el paquete ggrepel. p + ggrepel::geom_text_repel(data = subset(df, FDR &lt; 0.05)) ## Warning: Removed 9011 rows containing missing values (geom_point). 12.4.7.4 Versi√≥n interactiva O podemos hacer una versi√≥n interactiva con plotly. plotly::ggplotly(p) 12.5 An√°lisis de abundancia diferencial table(merged$sample) ## ## 5 6 7 8 9 10 ## 2298 1026 2740 2904 4057 6401 Si recuerdan, tenemos 6 muestras en total. üëâ Otro tipo de an√°lisis que podemos hacer es preguntarnos si cambi√≥ la composici√≥n celular entre nuestras muestras con y sin la inyecci√≥n de td-Tomato. üëâ Este tipo de an√°lisis nos dir√° que tipos celulares cambiaron de acuerdo a nuestras condiciones de inter√©s, que puede ser igual de interesante que encontrar genes diferencialmente expresados. üëâ Es como si scRNA-seq fuera un super-FACS donde usamos todo el transcriptoma. Hagamos una tabla de la frecuencia de cada tipo celular a lo largo de nuestras muestras. Es decir, una tabla de abundancias abundances &lt;- table(merged$celltype.mapped, merged$sample) abundances &lt;- unclass(abundances) head(abundances) ## ## 5 6 7 8 9 10 ## Allantois 97 15 139 127 318 259 ## Blood progenitors 1 6 3 16 6 8 17 ## Blood progenitors 2 31 8 28 21 43 114 ## Cardiomyocytes 85 21 79 31 174 211 ## Caudal epiblast 2 2 0 0 22 45 ## Caudal Mesoderm 10 10 9 3 10 29 A esta tabla le podemos agregar algo de informaci√≥n de nuestras muestras, y con eso construir un objeto del tipo que le gusta a edgeR # Attaching some column metadata. extra.info &lt;- colData(merged)[match(colnames(abundances), merged$sample), ] y.ab &lt;- DGEList(abundances, samples = extra.info) y.ab ## An object of class &quot;DGEList&quot; ## $counts ## ## 5 6 7 8 9 10 ## Allantois 97 15 139 127 318 259 ## Blood progenitors 1 6 3 16 6 8 17 ## Blood progenitors 2 31 8 28 21 43 114 ## Cardiomyocytes 85 21 79 31 174 211 ## Caudal epiblast 2 2 0 0 22 45 ## 29 more rows ... ## ## $samples ## group lib.size norm.factors batch cell barcode sample stage ## 5 1 2298 1 5 cell_9769 AAACCTGAGACTGTAA 5 E8.5 ## 6 1 1026 1 6 cell_12180 AAACCTGCAGATGGCA 6 E8.5 ## 7 1 2740 1 7 cell_13227 AAACCTGAGACAAGCC 7 E8.5 ## 8 1 2904 1 8 cell_16234 AAACCTGCAAACCCAT 8 E8.5 ## 9 1 4057 1 9 cell_19332 AAACCTGCAACGATCT 9 E8.5 ## 10 1 6401 1 10 cell_23875 AAACCTGAGGCATGTG 10 E8.5 ## tomato pool stage.mapped celltype.mapped closest.cell ## 5 TRUE 3 E8.25 Mesenchyme cell_24159 ## 6 FALSE 3 E8.25 Somitic mesoderm cell_63247 ## 7 TRUE 4 E8.5 Somitic mesoderm cell_25454 ## 8 FALSE 4 E8.25 ExE mesoderm cell_139075 ## 9 TRUE 5 E8.0 ExE mesoderm cell_116116 ## 10 FALSE 5 E8.5 Forebrain/Midbrain/Hindbrain cell_39343 ## doub.density sizeFactor label ## 5 0.02985045 1.6348759 19 ## 6 0.29191572 2.5980769 6 ## 7 0.60173979 1.5939009 17 ## 8 0.00473259 0.8707367 9 ## 9 0.07941464 0.8932525 15 ## 10 0.04074704 0.3947355 1 A diferencia de los an√°lisis de expresi√≥n diferencial, no usaremos calcNormFactors() porque este tipo de an√°lisis no cumple, generalmente, con las condiciones del m√©todo estad√≠stico A continuaci√≥n filtramos los tipos celulares para los cuales no tenemos suficiente informaci√≥n, si es el caso keep &lt;- filterByExpr(y.ab, group = y.ab$samples$tomato) y.ab &lt;- y.ab[keep, ] summary(keep) ## Mode FALSE TRUE ## logical 10 24 Luego hacemos nuestro an√°lisis de abundancia con edgeR el cual nos permite usar el modelo estad√≠stico que est√° dise√±ado para valores enteros (cuentas) y pocas r√©plicas Es la misma form√∫la del modelo estad√≠stico (design) que usamos anteriormente, pero para otros n√∫meros design &lt;- model.matrix(~ factor(pool) + factor(tomato), y.ab$samples) design ## (Intercept) factor(pool)4 factor(pool)5 factor(tomato)TRUE ## 5 1 0 0 1 ## 6 1 0 0 0 ## 7 1 1 0 1 ## 8 1 1 0 0 ## 9 1 0 1 1 ## 10 1 0 1 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 2 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$`factor(pool)` ## [1] &quot;contr.treatment&quot; ## ## attr(,&quot;contrasts&quot;)$`factor(tomato)` ## [1] &quot;contr.treatment&quot; y.ab &lt;- estimateDisp(y.ab, design, trend = &quot;none&quot;) summary(y.ab$common.dispersion) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0614 0.0614 0.0614 0.0614 0.0614 0.0614 plotBCV(y.ab, cex = 1) A diferencia de antes, tenemos pocos puntos (antes eran genes, ahora son tipos celulares), as√≠ que no estimaremos una curva, por eso usamos abundance.trend = FALSE fit.ab &lt;- glmQLFit(y.ab, design, robust = TRUE, abundance.trend = FALSE) summary(fit.ab$var.prior) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.254 1.254 1.254 1.254 1.254 1.254 plotQLDisp(fit.ab, cex = 1) Corremos el an√°lisis res &lt;- glmQLFTest(fit.ab, coef = ncol(design)) summary(decideTests(res)) ## factor(tomato)TRUE ## Down 1 ## NotSig 22 ## Up 1 topTags(res) ## Coefficient: factor(tomato)TRUE ## logFC logCPM F PValue ## ExE ectoderm -6.5663339 13.02497 66.266874 1.352022e-10 ## Mesenchyme 1.1651500 16.29382 11.290523 1.534506e-03 ## Allantois 0.8345294 15.50702 5.312163 2.554581e-02 ## Cardiomyocytes 0.8484008 14.86430 5.203963 2.701306e-02 ## Neural crest -0.7706378 14.76462 4.106177 4.830292e-02 ## Endothelium 0.7518608 14.28905 3.911511 5.371320e-02 ## Erythroid3 -0.6430834 17.28041 3.603666 6.367366e-02 ## Haematoendothelial progenitors 0.6581135 14.72323 3.123946 8.350641e-02 ## ExE mesoderm 0.3805309 15.67835 1.180627 2.826550e-01 ## Pharyngeal mesoderm 0.3793160 15.72073 1.169279 2.849523e-01 ## FDR ## ExE ectoderm 3.244852e-09 ## Mesenchyme 1.841407e-02 ## Allantois 1.620784e-01 ## Cardiomyocytes 1.620784e-01 ## Neural crest 2.148528e-01 ## Endothelium 2.148528e-01 ## Erythroid3 2.183097e-01 ## Haematoendothelial progenitors 2.505192e-01 ## ExE mesoderm 6.257608e-01 ## Pharyngeal mesoderm 6.257608e-01 Entre los tipos celulares donde ten√≠amos suficiente informaci√≥n, solo 2 muestran diferencias en sus niveles de frecuencia entre las muestras con y sin inyecciones de td-Tomato. 12.6 Comentarios sobre la interpretaci√≥n üëâ La distinci√≥n entre ambos tipos de an√°lisis en scRNA-seq es articial Las etiquetas que usamos para el an√°lisis de abundancia est√°n definidas por los niveles de expresi√≥n de los genes Este tema de cuantas veces usas los datos y como eso afecta las pruebas estad√≠sticas que usamos es un tema de investigaci√≥n actual In a talk that was as clear as her book ‚Äúintro to stat learning‚Äù, today's #bioc2021 keynote @daniela_witten showed how double dipping (e.g.¬†using genes to cluster data and then testing for DE between clusters) leads to + type 1 error and an intuitive method to correct this prob. ‚Äî Alejandro Reyes (@areyesq) August 4, 2021 Les recomiendo que lean detenidamente esa parte en OSCA 12.7 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:48:17 UTC&quot; proc.time() ## user system elapsed ## 346.357 28.645 347.347 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## batchelor * 1.8.1 2021-08-12 [1] Bioconductor ## beachmat 2.8.1 2021-08-12 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster * 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## BumpyMatrix 1.0.1 2021-07-04 [1] Bioconductor ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## edgeR * 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma * 3.48.3 2021-08-10 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magick 2.7.2 2021-05-02 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## MouseGastrulationData * 1.6.0 2021-05-20 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## Polychrome * 1.3.1 2021-07-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.4 2021-08-17 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scatterplot3d 0.3-41 2018-03-14 [1] RSPM (R 4.1.0) ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## SpatialExperiment * 1.2.1 2021-06-10 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Empezamos de nuevo con las cuentas originales en y &lt;- DGEList(counts(current), samples=colData(current)) y no las normalizadas.‚Ü©Ô∏é Revisa cu√°ntos genes no pasaron nuestro filtro de expresi√≥n cuando lo hicimos de forma manual en nuestro objeto keep. Corre otra vez table(keep).‚Ü©Ô∏é "],["introducci√≥n-a-seurat.html", "13 Introducci√≥n a Seurat 13.1 Diapositivas 13.2 Una perspectiva diferente 13.3 Kick-start 13.4 Quality Control 13.5 Normalizaci√≥n 13.6 Detecci√≥n de genes (caractersticas) altamente variables 13.7 Escalar los datos 13.8 Reducci√≥n dimensional lineal 13.9 Determinar la dimensionalidad del conjunto de datos 13.10 Clustering 13.11 Reducci√≥n dimensional no lineal (UMAP/tSNE) 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) 13.13 Assigning cell type identity to clusters 13.14 Guardar Resultados 13.15 Detalles de la sesi√≥n de R Patrocinadores", " 13 Introducci√≥n a Seurat Instructor: Kevin E. Meza-Landeros 13.1 Diapositivas Presentaci√≥n: aqu√≠ 13.2 Una perspectiva diferente Seurat es un paquete R dise√±ado para control de calidad, an√°lisis y exploraci√≥n de datos de secuencia de ARN de una sola c√©lula. Seurat tiene como objetivo permitir a los usuarios identificar e interpretar fuentes de heterogeneidad a partir de mediciones transcript√≥micas unicelulares e integrar diversos tipos de datos unicelulares. Seurat es desarrollado y mantenido por el laboratorio de Satija y se publica bajo la Licencia P√∫blica GNU (GPL 3.0). En este tutorial se ve como procesar los datos de scRNAseq con un nuevo paquete. Los pasos a realizar son en esencia los mismos que ya revisamos con el tutorial de la OSCA de RStudio. No olvides nunca que el paquete mas adecuado y que deber√°s utilizar depender√° mayoritariamente de tus datos y el procesamiento que se adec√∫e a estos. Adem√°s‚Ä¶ siempre es bueno diversos puntos de vista sobre las cosas, ¬øno es as√≠? Aprende mas sobre Seurat: aqu√≠ 13.3 Kick-start En este tutorial partimos a partir de que ya se tienen los archivos FASTQ resultados de secuenciaci√≥n. ¬øCon qu√© datos estoy trabajando? Peripheral Blood Mononuclear Cells (PBMC) disponibles gratuitamente de 10X Genomics. Son en total 2,700 c√©luas √∫nicas secuenciadas con Illumina NextSeq 500. Puedes descargar los datos de aqu√≠ (7.3MB). Descarga el archivo comprimido y procede a descomprimirlo. Se creara el siguiente directorio filtered_gene_bc_matrices/hg19/, aqu√≠ estar√°n los archivos que necesitaremos. A continuaci√≥n lo haremos con c√≥digo de R. Este tutorial solo es la punta del iceberg de lo que se puede hacer con la paquetera de Seurat. Para comenzar a sumergirte en este mundo no dudes en visitar la p√°gina oficial mantenida por Satija Lab Vignettes A continuaci√≥n estableceremos nuestros directorio de trabajo y leeremos los datos anteriores. La funci√≥n Read10X() lee en la salida de cellranger de 10X (de donde se obtuvieron los FASTQs), devolviendo una matriz de recuento √∫nica identificada molecularmente (UMI). Los valores en esta matriz representan el n√∫mero de mol√©culas para cada caracter√≠stica (es decir, gen; fila) que se detectan en cada c√©lula (columna). ## Cargar paquetes de R library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;dplyr&quot;) ## para filtar datos library(&quot;Seurat&quot;) ## paquete principal de este cap√≠tulo library(&quot;patchwork&quot;) ## para graficar im√°genes juntas # Usemos datos de pbmc3k tal y como lo hacen en # https://satijalab.org/seurat/articles/pbmc3k_tutorial.html # pero con nuestro propio c√≥digo bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&quot; )) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc3k&quot;)) fname &lt;- file.path(tempdir(), &quot;pbmc3k/filtered_gene_bc_matrices/hg19&quot;) # Load the PBMC dataset pbmc.data &lt;- Read10X(data.dir = fname) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) Veamos la estructura del Objeto de Seurat str(pbmc) ## Formal class &#39;Seurat&#39; [package &quot;SeuratObject&quot;] with 13 slots ## ..@ assays :List of 1 ## .. ..$ RNA:Formal class &#39;Assay&#39; [package &quot;SeuratObject&quot;] with 8 slots ## .. .. .. ..@ counts :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ data :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ scale.data : num[0 , 0 ] ## .. .. .. ..@ key : chr &quot;rna_&quot; ## .. .. .. ..@ assay.orig : NULL ## .. .. .. ..@ var.features : logi(0) ## .. .. .. ..@ meta.features:&#39;data.frame&#39;: 13714 obs. of 0 variables ## .. .. .. ..@ misc : list() ## ..@ meta.data :&#39;data.frame&#39;: 2700 obs. of 3 variables: ## .. ..$ orig.ident : Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ nCount_RNA : num [1:2700] 2419 4903 3147 2639 980 ... ## .. ..$ nFeature_RNA: int [1:2700] 779 1352 1129 960 521 781 782 790 532 550 ... ## ..@ active.assay: chr &quot;RNA&quot; ## ..@ active.ident: Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## ..@ graphs : list() ## ..@ neighbors : list() ## ..@ reductions : list() ## ..@ images : list() ## ..@ project.name: chr &quot;pbmc3k&quot; ## ..@ misc : list() ## ..@ version :Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. ..$ : int [1:3] 4 0 2 ## ..@ commands : list() ## ..@ tools : list() ¬øC√≥mo accedemos a cada slot? Clase Seurat. La informaci√≥n resumida sobre los objetos de Seurat se puede obtener de forma r√°pida y sencilla mediante las funciones est√°ndar de R. La forma / dimensiones del objeto se pueden encontrar usando las funciones dim(), ncol() y nrow(); Los nombres de celda y caracter√≠stica se pueden encontrar usando las funciones colnames() y rownames(), respectivamente, o la funci√≥n dimnames(). Se puede obtener un vector de nombres de objetos Assay, DimReduc y Graph contenidos en un objeto Seurat mediante el uso de nombres. dim(pbmc) ## [1] 13714 2700 head(rownames(pbmc)) ## [1] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ## [5] &quot;LINC00115&quot; &quot;NOC2L&quot; head(colnames(pbmc)) ## [1] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ## [5] &quot;AAACCGTGTATGCG-1&quot; &quot;AAACGCACTGGTAC-1&quot; Se puede obtener un vector de nombres de objetos Assay, DimReduc y Graph contenidos en un objeto Seurat mediante el uso de nombres. La extracci√≥n de objetos espec√≠ficos de Assay, DimReduc o Graph se puede realizar con el operador doble [[ ]] extract. La adici√≥n de nuevos objetos a un objeto de Seurat tambi√©n se hace con el operador doble [[ ]] extract; Seurat averiguar√° a qu√© parte del objeto Seurat pertenece un nuevo objeto asociado. names(pbmc) ## [1] &quot;RNA&quot; pbmc[[&quot;RNA&quot;]] ## Assay data with 13714 features for 2700 cells ## First 10 features: ## AL627309.1, AP006222.2, RP11-206L10.2, RP11-206L10.9, LINC00115, NOC2L, ## KLHL17, PLEKHN1, RP11-54O7.17, HES4 # pbmc[[&#39;tsne&#39;]] El acceso a los datos de un objeto Seurat se realiza con la funci√≥n GetAssayData(). La adici√≥n de datos de expresi√≥n a counts, data, o scale.data se puede hacer con SetAssayData(). Los datos nuevos deben tener las mismas celdas en el mismo orden que los datos de la expresi√≥n actual. Los datos agregados a los recuentos o datos deben tener las mismas caracter√≠sticas que los datos de la expresi√≥n actual. GetAssayData(object = pbmc, slot = &quot;data&quot;)[1:3, 1:3] ## 3 x 3 sparse Matrix of class &quot;dgCMatrix&quot; ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 ## AL627309.1 . . . ## AP006222.2 . . . ## RP11-206L10.2 . . . Metadata de las C√©lulas. Se puede acceder a los metadatos a nivel de celda con el operador de extracci√≥n [[ ]] extract o usando $sigil. Extraer con $sigil significa que solo se puede extraer un bit de metadatos a la vez, aunque se ha habilitado el autocompletado de pesta√±as, lo que lo hace ideal para uso interactivo. La adici√≥n de metadatos a nivel de celda se puede configurar usando el operador de extracci√≥n √∫nico [[ ]] tambi√©n, o usando AddMetaData. head(pbmc@meta.data) ## orig.ident nCount_RNA nFeature_RNA ## AAACATACAACCAC-1 pbmc3k 2419 779 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 ## AAACCGTGTATGCG-1 pbmc3k 980 521 ## AAACGCACTGGTAC-1 pbmc3k 2163 781 head(pbmc[[c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;)]]) ## nCount_RNA nFeature_RNA ## AAACATACAACCAC-1 2419 779 ## AAACATTGAGCTAC-1 4903 1352 ## AAACATTGATCAGC-1 3147 1129 ## AAACCGTGCTTCCG-1 2639 960 ## AAACCGTGTATGCG-1 980 521 ## AAACGCACTGGTAC-1 2163 781 # Passing `drop = TRUE` will turn the meta data into a names vector # with each entry being named for the cell it corresponds to head(pbmc[[&quot;nCount_RNA&quot;, drop = TRUE]]) ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 ## 2419 4903 3147 2639 ## AAACCGTGTATGCG-1 AAACGCACTGGTAC-1 ## 980 2163 La clase Assay almacena datos de una sola celda. Para los experimentos t√≠picos de scRNA-seq, un objeto Seurat tendr√° un √∫nico ensayo (‚ÄúRNA‚Äù). Este ensayo tambi√©n almacenar√° m√∫ltiples ‚Äòtransformaciones‚Äô de los datos, incluidos recuentos sin procesar (ranura @counts), datos normalizados (ranura @data) y datos escalados para la reducci√≥n dimensional (ranura @scale.data). Para experimentos m√°s complejos, un objeto podr√≠a contener m√∫ltiples ensayos. Estos podr√≠an incluir tipos de datos multimodales (etiquetas derivadas de anticuerpos CITE-seq, ADT) o mediciones imputadas / corregidas por lotes. Cada uno de esos ensayos tiene la opci√≥n de almacenar tambi√©n las mismas transformaciones de datos. ¬øC√≥mo se ven los datos en una matriz de recuento? Examinemos algunos genes en las primeras treinta c√©lulas. Los valores en la matriz representan ceros (no se detectan mol√©culas). Dado que la mayor√≠a de los valores en una matriz scRNA-seq son 0, Seurat utiliza una representaci√≥n de matriz dispersa (sparse matrix) siempre que sea posible. Esto da como resultado un ahorro significativo de memoria y velocidad. pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 30 column names &#39;AAACATACAACCAC-1&#39;, &#39;AAACATTGAGCTAC-1&#39;, &#39;AAACATTGATCAGC-1&#39; ... ]] ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . dense.size &lt;- object.size(as.matrix(pbmc.data)) dense.size ## 709591472 bytes sparse.size &lt;- object.size(pbmc.data) sparse.size ## 29905192 bytes dense.size / sparse.size ## 23.7 bytes ¬°EN ESTE CASO UNA MATRIZ NO DISPERSA OCUPA ~ 24 VECES MAS ESPACIO! 13.4 Quality Control Algunas m√©tricas de control de calidad com√∫nmente utilizadas por la comunidad incluyen: El n√∫mero de genes √∫nicos detectados en cada c√©lula. Las c√©lulas de baja calidad o las gotitas vac√≠as suelen tener muy pocos genes. Los dobletes o multipletes celulares pueden exhibir un recuento de genes aberrantemente alto De manera similar, el n√∫mero total de mol√©culas detectadas dentro de una c√©lula (se correlaciona fuertemente con genes √∫nicos). El porcentaje de lecturas que se asignan al genoma mitocondrial. Las c√©lulas de baja calidad / moribundas a menudo exhiben una extensa contaminaci√≥n mitocondrial Calculamos m√©tricas de control de calidad mitocondrial con la funci√≥n PercentageFeatureSet(), que calcula el porcentaje de recuentos que se originan a partir de un conjunto de caracter√≠sticas. El operador [[ puede agregar columnas a los metadatos del objeto. Este es un gran lugar para almacenar estad√≠sticas de control de calidad. Entonces calculamos y a√±adimos la cantidad de lecturas que corresponden al genoma mitocondrial. pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) Visualizamos las m√©tricas de control de calidad mencionadas anteriormente como un diagrama de viol√≠n. Ademas vemos la correlaci√≥n entre el numero de mol√©culas de RNA detectadas en cada c√©lula con el n√∫mero de genes √∫nicos y con el porcentaje de lecturas que corresponden a mtADN. VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 Finalmente filtramos aquellas c√©lulas que se salen de los est√°ndares de cada uno de los par√°metros. # Filter pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) ¬øD√≥nde se almacenan la m√©tricas de QC en Seurat? Est√°n almacenadas en la seccion de @meta.data del objeto Seurat. head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 13.5 Normalizaci√≥n De forma predeterminada, se emplea un m√©todo de normalizaci√≥n de escala global ‚ÄúLogNormalize‚Äù que normaliza las medidas de expresi√≥n de caracter√≠sticas para cada c√©lula por la expresi√≥n total, multiplica esto por un factor de escala (10.000 por defecto) y transforma el resultado en logaritmos. Los valores normalizados se almacenan en pbmc [[\"RNA\"]]@data. pbmc &lt;- NormalizeData(pbmc, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) 13.6 Detecci√≥n de genes (caractersticas) altamente variables A continuaci√≥n, calculamos un subconjunto de caracter√≠sticas que exhiben una alta variaci√≥n de c√©lula a c√©lula en el conjunto de datos (es decir, est√°n altamente expresadas en algunas c√©lulas y poco expresadas en otras). El equipo de Seurat y otros equipos han descubierto que centrarse en estos genes en el an√°lisis posterior ayuda a resaltar la se√±al biol√≥gica en conjuntos de datos unicelulares. El procedimiento en Seurat mejora a comparaci√≥n de las versiones anteriores al modelar directamente la relaci√≥n de varianza media inherente a los datos de una sola c√©lula, y se implementa en la funci√≥n FindVariableFeatures(). De forma predeterminada, se devuelven 2000 caracter√≠sticas por conjunto de datos (aunque se puede modificar). Estos se utilizar√°n en an√°lisis posteriores, como PCA. pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) top10 ## [1] &quot;PPBP&quot; &quot;LYZ&quot; &quot;S100A9&quot; &quot;IGLL5&quot; &quot;GNLY&quot; &quot;FTL&quot; &quot;PF4&quot; &quot;FTH1&quot; ## [9] &quot;GNG11&quot; &quot;S100A8&quot; # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results plot1 + plot2 ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). 13.7 Escalar los datos A continuaci√≥n, aplicamos una transformaci√≥n lineal (‚Äúescalado‚Äù) que es un paso de preprocesamiento est√°ndar antes de las t√©cnicas de reducci√≥n dimensional como PCA. La funci√≥n ScaleData(): Cambia la expresi√≥n de cada gen, de modo que la expresi√≥n media en las c√©lulas sea 0 Escala la expresi√≥n de cada gen, de modo que la varianza entre las c√©lulas sea 1 Este paso otorga el mismo peso en los an√°lisis posteriores, de modo que los genes altamente expresados no dominen Los resultados de esto se almacenan en pbmc [[\"RNA\"]]@scale.data. all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes) ## Centering and scaling data matrix 13.8 Reducci√≥n dimensional lineal A continuaci√≥n, realizamos PCA sobre los datos escalados. De forma predeterminada, solo las caracter√≠sticas variables determinadas previamente se utilizan como entrada, pero se pueden definir mediante el argumento de caracter√≠sticas si desea elegir un subconjunto diferente. pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL, FTH1, LYZ, FCN1, S100A9, TYMP ## FCER1G, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, IFITM3, SPI1, CFP ## PSAP, IFI30, SAT1, COTL1, S100A11, NPC2, GRN, LGALS3, GSTP1, PYCARD ## Negative: MALAT1, LTB, IL32, IL7R, CD2, B2M, ACAP1, CD27, STK17A, CTSW ## CD247, GIMAP5, AQP3, CCL5, SELL, TRAF3IP3, GZMA, MAL, CST7, ITM2A ## MYC, GIMAP7, HOPX, BEX2, LDLRAP1, GZMK, ETS1, ZAP70, TNFAIP8, RIC3 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1, HLA-DRA, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DMA, HLA-DPB1, HLA-DQA2, CD37, HLA-DRB5, HLA-DMB, HLA-DPA1, FCRLA, HVCN1, LTB ## BLNK, P2RX5, IGLL5, IRF8, SWAP70, ARHGAP24, FCGR2B, SMIM14, PPP1R14A, C16orf74 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA, FGFBP2, CTSW, GNLY, B2M, SPON2 ## CCL4, GZMH, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX ## TTC38, APMAP, CTSC, S100A4, IGFBP7, ANXA1, ID2, IL32, XCL1, RHOC ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, HLA-DPA1, CD74, MS4A1, HLA-DRB1, HLA-DRA ## HLA-DRB5, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, CD37, HVCN1, FCRLA, IRF8 ## PLAC8, BLNK, MALAT1, SMIM14, PLD4, LAT2, IGLL5, P2RX5, SWAP70, FCGR2B ## Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU ## HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, PTCRA, CA2, ACRBP, MMD, TREML1 ## NGFRAP1, F13A1, SEPT5, RUFY1, TSC22D1, MPP1, CMTM5, RP11-367G6.3, MYL9, GP1BA ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1, CD74, HLA-DPB1, HIST1H2AC, PF4, TCL1A ## SDPR, HLA-DPA1, HLA-DRB1, HLA-DQA2, HLA-DRA, PPBP, LINC00926, GNG11, HLA-DRB5, SPARC ## GP9, AP001189.4, CA2, PTCRA, CD9, NRGN, RGS18, GZMB, CLU, TUBB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8, S100A4, GIMAP7, S100A10, S100A9, MAL ## AQP3, CD2, CD14, FYB, LGALS2, GIMAP4, ANXA1, CD27, FCN1, RBP7 ## LYZ, S100A11, GIMAP5, MS4A6A, S100A12, FOLR3, TRABD2A, AIF1, IL8, IFI6 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY, CCL4, CST7, PRF1, GZMA, SPON2 ## GZMH, S100A9, LGALS2, CCL3, CTSW, XCL2, CD14, CLIC3, S100A12, CCL5 ## RBP7, MS4A6A, GSTP1, FOLR3, IGFBP7, TYROBP, TTC38, AKR1C3, XCL1, HOPX ## Negative: LTB, IL7R, CKB, VIM, MS4A7, AQP3, CYTIP, RP11-290F20.3, SIGLEC10, HMOX1 ## PTGES3, LILRB2, MAL, CD27, HN1, CD2, GDI2, ANXA5, CORO1B, TUBA1B ## FAM110A, ATP1A1, TRADD, PPA1, CCDC109B, ABRACL, CTD-2006K23.1, WARS, VMO1, FYB Seurat proporciona varias formas √∫tiles de visualizar tanto las c√©lulas como las caracter√≠sticas que definen el PCA, incluidas VizDimReduction(), DimPlot() y DimHeatmap(). Puedes examinar y visualizar los resultados de PCA de diferentes formas. print(pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) En particular, DimHeatmap() permite una f√°cil exploraci√≥n de las fuentes primarias de heterogeneidad en un conjunto de datos y puede ser √∫til cuando se intenta decidir qu√© PC incluir para an√°lisis posteriores posteriores. Tanto las c√©lulas como las caracter√≠sticas se ordenan de acuerdo con sus puntajes de PCA. Establecer cells en un n√∫mero traza las c√©lulas ‚Äúextremas‚Äù en ambos extremos del espectro, lo que acelera dr√°sticamente el trazado de grandes conjuntos de datos. Aunque claramente es un an√°lisis supervisado, consideramos que esta es una herramienta valiosa para explorar conjuntos de caracter√≠sticas correlacionadas. DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) 13.9 Determinar la dimensionalidad del conjunto de datos Para superar el extenso ruido t√©cnico en cualquier caracter√≠stica √∫nica para los datos de scRNA-seq, Seurat agrupa las c√©lulas en funci√≥n de sus puntuaciones de PCA, y cada PC representa esencialmente una ‚Äúmetafunci√≥n‚Äù que combina informaci√≥n en un conjunto de caracter√≠sticas correlacionadas. Por lo tanto, los componentes principales principales representan una compresi√≥n s√≥lida del conjunto de datos. Sin embargo, ¬øcu√°ntos componentes deber√≠amos elegir incluir? 10? 20? 100? En Macosko et al, implementamos una prueba de remuestreo inspirada en el procedimiento JackStraw. Permutamos aleatoriamente un subconjunto de los datos (1% por defecto) y volvemos a ejecutar PCA, construyendo una ‚Äúdistribuci√≥n nula‚Äù de puntuaciones de caracter√≠sticas, y repetimos este procedimiento. Identificamos PC ‚Äúimportantes‚Äù como aquellas que tienen un gran enriquecimiento de caracter√≠sticas de bajo valor p.¬† # NOTE: This process can take a long time for big datasets, comment out for expediency. More # approximate techniques such as those implemented in ElbowPlot() can be used to reduce # computation time pbmc &lt;- JackStraw(pbmc, num.replicate = 100) pbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20) La funci√≥n JackStrawPlot() proporciona una herramienta de visualizaci√≥n para comparar la distribuci√≥n de los p-values para cada PC con una distribuci√≥n uniforme (l√≠nea discontinua). Las PC ‚Äúsignificativas‚Äù mostrar√°n un gran enriquecimiento de funciones con valores p bajos (curva s√≥lida por encima de la l√≠nea discontinua). En este caso, parece que hay una fuerte ca√≠da en la importancia despu√©s de los primeros 10-12 PCs. JackStrawPlot(pbmc, dims = 1:15) ## Warning: Removed 23504 rows containing missing values (geom_point). Un m√©todo heur√≠stico alternativo genera un ‚Äúdiagrama de codo (Elbow Plot)‚Äù: una clasificaci√≥n de componentes principales basada en el porcentaje de varianza explicada por cada uno (funci√≥n ElbowPlot()). En este ejemplo, podemos observar un ‚Äúcodo‚Äù alrededor de PC9-10, lo que sugiere que la mayor parte de la se√±al verdadera se captura en las primeras 10 PC. ElbowPlot(pbmc) 13.10 Clustering pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) ## Computing nearest neighbor graph ## Computing SNN pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95965 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8723 ## Number of communities: 9 ## Elapsed time: 0 seconds 13.11 Reducci√≥n dimensional no lineal (UMAP/tSNE) Seurat ofrece varias t√©cnicas de reducci√≥n dimensional no lineal, como tSNE y UMAP, para visualizar y explorar estos conjuntos de datos. El objetivo de estos algoritmos es aprender la variedad subyacente de los datos para colocar c√©lulas similares juntas en un espacio de baja dimensi√≥n. Las c√©lulas dentro de los grupos basados en gr√°ficos determinados anteriormente deben ubicarse conjuntamente en estos gr√°ficos de reducci√≥n de dimensi√≥n. Como entrada para UMAP y tSNE, sugerimos usar las mismas PC como entrada para el an√°lisis de agrupamiento. # If you haven&#39;t installed UMAP, you can do so via reticulate::py_install(packages = &#39;umap-learn&#39;) pbmc &lt;- RunUMAP(pbmc, dims = 1:10) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 15:49:35 UMAP embedding parameters a = 0.9922 b = 1.112 ## 15:49:35 Read 2638 rows and found 10 numeric columns ## 15:49:35 Using Annoy for neighbor search, n_neighbors = 30 ## 15:49:35 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 15:49:35 Writing NN index file to temp file /tmp/RtmptOf5dE/file85718fe4172 ## 15:49:35 Searching Annoy index using 1 thread, search_k = 3000 ## 15:49:36 Annoy recall = 100% ## 15:49:36 Commencing smooth kNN distance calibration using 1 thread ## 15:49:37 Initializing from normalized Laplacian + noise ## 15:49:37 Commencing optimization for 500 epochs, with 105124 positive edges ## 15:49:40 Optimization finished # Note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(pbmc, reduction = &quot;umap&quot;) Puede guardar el objeto en este punto para que se pueda volver a cargar f√°cilmente sin tener que volver a ejecutar los pasos computacionalmente intensivos realizados anteriormente o compartir f√°cilmente con los colaboradores. if (interactive()) { saveRDS(pbmc, file = &quot;pbmc_tutorial.rds&quot;) } 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) Seurat puede ayudarlo a encontrar marcadores que definan cl√∫steres mediante expresi√≥n diferencial. De forma predeterminada, identifica marcadores positivos y negativos de un solo grupo (especificado en ident.1), en comparaci√≥n con todas las dem√°s c√©lulas. FindAllMarkers() automatiza este proceso para todos los cl√∫steres, pero tambi√©n se pueden comparar grupos de cl√∫steres entre s√≠ o contra todas las c√©lulas. El argumento min.pct requiere que se detecte una caracter√≠stica en un porcentaje m√≠nimo en cualquiera de los dos grupos de c√©lulas, y el argumento thresh.test requiere que una caracter√≠stica se exprese diferencialmente (en promedio) en alguna cantidad entre los dos grupos. Puede establecer ambos en 0, pero con un aumento dram√°tico en el tiempo, ya que esto probar√° una gran cantidad de caracter√≠sticas que probablemente no sean altamente discriminatorias. - ¬øDemasiado lento? Como otra opci√≥n para acelerar estos c√°lculos, se puede configurar el n√∫mero m√°ximo de c√©lulas por identificador. Esto reducir√° la resoluci√≥n de cada clase de identidad para que no tenga m√°s c√©lulas que las que se establezcan. Si bien generalmente habr√° una p√©rdida de potencia, los aumentos de velocidad pueden ser significativos y es probable que las caracter√≠sticas expresadas de manera m√°s diferencial a√∫n se eleven a la cima. # find all markers of cluster 2 cluster2.markers &lt;- FindMarkers(pbmc, ident.1 = 2, min.pct = 0.25) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.593535e-91 1.2154360 0.949 0.466 3.556774e-87 ## LTB 7.994465e-87 1.2828597 0.981 0.644 1.096361e-82 ## CD3D 3.922451e-70 0.9359210 0.922 0.433 5.379250e-66 ## IL7R 1.130870e-66 1.1776027 0.748 0.327 1.550876e-62 ## LDHB 4.082189e-65 0.8837324 0.953 0.614 5.598314e-61 # find all markers distinguishing cluster 5 from clusters 0 and 3 cluster5.markers &lt;- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 2.150929e-209 4.267579 0.975 0.039 2.949784e-205 ## IFITM3 6.103366e-199 3.877105 0.975 0.048 8.370156e-195 ## CFD 8.891428e-198 3.411039 0.938 0.037 1.219370e-193 ## CD68 2.374425e-194 3.014535 0.926 0.035 3.256286e-190 ## RP11-290F20.3 9.308287e-191 2.722684 0.840 0.016 1.276538e-186 # find markers for every cluster compared to all remaining cells, report only the positive # ones pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## # A tibble: 18 √ó 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1.74e-109 1.07 0.897 0.593 2.39e-105 0 LDHB ## 2 1.17e- 83 1.33 0.435 0.108 1.60e- 79 0 CCR7 ## 3 0 5.57 0.996 0.215 0 1 S100A9 ## 4 0 5.48 0.975 0.121 0 1 S100A8 ## 5 7.99e- 87 1.28 0.981 0.644 1.10e- 82 2 LTB ## 6 2.61e- 59 1.24 0.424 0.111 3.58e- 55 2 AQP3 ## 7 0 4.31 0.936 0.041 0 3 CD79A ## 8 9.48e-271 3.59 0.622 0.022 1.30e-266 3 TCL1A ## 9 1.17e-178 2.97 0.957 0.241 1.60e-174 4 CCL5 ## 10 4.93e-169 3.01 0.595 0.056 6.76e-165 4 GZMK ## 11 3.51e-184 3.31 0.975 0.134 4.82e-180 5 FCGR3A ## 12 2.03e-125 3.09 1 0.315 2.78e-121 5 LST1 ## 13 1.05e-265 4.89 0.986 0.071 1.44e-261 6 GZMB ## 14 6.82e-175 4.92 0.958 0.135 9.36e-171 6 GNLY ## 15 1.48e-220 3.87 0.812 0.011 2.03e-216 7 FCER1A ## 16 1.67e- 21 2.87 1 0.513 2.28e- 17 7 HLA-DPB1 ## 17 7.73e-200 7.24 1 0.01 1.06e-195 8 PF4 ## 18 3.68e-110 8.58 1 0.024 5.05e-106 8 PPBP Seurat tiene varias pruebas de expresi√≥n diferencial que se pueden configurar con el par√°metro test.use (consulte nuestra vi√±eta DE para obtener m√°s detalles). Por ejemplo, la prueba ROC devuelve el ‚Äúpoder de clasificaci√≥n‚Äù para cualquier marcador individual (que var√≠a de 0 - aleatorio a 1 - perfecto) . cluster0.markers &lt;- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) Se incluyen varias herramientas para visualizar la expresi√≥n de los marcadores. VlnPlot() (muestra distribuciones de probabilidad de expresi√≥n entre cl√∫steres) y FeaturePlot() (visualiza la expresi√≥n de caracter√≠sticas en un gr√°fico tSNE o PCA) son nuestras visualizaciones m√°s utilizadas. Tambi√©n sugerimos explorar RidgePlot(), CellScatter() y DotPlot() como m√©todos adicionales para ver su conjunto de datos. VlnPlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) ## you can plot raw counts as well VlnPlot(pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) FeaturePlot(pbmc, features = c( &quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot; )) # DoHeatmap() generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster. pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) -&gt; top10 DoHeatmap(pbmc, features = top10$gene) + NoLegend() 13.13 Assigning cell type identity to clusters Podemos usar marcadores can√≥nicos para hacer coincidir f√°cilmente la agrupaci√≥n imparcial con los tipos de c√©lulas conocidos. new.cluster.ids &lt;- c( &quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot; ) names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() 13.14 Guardar Resultados if (interactive()) { saveRDS(pbmc, file = &quot;pbmc3k_final.rds&quot;) } 13.15 Detalles de la sesi√≥n de R ## Informaci√≥n de la sesi√≥n de R Sys.time() ## [1] &quot;2021-08-19 15:50:19 UTC&quot; proc.time() ## user system elapsed ## 164.156 12.161 120.738 options(width = 120) sessioninfo::session_info() ## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-19 ## ## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.23 2021-08-13 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr * 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.8.1 2021-08-10 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.3 2021-08-10 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## survival 3.2-12 2021-08-13 [3] RSPM (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["pl√°tica-de-ricardo-ramirez.html", "Pl√°tica de Ricardo Ramirez", " Pl√°tica de Ricardo Ramirez Empieza la pl√°tica cient√≠fica de Ricardo O. Ramirez Flores @roramirezf94 üá≤üáΩ üôåüèΩhttps://t.co/iXo6Pnl4tlüëÄ https://t.co/1J4h0H2QKL#scRNAseq #rstats#rstatsES @Bioconductor #EBM2021 #CDSB2021 @saezlab pic.twitter.com/EBPKwtyhO4 ‚Äî ComunidadBioInfo (@CDSBMexico) August 13, 2021 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
