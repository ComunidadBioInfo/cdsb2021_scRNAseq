[["index.html", "Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Información del taller Formato del curso: en línea ¿Quién es nuestra audiencia? Formulario de registro Instructores Ponentes e instructores invitados Ayudantes Temario Código de Conducta Pre-requisitos Horario Música para ejercicios Materiales Zoom Organizadores Patrocinadores Información sesión de R Licencia", " Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Leonardo Collado-Torres Lieber Institute for Brain Development, Johns Hopkins Medical Campus Información del taller 9-13 de agosto de 2021 ¡Bienvenidxs al taller Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor! En los últimos años, la generación y análisis de transcriptomas de célula única ha cobrado gran importancia para resolver preguntas biológicas. En este taller revisaremos los métodos más recientes para analizar datos de single cell RNA-seq (transcriptómica en células únicas), usando paquetes de R especializados que están disponibles libremente vía Bioconductor. Este taller estará basado en el libro Orchestrating Single Cell Analysis with Bioconductor que fue publicado en Nature Methods y es de los artículos con mayor publicidad en 2020 y 2021. Durante este taller aprenderás las herramientas estadísticas para analizar datos de transcriptómica en células únicas usando Bioconductor. Revisaremos qué es un análisis de datos de célula única, cuáles son las principales diferencias entre el análisis de transcriptomas de célula única y en bulk, cómo documentar tu análisis y algunas herramientas para interpretar tus resultados. Formato del curso: en línea Este es un curso digital. Las sesiones y material del curso serán presentados en línea. Esta modalidad incluirá grabaciones de video o audio del material, intercambio de archivos y sesiones de discusión temáticos, ejercicios de auto-evaluación y acceso a los instructores para comentarios durante el curso. ¿Quién es nuestra audiencia? Este curso está dirigido a personas que desean aprender cómo analizar datos transcriptómicos de célula única usando paquetes de R/Bioconductor. Revisa los videos de CDSB2020 en YouTube o la página web de cdsb2020, que es similar al taller de este año. Formulario de registro http://congresos.nnb.unam.mx/EBM2021/ Do you want to learn how to analyze #scRNAseq with @Bioconductor?Learn with @lcolladotor@yalbi_ibm @AnaBetty2304 @argininaa @naielisha @lawrah20 @roramirezf94 @jvelezmagic @KevsGenomic @mpadilla905Material adapted from OSCA @PeteHaitch et al#rstatshttps://t.co/MIfFmKt3Fq pic.twitter.com/nSPCmVEPAC — ComunidadBioInfo (@CDSBMexico) July 2, 2021 Instructores Leonardo Collado-Torres Yalbi Balderas https://comunidadbioinfo.github.io/es/#people Ponentes e instructores invitados Ana Beatriz Villaseñor Altamirano Citlali Gil Aguillon Elisa Márquez Zavala Laura Lucila Gómez Romero Ricardo Ramirez Flores Ayudantes Jesús Vélez Santiago Kevin Emmanuel Meza Landeros Mónica Padilla Gálvez Temario Día 1 Introducción a R y RStudio Ejercicio usando usethis, here y postcards Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Día 2 Estructura e importe de datos Comunidades RLadies Control de calidad Día 3 Normalización de datos Foto y actividades de la comunidad Selección de genes Día 4 Reducción de dimensiones Clustering Identificación de genes marcadores Día 5 Anotación de clusters de células Análisis de expresión diferencial Plática científica del ponente invitadx Código de Conducta Seguiremos el código de conducta de la CDSB México comunidadbioinfo.github.io/es/codigo-de-conducta/ además del código de conducta de Bioconductor bioconductor.org/about/code-of-conduct/. Pre-requisitos De forma general, Computadora con al menos 8Gb de memoria y permisos de administrador para instalar paqueterías de R. Tener instalado R y RStudio en su última versión. Conocimientos básicos de secuenciación de transcriptomas. Conocimientos básicos de RStudio (Creación de Rscripts, manejo de la consola de RStudio, manejo del espacio de visualización). Conocimiento intermedio de R (Manejo de variables, lectura de archivos, creación y manejo de data frames y listas, generación de gráficas básicas, conocimiento sobre cómo instalar paqueterías desde CRAN y Bioconductor). Más específicamente, computadora con al menos 8 GB de memoria RAM, aplicación Zoom https://zoom.us/download, R versión 4.1 instalada de CRAN https://cran.r-project.org/ (ver video de https://youtu.be/6knyHlUe1cM sobre como instalar R en macOS o winOS), RStudio versión 1.4 https://www.rstudio.com/products/rstudio/download/#download, y los siguientes paquetes de R y Bioconductor: ## Para instalar paquetes if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } ## Para instalar paquetes de Bioconductor remotes::install_cran(&quot;BiocManager&quot;) BiocManager::version() # El anterior comando debe mostrar que estás usando la versión 3.13 ## Instala los paquetes de R que necesitamos ## BiocManager::install(c(&quot;batchelor&quot;, &quot;BiocFileCache&quot;, &quot;BiocSingular&quot;, &quot;bluster&quot;, &quot;celldex&quot;, &quot;clusterExperiment&quot;, &quot;cowplot&quot;, &quot;dplyr&quot;, &quot;DropletUtils&quot;, &quot;EnsDb.Hsapiens.v86&quot;, &quot;ExperimentHub&quot;, &quot;fossil&quot;, &quot;gert&quot;, &quot;gh&quot;, &quot;here&quot;, &quot;iSEE&quot;, &quot;kableExtra&quot;, &quot;org.Mm.eg.db&quot;, &quot;patchwork&quot;, &quot;PCAtools&quot;, &quot;pheatmap&quot;, &quot;plotly&quot;, &quot;postcards&quot;, &quot;pryr&quot;, &quot;RColorBrewer&quot;, &quot;rsthemes&quot;, &quot;Rtsne&quot;, &quot;scater&quot;, &quot;scPipe&quot;, &quot;scran&quot;, &quot;scRNAseq&quot;, &quot;sessioninfo&quot;, &quot;Seurat&quot;, &quot;SingleCellExperiment&quot;, &quot;SingleR&quot;, &quot;suncalc&quot;, &quot;TENxPBMCData&quot;, &quot;usethis&quot;, &quot;uwot&quot;)) Horario Consulta el calendario de este curso en: http://bit.ly/calendarcdsb2021. Horario Tema Instructores Día 1: Agosto 9, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-09:30 Inauguración EBM2021 Julio Collado Vides, Christian Sohlenkamp, Irma Martínez Flores, Shirley Alquicira Hernández 09:30-10:00 Bienvenida a la CDSB y revisión del código de conducta Leonardo Collado-Torres 10:00-11:00 Introducción a R y RStudio Leonardo Collado-Torres 11:00-11:30 Descanso 11:30-14:00 Ejercicio usando usethis, here y postcards Citlali Gil Aguillon y Elisa Márquez Zavala 14:00-15:30 Descanso: comida 15:30-17:00 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Citlali Gil Aguillon y Elisa Márquez Zavala 17:00-18:00 (Invitada) Principios FAIR para software de investigación Paula Andrea Día 2: Agosto 10, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Estructura e importe de datos Citlali Gil Aguillon y Elisa Márquez Zavala 11:00-11:30 Descanso 11:30-12:00 Keynote: La comunidad R-Ladies Ana Beatriz Villaseñor Altamirano 12:00-14:00 Control de calidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Control de calidad Leonardo Collado-Torres 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 3: Agosto 11, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Normalización de datos Ana Beatriz Villaseñor Altamirano 10:30-11:00 Foto 11:00-11:30 Descanso 11:30-12:30 Selección de genes Yalbi Balderas 12:30-14:00 Actividades para construir la comunidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Selección de genes Laura Lucila Gómez Romero 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 4: Agosto 12, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Reducción de dimensiones Laura Lucila Gómez Romero 11:00-11:30 Descanso 11:30-14:00 Clustering Laura Lucila Gómez Romero 14:00-15:30 Descanso: comida 15:30-17:30 Identificación de genes marcadores Yalbi Balderas 17:30-18:30 CDSB 2021: Evento social remoto Día 5: Agosto 13, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Anotación de clusters de células Yalbi Balderas 10:30-11:00 Evaluación del taller Irma Martínez Flores y Shirley Alquicira Hernández 11:00-11:30 Descanso 11:30-12:30 Análisis de expresión diferencial Leonardo Collado-Torres 12:30-14:00 Introducción a Seurat Kevin Emmanuel Meza Landeros 14:00-15:30 Descanso: comida 15:30-17:00 Plática científica y sesión de preguntas Ricardo Ramirez Flores 17:00-17:30 Clausura y recordatorio de la CDSB 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Música para ejercicios Aquí están las listas de canciones por si desean escuchar algo de música mientras realizan ejercicios iTunes Spotify Materiales Descarga los materiales con usethis::use_course('comunidadbioinfo/cdsb2021_scRNAseq') o revisalos en línea vía comunidadbioinfo.github.io/cdsb2021_scRNAseq. Zoom Las ligas de Zoom están disponibles exclusivamente para lxs participantes de CDSB2021 vía Slack. Te enviaremos una invitación al correo electrónico que usaste para registrate. Organizadores Comunidad de Desarrolladores de Software en Bioinformática CDSB Red Mexicana de Bioinformática RMB Nodo Nacional de Bioinformática en la UNAM NNB-CCG Patrocinadores Agradecemos a nuestros patrocinadores: Información sesión de R Detalles de la sesión de R usada para crear este libro. El código fuente está disponible vía ComunidadBioInfo/cdsb2021_scRNAseq. options(width = 120) pkgs &lt;- installed.packages()[, &quot;Package&quot;] sessioninfo::session_info(pkgs, include_base = TRUE) ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## ade4 1.7-17 2021-06-17 [1] RSPM (R 4.1.0) ## annotate 1.70.0 2021-05-19 [1] Bioconductor ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## AnVIL 1.4.1 2021-06-22 [2] Bioconductor ## ape 5.5 2021-04-25 [1] RSPM (R 4.1.0) ## askpass 1.1 2019-01-13 [2] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## backports 1.2.1 2020-12-09 [1] RSPM (R 4.1.0) ## base * 4.1.0 2021-07-29 [3] local ## base64enc 0.1-3 2015-07-28 [1] RSPM (R 4.1.0) ## batchelor 1.8.0 2021-05-19 [1] Bioconductor ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## benchmarkme 1.0.7 2021-03-21 [1] RSPM (R 4.1.0) ## benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.1.0) ## BH 1.75.0-0 2021-01-11 [1] RSPM (R 4.1.0) ## Biobase 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocStyle 2.20.2 2021-06-17 [1] Bioconductor ## biocthis 1.2.0 2021-05-19 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## boot 1.3-28 2021-05-03 [3] CRAN (R 4.1.0) ## brew 1.0-6 2011-04-13 [2] RSPM (R 4.1.0) ## brio 1.1.2 2021-04-23 [2] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## callr 3.7.0 2021-04-20 [2] RSPM (R 4.1.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.1.0) ## celldex 1.2.0 2021-05-20 [1] Bioconductor ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## class 7.3-19 2021-05-03 [3] CRAN (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clipr 0.7.1 2020-10-08 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## clusterExperiment 2.12.0 2021-05-19 [1] Bioconductor ## ClusterR 1.2.5 2021-05-21 [1] RSPM (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## commonmark 1.7 2018-12-01 [2] RSPM (R 4.1.0) ## compiler 4.1.0 2021-07-29 [3] local ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## cpp11 0.3.1 2021-06-25 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## credentials 1.3.1 2021-07-25 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## datasets * 4.1.0 2021-07-29 [3] local ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## desc 1.3.0 2021-03-05 [2] RSPM (R 4.1.0) ## devtools 2.4.2 2021-06-07 [2] RSPM (R 4.1.0) ## diffobj 0.3.4 2021-03-22 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## docopt 0.7.1 2020-06-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## forcats 0.5.1 2021-01-27 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## foreign 0.8-81 2020-12-22 [3] CRAN (R 4.1.0) ## formatR 1.11 2021-06-01 [1] RSPM (R 4.1.0) ## fossil 0.4.0 2020-03-23 [1] RSPM (R 4.1.0) ## fs 1.5.0 2020-07-31 [2] RSPM (R 4.1.0) ## futile.logger 1.4.3 2016-07-10 [1] RSPM (R 4.1.0) ## futile.options 1.0.1 2018-04-20 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.7.0 2021-01-04 [1] RSPM (R 4.1.0) ## genefilter 1.74.0 2021-05-19 [1] Bioconductor ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges 1.44.0 2021-05-19 [1] Bioconductor ## gert 1.3.1 2021-06-23 [2] RSPM (R 4.1.0) ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## gh 1.3.0 2021-04-30 [2] RSPM (R 4.1.0) ## gitcreds 0.1.1 2020-12-04 [2] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gmp 0.6-2 2021-01-07 [1] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gplots 3.1.1 2020-11-28 [1] RSPM (R 4.1.0) ## graphics * 4.1.0 2021-07-29 [3] local ## grDevices * 4.1.0 2021-07-29 [3] local ## grid 4.1.0 2021-07-29 [3] local ## gridBase 0.4-7 2014-02-24 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## gtools 3.9.2 2021-06-06 [1] RSPM (R 4.1.0) ## hash 2.2.6.1 2019-03-04 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## howmany 0.3-1 2012-06-01 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## ini 0.3.1 2018-05-20 [2] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE 2.4.0 2021-05-19 [1] Bioconductor ## isoband 0.2.5 2021-07-13 [1] RSPM (R 4.1.0) ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## kernlab 0.9-29 2019-11-12 [1] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lambda.r 1.2.4 2019-09-18 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## littler 0.3.13 2021-07-24 [2] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfdr 1.1-8 2015-07-15 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## lubridate 1.7.10 2021-02-26 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## maps 3.3.0 2018-04-03 [1] RSPM (R 4.1.0) ## markdown 1.1 2019-08-07 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mbkmeans 1.8.0 2021-05-19 [1] Bioconductor ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## methods * 4.1.0 2021-07-29 [3] local ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## NMF 0.23.0 2020-08-01 [1] RSPM (R 4.1.0) ## nnet 7.3-16 2021-05-03 [3] CRAN (R 4.1.0) ## openssl 1.4.4 2021-04-30 [2] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## parallel 4.1.0 2021-07-29 [3] local ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## PCAtools 2.4.0 2021-05-19 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## phylobase 0.8.10 2020-03-01 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pixmap 0.4-12 2021-01-29 [1] RSPM (R 4.1.0) ## pkgbuild 1.2.0 2020-12-15 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## pkgload 1.2.1 2021-04-06 [2] RSPM (R 4.1.0) ## pkgmaker 0.32.2 2020-10-20 [1] RSPM (R 4.1.0) ## plogr 0.2.0 2018-03-25 [1] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## postcards 0.2.2 2021-07-31 [1] RSPM (R 4.1.0) ## pracma 2.3.3 2021-01-23 [1] RSPM (R 4.1.0) ## praise 1.0.0 2015-08-11 [2] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## processx 3.5.2 2021-04-30 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## pryr 0.1.5 2021-07-26 [1] RSPM (R 4.1.0) ## ps 1.6.0 2021-02-28 [2] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.cache 0.15.0 2021-04-30 [1] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rapiclient 0.1.3 2020-01-17 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## rcmdcheck 1.3.3 2019-05-07 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RcppArmadillo 0.10.6.0.0 2021-07-16 [1] RSPM (R 4.1.0) ## RcppEigen 0.3.3.9.1 2020-12-17 [1] RSPM (R 4.1.0) ## RcppHNSW 0.3.0 2020-09-06 [1] RSPM (R 4.1.0) ## RcppProgress 0.4.2 2020-02-06 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## registry 0.5-1 2019-03-05 [1] RSPM (R 4.1.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.1.0) ## remotes 2.4.0 2021-06-02 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## rncl 0.8.4 2020-02-10 [1] RSPM (R 4.1.0) ## RNeXML 2.4.5 2020-06-18 [1] RSPM (R 4.1.0) ## rngtools 1.5 2020-01-23 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## roxygen2 7.1.1 2020-06-27 [2] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rversions 2.1.1 2021-05-31 [2] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scPipe 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle 1.2.1 2021-08-05 [1] Bioconductor ## selectr 0.4-2 2019-11-20 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shapefiles 0.7 2013-01-26 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment 1.14.1 2021-05-21 [1] Bioconductor ## SingleR 1.6.1 2021-05-20 [1] Bioconductor ## sitmo 2.0.1 2019-01-07 [1] RSPM (R 4.1.0) ## snow 0.4-3 2018-09-14 [1] RSPM (R 4.1.0) ## softImpute 1.4-1 2021-05-09 [1] RSPM (R 4.1.0) ## sourcetools 0.1.7 2018-04-25 [1] RSPM (R 4.1.0) ## sp 1.4-5 2021-01-10 [1] RSPM (R 4.1.0) ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatial 7.3-14 2021-05-03 [3] CRAN (R 4.1.0) ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## splines 4.1.0 2021-07-29 [3] local ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stats * 4.1.0 2021-07-29 [3] local ## stats4 4.1.0 2021-07-29 [3] local ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## styler 1.5.1 2021-07-13 [1] RSPM (R 4.1.0) ## SummarizedExperiment 1.22.0 2021-05-19 [1] Bioconductor ## suncalc 0.5.0 2019-04-03 [1] RSPM (R 4.1.0) ## survival 3.2-11 2021-04-26 [3] CRAN (R 4.1.0) ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## sys 3.4 2020-07-23 [2] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tcltk 4.1.0 2021-07-29 [3] local ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## TENxPBMCData 1.10.0 2021-05-20 [1] Bioconductor ## testthat 3.0.4 2021-07-01 [2] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## tinytex 0.33 2021-08-05 [1] RSPM (R 4.1.0) ## tools 4.1.0 2021-07-29 [3] local ## usethis 2.0.1 2021-02-10 [2] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## utils * 4.1.0 2021-07-29 [3] local ## uuid 0.1-4 2020-02-26 [1] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## waldo 0.2.5 2021-03-08 [2] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## whisker 0.4 2019-08-28 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xopen 1.0.0 2018-09-17 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zinbwave 1.14.1 2021-05-25 [1] Bioconductor ## zip 2.2.0 2021-05-31 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Fecha de la última actualización de esta página: 2021-08-09 22:09:55. Licencia This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["inauguración-cdsb2021.html", "Inauguración CDSB2021", " Inauguración CDSB2021 "],["introducción-a-r-y-rstudio.html", "1 Introducción a R y RStudio 1.1 R 1.2 GitHub 1.3 RStudio 1.4 Material del curso 1.5 Detalles de la sesión de R Patrocinadores", " 1 Introducción a R y RStudio Instructor: Leonardo Collado Torres 1.1 R R: es gratis, de acceso libre, utilizado para muchos campos de trabajo, fuerte en la bioinformática a través de Bioconductor Instalación a través de CRAN: https://cran.r-project.org/ Para explorar que se puede hacer con R: R Weekly https://rweekly.org/ R Bloggers https://www.r-bloggers.com/ Twitter https://twitter.com/search?q=%23rstats&amp;src=typed_query Twitter en español https://twitter.com/search?q=%23rstatsES&amp;src=typed_query TidyTuesday https://twitter.com/search?q=%23TidyTuesday&amp;src=typed_query DatosDeMiercoles https://twitter.com/search?q=%23datosdemiercoles&amp;src=typed_query Para pedir ayuda hay muchas opciones https://lcolladotor.github.io/bioc_team_ds/how-to-ask-for-help.html Material en el que estoy involucrado: https://twitter.com/lcolladotor https://www.youtube.com/c/LeonardoColladoTorres/playlists LIBD rstats club https://docs.google.com/spreadsheets/d/1is8dZSd0FZ9Qi1Zvq1uRhm-P1McnJRd_zxdAfCRoMfA/edit?usp=sharing https://twitter.com/CDSBMexico, https://twitter.com/LIBDrstats, https://twitter.com/Bioconductor https://comunidadbioinfo.github.io/ YouTube CDSB: https://www.youtube.com/channel/UCHCdYfAXVzJIUkMoMSGiZMw Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor https://lmweber.org/OSTA-book/ Thank you @Bioconductor for welcoming me &amp; providing me a foundation &amp; platform for my careerGracias BioC por darme una oportunidad y plataforma para desarrollar mi carreraTime to pass it on/Toca enseñar y crecer la bola de nieve ❄️ @CDSBMexico 🇲🇽#BioC2021 #rstats #rstatsES https://t.co/8cDXP4Pf2W pic.twitter.com/rpQgH8UsWW — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 5, 2021 1.2 GitHub Permite compartir código Se complementa con Git que es para tener un control de versiones de tu código https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Introduccion-al-flujo-de-trabajo-orientado-a-proyectos.pdf Puedes tener páginas web estáticas https://pages.github.com/ https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/. En especial https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq/tree/gh-pages se convierte en https://comunidadbioinfo.github.io/cdsb2021_scRNAseq/ Página personal: https://github.com/lcolladotor/lcolladotor.github.com se convierte en http://lcolladotor.github.io/. Está todo hecho con https://github.com/lcolladotor/lcolladotorsource Tip: usen el mismo nombre de usuario en GitHub, Twitter, Gmail, etc. How to be a Modern Scientist: https://lcolladotor.github.io/bioc_team_ds/how-to-be-a-modern-scientist.html 1.3 RStudio RStudio Desktop es gratis http://www.rstudio.com/products/rstudio/download/preview/ Nos ayuda a realizar muchas cosas con R de forma más rápida Demo rsthemes remotes::install_github(c( &quot;gadenbuie/rsthemes&quot; )) remotes::install_cran(&quot;suncalc&quot;) rsthemes::install_rsthemes(include_base16 = TRUE) usethis::edit_r_profile() ## From https://www.garrickadenbuie.com/project/rsthemes/ if (interactive() &amp;&amp; requireNamespace(&quot;rsthemes&quot;, quietly = TRUE)) { # Set preferred themes if not handled elsewhere.. rsthemes::set_theme_light(&quot;Solarized Light {rsthemes}&quot;) # light theme rsthemes::set_theme_dark(&quot;base16 Monokai {rsthemes}&quot;) # dark theme rsthemes::set_theme_favorite(c( &quot;Solarized Light {rsthemes}&quot;, &quot;base16 Monokai {rsthemes}&quot;, &quot;One Dark {rsthemes}&quot; )) # Whenever the R session restarts inside RStudio... setHook(&quot;rstudio.sessionInit&quot;, function(isNewSession) { # Automatically choose the correct theme based on time of day ## Used rsthemes::geolocate() once rsthemes::use_theme_auto(lat = 39.2891, lon = -76.5583) }, action = &quot;append&quot;) } ## https://blog.rstudio.com/2013/06/10/rstudio-cran-mirror/ options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) Es actualizado con bastante frecuencia RStudio cheatsheets https://www.rstudio.com/resources/cheatsheets/ https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf RStudio projects: usalos para organizar tu código https://github.com/ComunidadBioInfo/cdsb2020/blob/master/presentaciones_flujos-de-trabajo/Trabajando-con-proyectos.pdf usethis::create_project(&quot;~/Desktop/cdsb2021_scRNAseq_notas&quot;) ## Inicien un archivo para sus notas usethis::use_r(&quot;01-notas.R&quot;) O por ejemplo el archivo 01-visualizar-mtcars.R ## Creemos el archivo R/01-visualizar-mtcars.R usethis::use_r(&quot;01-visualizar-mtcars.R&quot;) con el siguiente contenido: ## Cargar paquetes que usaremos en este código library(&quot;sessioninfo&quot;) library(&quot;here&quot;) library(&quot;ggplot2&quot;) ## Hello world print(&quot;Soy Leo&quot;) ## Crear directorio para las figuras dir.create(here::here(&quot;figuras&quot;), showWarnings = FALSE) ## Hacer una imagen de ejemplo pdf(here::here(&quot;figuras&quot;, &quot;mtcars_gear_vs_mpg.pdf&quot;), useDingbats = FALSE ) ggplot(mtcars, aes(group = gear, y = mpg)) + geom_boxplot() dev.off() ## Para reproducir mi código options(width = 120) sessioninfo::session_info() Configura usethis con GitHub vía https://usethis.r-lib.org/articles/articles/git-credentials.html ## Para poder conectar tu compu con GitHub usethis::create_github_token() ## Abrirá una página web, escoje un nombre único ## y luego da click en el botón verde al final. Después copia el token ## (son 40 caracteres) gitcreds::gitcreds_set() ## Ojo, copia el token, no tu password de git! ## Si no, terminaras en la situación descrita en ## https://github.com/r-lib/usethis/issues/1347 ## Configura tu usuario de GitHub usethis::edit_git_config() # [user] # name = Leonardo Collado Torres # email = lcolladotor@gmail.com ## Para inicializar el repositorio de Git usethis::use_git() ## Para conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Resultado ejemplo: https://github.com/lcolladotor/cdsb2021_scRNAseq_notas. El que hice en vivo está disponible vía https://github.com/lcolladotor/cdsb2021_scRNAseq_notas_en_vivo (o https://github.com/lcolladotor/rnaseq_2021_notas_en_vivo para un ejemplo de febrero 2021). Una vez que termines, agrega la liga al repositorio con tus notas del curso en el Google Sheet del curso. (De ser necesario, pide permisos para editar el archivo.) 1.4 Material del curso Pueden descargar la versión estática con usethis::use_course('ComunidadBioInfo/cdsb2021_scRNAseq') Pueden verlo en línea a través de ComunidadBioInfo.github.io/cdsb2021_scRNAseq Pueden clonarlo desde GitHub de tal forma que podrán actualizarlo fácilmente usando git pull git clone https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq.git ## Si tienen su SSH key configurarda pueden usar ## Info sobre SSH keys de GitHub: ## https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent git clone git@github.com:ComunidadBioInfo/cdsb2021_scRNAseq.git O desde R con: ## Opción más nueva: library(&quot;gert&quot;) repo &lt;- git_clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) setwd(repo) ## Otra opción: git2r::clone( &quot;https://github.com/ComunidadBioInfo/cdsb2021_scRNAseq&quot;, &quot;~/Desktop/cdsb2021_scRNAseq&quot; ) 1.5 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:09:55 UTC&quot; proc.time() ## user system elapsed ## 0.476 0.151 0.497 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["ejercicio-usando-usethis-here-y-postcards.html", "2 Ejercicio usando usethis, here y postcards 2.1 here 2.2 usethis 2.3 Vinculando RStudio con Git y GitHub 2.4 Ejercicio postcards 2.5 Detalles de la sesión de R Patrocinadores", " 2 Ejercicio usando usethis, here y postcards Instructoras: Elisa Márquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres 2.1 here Este paquete es bastante útil El directorio que toma como base será en el que nos encontremos al momento de cargar el paquete here, heuristicamente busca la raíz del proyecto y se posiciona en él. # se descargó previamente, así que solo se carga library(&quot;here&quot;) # busca la raiz del proyecto en el que se encuentre En ciertas ocasiones puede haber algun error, ya que puede chocar con otros paquetes (como plyr). para evitar esto podemos usar here::here (que básicamente aclara que la función solicitada es del paquete here) here::here() Podemos checar en qué directorio nos encontramos con getwd(), si no es el que deseamos podemos cambiarlo con setwd() getwd() # regresa la path en donde nos encontramos setwd(&quot;direccion/deseada&quot;) # nos lleva a la path indicada Pero con here podemos no especificar la path getwd() # para checar en donde nos encontramos here::here() # para checar dónde te encuentras # nos movemos al subdirectorio R setwd(here::here(&quot;R&quot;)) # podemos cambiar de directorio, aun así `here está en la raíz A continuación ofrecemos algunos ejemplos de cómo podría emplearse here::here # como ejemplo: vamos a guardar datos en archivo y cargarlos a &lt;- 1 c &lt;- 23 save(a, c, file = here::here(&quot;datos-prueba.RData&quot;)) # rm(a,c) load(here::here(&quot;datos-prueba.RData&quot;)) # creamos un directorio dir.create(here::here(&quot;subdirectorio&quot;), showWarnings = FALSE) # podemos crear un archivo, indicando el subdirectorio, (en este caso el primer argumento) file.create(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # abrimos el nuevo archivo creado file.show(here::here(&quot;subdirectorio&quot;, &quot;nombrearchivo&quot;)) # podemos editarlo!! # por ejemplo si quisieramos ver nuestros archivos del directorio list.files(here::here(), recursive = TRUE) 2.2 usethis manual de usuario usethis puede ser más amigable, por ejemplo para la creación de nuevos archivos .R es capaz de agruparlos en la carpeta R (dando un orden al proyecto) usethis::use_r(&quot;notas-prueba.R&quot;) # no importando en qué path estemos En el siguiente ejercicio veremos algunos usos de usethis 2.3 Vinculando RStudio con Git y GitHub Ahora vamos a vincular nuestro proyecto de Rstudio con Github, esto es muy util para tener un control de nuestros archivos, poder compartirlos o usar el de otrxs 2.3.1 Prerrequisitos Debemos tener una cuenta de Github. Si no tienes este es el momento para crear una cuenta! https://docs.github.com/es/github/getting-started-with-github/signing-up-for-github/signing-up-for-a-new-github-account También debemos instalar git en nuestras computadoras ya que el paquete gitcreds lo requiere https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Despues de instalar git debemor reiniciar nuestro RStudio para que pueda anexarse Y la instalación de los siguientes paquetes: # paquetes que vamos a requerir install.packages(c(&quot;gitcreds&quot;, &quot;gert&quot;, &quot;gh&quot;)) # cargarlos de manera separada library(&quot;gitcreds&quot;) library(&quot;gert&quot;) library(&quot;gh&quot;) 2.3.2 Creando token de acceso personal (PAT) Para conectar nuestro repositorio de Rstudio con Github solicitamos un token, esto para que github otorgue permiso a nuestra computadora Emplearemos el siguiente bloque de código para solicitar dicho token (elige un nombre significativo) Otra manera de solicitar el token es ingresando a https://github.com/settings/tokens, esta opción no dará una recomendación de los parámetros a seleccionar El parámetro de expiración del token puede cambiarse para que no expire (por seguridad no lo recomienda Github), de otra manera considera su tiempo de vigencia Una vez generado el token debes guardarlo, pues no volverá a aparecer. Siempre puedes volver a generar uno nuevo (no olvides borrar el token anterior) # Para iniciar conexión con GitHub usethis::create_github_token() # redirige a github donde eligiras nombre especifico del token # copia el token para después ingresarlo con gitcreds_set() gitcreds::gitcreds_set() # aquí colocas el token (NO tu contraseña de github!!!) NOTA: en el comando gitcreds::gitcreds_set() NO debemos poner nuestro token entre parentesis, sino que al ejecutar el comando la misma función nos pedirá ingresar el token El siguiente paso será configurar nuestro usuario de github en el archivo .gitconfig # Configurar usuario de gitHub usethis::edit_git_config() # que abre el archivo .gitconfig # colocaremos nombre y correo de cuenta de github. SOLO borrar los # y respetar los demas espacios # [user] # name = N O M B R E # email = correodeGithub 2.3.3 Inicializar repositorio de Git y Github Ahora vamos a inicializar el repositorio en Git (de manera local en tu computadora) y enseguida solicitamos que se conecte con los servidores de Github # inicializar el repositorio de Git usethis::use_git() # # conectar tu repositorio local de Git con los servidores de GitHub usethis::use_github() Git es el software mientras que GitHub es la plataforma web (basada en Git) que permite la colaboración LISTO!! Comando útil para checar configuración gh::gh_whoami() # para checar cómo quedó la configuración 2.3.4 Probar otros comandos de gert Una vez que ya vinculamos nuestro repositorio con github podemos seguir actualizandolo. Vamos a checar brevemente algunos de los comandos que son útiles para ello: Checaremos git_add, git_commit, git_log y git_push # escribimos un nuevo archivo, volvemos a usar here::here para especificar path writeLines(&quot;hola&quot;, here::here(&quot;R&quot;, &quot;prueba-here.R&quot;)) # otra manera es usar use_r usethis::use_r(&quot;archivo-prueba-github.R&quot;) # añade archivo al directorio R del proyecto actual # Por ejemplo podríamos probar añadir algo nuevo gert::git_add(&quot;R/archivo-prueba-github.R&quot;) # añadimos commit de lo que se hizo gert::git_commit(&quot;se subio archivo prueba&quot;) # nos da info de los commits gert::git_log() # sube tus cambios del repo local a los de github gert::git_push() # COMANDO IMPORTANTE Puede ser más amigable usar el recuadro de Git que aparece en RStudio para hacer todo lo anterior! Recuerden subir sus repositorios al Google Sheet 2.4 Ejercicio postcards Similar a https://pages.github.com/ postcards tiene 4 templados de páginas web https://github.com/seankross/postcards Tu página web debe describir decir algo sobre ti, tus intereses, y tus proyectos además de cómo contactarte Ejemplo https://amy-peterson.github.io/ vía https://github.com/amy-peterson/amy-peterson.github.com http://jtleek.com/ vía https://github.com/jtleek/jtleek.github.io http://aejaffe.com/ vía https://github.com/andrewejaffe/andrewejaffe.github.io 2.4.1 Crear el repositorio Podemos crearlo desde RStudio o desde github.com (opción 1) Desde RStudio ¡Cuidado!: Antes de crear un proyecto, revisen dónde están parados (getwd()) en su directorio y dónde quieren que se cree ## Creen el RStudio project. Es MUY importante que el usuario debe sea igual que en github usethis::create_project(&quot;Su_Usuario.github.io&quot;) Nuevo proyecto : git user ## Configura Git y GitHub # Con use_git() preguntará si desean hacer un commit, y después pedirá reiniciar Rstudio para que obtengan un nuevo botón llamado &quot;git()&quot; usethis::use_git() Nuevo botón button_git usethis::use_github() Creen su templado usando postcards. Va a crear un archivo index.Rmd ## Solo uno de estos, de acuerdo al templado que más les gustó postcards::create_postcard(template = &quot;jolla&quot;) postcards::create_postcard(template = &quot;jolla-blue&quot;) postcards::create_postcard(template = &quot;trestles&quot;) postcards::create_postcard(template = &quot;onofre&quot;) (opción 2) Desde github Creen un nuevo repositorio, público y sin archivo README en https://github.com/new llamado “usuario.github.io” con su nombre exacto en github ¡Cuidado! El repositorio debe ser público y sin README Creen un nuevo proyecto en RStudio: File &gt; New_project &gt; New directory &gt; Postcards Website Elijan el templado que más les gustó Ya con el proyecto creado, hay que configurar git y github ## Configura Git y GitHub # Con use_git() preguntará si desean hacer un commit, y después pedirá reiniciar Rstudio para que obtengan un nuevo botón llamado &quot;git()&quot; usethis::use_git() Nuevo botón: button_git Ahora que tienen el botón Git, hagan click y en la esquina derecha habrá un símbolo con dos rectángulos morados y un rombo blanco, denle click. button_branch Ahora el botón Add Remote y ahí podrán nombrar este acceso remoto como gusten, y agregar la URL de su repositorio en github. Da click en Add y después asignen el nombre de rama master Ahora pueden crear la rama, y sobreescribir el acceso cuando se los pregunte. 2.4.2 Modificar y subir a github nuestro postcard Ya que hayan creado con cualquiera de las 2 opciones anteriores pueden continuar: Llenen su información usando el formato Markdown. Por ejemplo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L17-L31. Agreguen sus perfiles estilo https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L7-L12 Den click en el botón azul de knit en RStudio. Es equivalente a rmarkdown::render(\"index.Rmd\"). Esto creará el archivo index.html. Hagan un commit para guardar los archivos nuevos incluyendo index.html y luego un push para subir los archivos a GitHub con alguna de las siguientes dos maneras: (opción 1) Botón de Git * Para guardar los archivos nuevos, incluyendo index.html, debemos hacer un commit. Podemos hacerlo con el nuevo botón de git, primero seleccionando los archivos: add_file Cuando hayamos seleccionado todos los archivos, veremos que la columna Status cambia a una “A” de agregado o added y podemos darle al botón Commit justo arriba de Status. Esto abrirá una nueva pestaña donde podremos poner un mensaje sobre nuestro commit y después darle al botón Commit. button_git Una vez terminado, en esa misma pantalla podemos darle un push para subir los archivos a GitHub con el botón de Push con una flecha verde arriba de Commit message. (opcion 2) Línea de comandos Otra manera de hacer es vía línea de comandos, primero pueden agregar los archivos con gert::git_add() o hacer directamente un commit de todos los archivos y luego un pull: ## Guardamos los archivos nuevos con el commit gert::git_commit_all(&quot;mensaje sobre el commit&quot;) ## Subimos los archivos a github gert::git_push (extra) . Pueden copiar y pegar emojis en sus páginas o utilizar fontawesome para agregar diferentes símbolos (como github o twitter): En código YAML # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en código YAML y_fawesome Se ve así: fawesome En el texto # Utlilizando `r fontawesome::fa(&quot;font-awesome-logo-full&quot;, fill = &quot;forestgreen&quot;)` en el texto tfawesome (opcional). Anuncien su nueva página web en Twitter usando el hashtag #rstats y/o etiquen al autor de postcards https://twitter.com/seankross. Pueden después incluir su página web en su introducción en el canal #bienvenida del Slack de la CDSB ^^. Recuerden subir sus repositorios al Google Sheet 2.5 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:09:56 UTC&quot; proc.time() ## user system elapsed ## 0.664 0.108 0.643 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducción-a-rna-seq-de-célula-única-scrna-seq-con-bioconductor-y-al-libro-de-osca.html", "3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA 3.1 Bioconductor 3.2 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA 3.3 Detalles de la sesión de R Patrocinadores", " 3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Instructoras: Elisa Márquez Zavala, Citlali Gil Aguillon Contenido adaptado del Curso de RNASeq de Leonardo Collado Torres y de Original Notes in English 3.1 Bioconductor CRAN, the R package repository: https://cran.r-project.org/ CRAN task views: https://cran.r-project.org/web/views/ “Bioconductor proporciona herramientas para el análisis y la comprensión de datos genómicos de alto rendimiento. Bioconductor utiliza el lenguaje de programación estadístico R y es de código abierto y desarrollo abierto. Tiene dos lanzamientos cada año y una comunidad de usuarios activa. Bioconductor también está disponible como AMI (Imagen de máquina de Amazon) e imágenes de Docker.” https://www.bioconductor.org/ Where do I start using Bioconductor? http://lcolladotor.github.io/2014/10/16/startbioc/#.XqxNGRNKiuo Básicamente es un repositorio con reglas o estándares para el análisis y la comprensión de datos genómicos de alto rendimiento. Para conocer sobre Bioconductor podemos ir a: https://www.bioconductor.org/ y dar click en About 3.1.1 Equipos y consejos Es conformado por diversos equipos y consejos (Asesores científicos, técnicos y de la comunidad). Por ejemplo Leonardo Collado. Científicos : Proporciona orientación externa y supervisión de la dirección científica del proyecto y está compuesto por líderes en el análisis estadístico de datos genómicos. Técnicos: Desarrollar estrategias para asegurar que la parte técnica de la infraestructura sea apropiada a largo plazo (manejo de paquetes, sitio web, slack, etc) Comunidad : Empoderar a las comunidades de usuarios y desarrolladores mediante la coordinación de actividades de capacitación y divulgación. Dentro del equipo core que mantiene a Bioconductor y apoya con las dudas (https://www.bioconductor.org/about/core-team/) hay gente a la que Bioconductor le paga por mantener los repositorios, lo cual lo hace diferente de CRAN. El tener gente que oficialmente sabe cómo ayudarte y tiene el tiempo para hacerlo crea una mejor experiencia para los usuarios y los desarrolladores. 3.1.2 Encontrando paquetes de Bioconductor Tipos de paquetes Hay 4 tipos de paquetes que aceptan Software: tipo principal de paquete BioC, en su mayoría aportado por el usuario. Es un paquete con un tipo de análisis específico. Algunos los hacen gente pagada directamente por Bioconductor Annotation: facilita la interacción con bases de datos genómicas muy utilizadas Experiment: contienen datos para algún artículo o datos que se usan en ejemplos más exhaustivos, en su mayoría aportados por el usuario. ~&lt;5 Mb Workflows: demuestran como puedes usar varios paquetes de Bioconductor para ciertos tipos de análisis Para descubrir paquetes: Software: http://bioconductor.org/packages/release/bioc/ Annotation: http://bioconductor.org/packages/release/data/annotation/ Experiment Data: http://bioconductor.org/packages/release/data/experiment/ Workflows: http://bioconductor.org/packages/release/workflows/ Las listas de cada tipo de paquete se ven algo así: Package Maintainer Title Nombre del paquete Quién lo mantiene Título completo recount3 Leonardo Collado-Torres Explore and download data from the recount3 project Paquetes de R de Leo: https://lcolladotor.github.io/pkgs/ Sin embargo, estas listas no son muy amigables si queremos explorar por lo que podemos usar biocViews Encontrando paquetes a través de biocViews: http://bioconductor.org/packages/release/BiocViews.html#___Software Estructura tipo árbol Son 4 árboles principales: software, annotation, experiment, workflow Dentro de cada árbol, un paquete puede ser parte de varias ramas, por ejemplo, recount3 está dentro de todas estas ramas: Software AssayDomain GeneExpression BiologicalQuestion DifferentialExpression Coverage Infrastructure DataImport Technology Sequencing RNASeq Tiene una búsqueda de texto simple Ejemplo: Software → WorkflowStep → Visualization → http://bioconductor.org/packages/release/BiocViews.html#___Visualization (486 paquetes en BioC 3.11 abril-octubre 2020, 506 en BioC 3.12 octubre 2020-abril 2021, 529 en BioC 3.13 agosto 2021) 3.1.3 Estructura de un paquete de BioC Usa https://bioconductor.org/packages/&lt;pkg_name&gt; Ejemplo: https://bioconductor.org/packages/recount Otro ejemplo: https://bioconductor.org/packages/SummarizedExperiment Badges (etiquetas): rápidamente podemos evaluar como está : ¿En qué plataformas funciona? : ¿Qué tan descargado es? : ¿Se han hecho preguntas del paquete en los últimos 6 meses? (respondidas/hechas) : ¿Cuánto tiempo lleva en Bioconductor? : ¿Funciona en las máquinas de bioconductor? : ¿Cuándo fue la última vez que lo actualizaron? : Número de dependencias recursivas necesarias para instalar el paquete Parráfo de descripción del paquete Cómo citar al paquete de Bioconductor Cómo instalarlo. Más detalles en http://bioconductor.org/install/ Documentación Una líga por cada vignette en formato PDF o HTML. Es la documentación principal! Una vignette es donde lxs autores del paquete explican cómo usar las diferentes funciones del paquete y en qué orden Detalles Términos de biocViews Cómo se relaciona a otros paquetes (depends, imports, linking to, suggests, depends on me, …) URL: donde puedes encontrar el código fuente (nos puede dar más infor) BugReports: donde puedes pedir ayuda Más detalles sobre el paquete Estadísticas de descargas 3.1.4 Las dos ramas de Bioconductor: release y devel Dos ramas release, actualmente 3.13 devel, actualmente 3.14 Bioconductor version 3.14 (Development) https://bioconductor.org/packages/devel/BiocViews.html#___Software Ejemplo: http://bioconductor.org/packages/devel/bioc/html/recount.html Bioconductor tiene es actualizado cada 6 meses (abril y octubre). R lo actualizan 1 vez al año (abril). Todo el software lo prueban en macOS, Windows y linux Ejemplo: http://bioconductor.org/checkResults/release/bioc-LATEST/recount/ y http://bioconductor.org/checkResults/devel/bioc-LATEST/recount/ Resumen BioC 3.13 http://bioconductor.org/news/bioc_3_13_release/ Blog post en LIBD rstats club: Quick overview on the new Bioconductor 3.8 release http://research.libd.org/rstatsclub/2018/11/02/quick-overview-on-the-new-bioconductor-3-8-release/ 3.1.5 Cursos y eventos http://bioconductor.org/help/events/ http://bioconductor.org/help/course-materials/ BioC2021: conferencia principal anual https://bioc2021.bioconductor.org/ Talleres del BioC2019: https://rebrand.ly/biocworkshops2019 Teach online data science, bioinformatics, or other computational skills interactively using the Orchestra platform:https://t.co/r4aJ2xAZbh Nearly 50 workshop environments preloaded with #jupyter, #rstudio, #shell. #rstats, or #python.@NIHSTRIDES @NIHDataScience @Bioconductor pic.twitter.com/HyWVLBJxGU — Sean Davis (@seandavis12) January 10, 2021 Talleres de la CDSB, como los talleres de CDSB 2020: https://comunidadbioinfo.github.io/post/cdsb2020-building-workflows-with-rstudio-and-scrnaseq-with-bioconductor/#.XmJT-Z-YU1I 3.1.6 Comunidad Slack: https://bioc-community.herokuapp.com/ Sitio web de ayuda: https://support.bioconductor.org/ Usa la(s) etiqueta(s) adecuada(s) para que lxs autores de los paquetes reciban email de forma automática Pueden revisar ese sitio web y usarlo para aprender cómo en https://lcolladotor.github.io/bioc_team_ds/helping-others.html#bioconductor-support-practice-grounds Twitter: https://twitter.com/bioconductor 3.2 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA link a diapositivas 3.3 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:09:57 UTC&quot; proc.time() ## user system elapsed ## 0.445 0.118 0.436 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["estructura-e-importe-de-datos.html", "4 Estructura e importe de datos 4.1 Detalles de la sesión de R Patrocinadores", " 4 Estructura e importe de datos TODO 4.1 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:09:57 UTC&quot; proc.time() ## user system elapsed ## 0.435 0.119 0.420 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["control-de-calidad.html", "5 Control de calidad 5.1 Diapositivas de Peter Hickey 5.2 Ejercicio: entendiendo addPerCellQC 5.3 Gráficas sobre medidas de control de calidad (QC) 5.4 Eliminar células de baja calidad 5.5 Ejercicio: filtrado de células 5.6 Datos de Grun et al 5.7 Gráficas de QC extra 5.8 Ejercicio: ERCC Grun et al 5.9 Identificando droplets vacíos con datos de PBMC 5.10 Ejercicio: detección de droplets vacíos 5.11 Filtrado de expresión mitocondrial adicional 5.12 Ejercicio avanzado 5.13 Discusión ¿Conviene eliminar datos? 5.14 Explorando datos de forma interactiva con iSEE 5.15 Detalles de la sesión de R Patrocinadores", " 5 Control de calidad Instructor: Leonardo Collado Torres ## Paquetes de este capítulo library(&quot;scRNAseq&quot;) ## para descargar datos de ejemplo library(&quot;AnnotationHub&quot;) ## para obtener información de genes library(&quot;scater&quot;) ## para gráficas y control de calidad library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;DropletUtils&quot;) ## para detectar droplets library(&quot;Matrix&quot;) ## para leer datos en formatos comprimidos 5.1 Diapositivas de Peter Hickey Ve las diapositivas aquí 5.2 Ejercicio: entendiendo addPerCellQC ## Datos library(&quot;scRNAseq&quot;) sce.416b &lt;- LunSpikeInData(which = &quot;416b&quot;) ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## snapshotDate(): 2021-05-18 ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## require(&quot;ensembldb&quot;) sce.416b$block &lt;- factor(sce.416b$block) # Descarga los archivos de anotación de la base de datos de Ensembl # correspondientes usando los recursos disponibles vía AnnotationHub library(&quot;AnnotationHub&quot;) ah &lt;- AnnotationHub() ## snapshotDate(): 2021-05-18 query(ah, c(&quot;Mus musculus&quot;, &quot;Ensembl&quot;, &quot;v97&quot;)) ## AnnotationHub with 1 record ## # snapshotDate(): 2021-05-18 ## # names(): AH73905 ## # $dataprovider: Ensembl ## # $species: Mus musculus ## # $rdataclass: EnsDb ## # $rdatadateadded: 2019-05-02 ## # $title: Ensembl 97 EnsDb for Mus musculus ## # $description: Gene and protein annotations for Mus musculus based on Ensem... ## # $taxonomyid: 10090 ## # $genome: GRCm38 ## # $sourcetype: ensembl ## # $sourceurl: http://www.ensembl.org ## # $sourcesize: NA ## # $tags: c(&quot;97&quot;, &quot;AHEnsDbs&quot;, &quot;Annotation&quot;, &quot;EnsDb&quot;, &quot;Ensembl&quot;, &quot;Gene&quot;, ## # &quot;Protein&quot;, &quot;Transcript&quot;) ## # retrieve record with &#39;object[[&quot;AH73905&quot;]]&#39; # Obtén la posición del cromosoma para cada gen ens.mm.v97 &lt;- ah[[&quot;AH73905&quot;]] ## loading from cache location &lt;- mapIds( ens.mm.v97, keys = rownames(sce.416b), keytype = &quot;GENEID&quot;, column = &quot;SEQNAME&quot; ) ## Warning: Unable to map 563 of 46604 requested IDs. # Identifica los genes mitocondriales is.mito &lt;- which(location == &quot;MT&quot;) library(&quot;scater&quot;) sce.416b &lt;- addPerCellQC(sce.416b, subsets = list(Mito = is.mito) ) ## Si quieres guarda los resultados de addPerCellQC() para responder ## las preguntas del ejercicio. Eventualmente si necesitaremos los ## resultados de addPerCellQC() para las secciones posteriores a este ## ejercicio. ¿Qué cambió en nuestro objeto sce después de addPerCellQC? 1 Haz una gráfica de boxplots del número de genes por bloque (block) de células. 2 5.3 Gráficas sobre medidas de control de calidad (QC) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;) + scale_y_log10() plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) 5.3.1 Ejercicio: gráficas QC ERCC Adapta el código de las gráficas anteriores para otra variable de control de calidad. Por ejemplo, escribe el código para reproducir las siguientes gráficas. Basado en las gráficas encuentra la variable de colData(sce.416b) que contiene la información que queremos gráficar. ¡No hay que reemplazar todo lo que diga phenotype Tengo cuidado con las transformaciones de valores en el eje Y. No aplican para todo tipo de datos. 5.4 Eliminar células de baja calidad # Valores de límite ejemplo qc.lib &lt;- sce.416b$sum &lt; 100000 qc.nexprs &lt;- sce.416b$detected &lt; 5000 qc.spike &lt;- sce.416b$altexps_ERCC_percent &gt; 10 qc.mito &lt;- sce.416b$subsets_Mito_percent &gt; 10 discard &lt;- qc.lib | qc.nexprs | qc.spike | qc.mito # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib), NExprs = sum(qc.nexprs), SpikeProp = sum(qc.spike), MitoProp = sum(qc.mito), Total = sum(discard) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 3 0 19 14 33 ## Usando isOutlier() para determinar los valores de corte qc.lib2 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;) qc.nexprs2 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot; ) qc.spike2 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot; ) qc.mito2 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot; ) discard2 &lt;- qc.lib2 | qc.nexprs2 | qc.spike2 | qc.mito2 # Extraemos los límites de valores (thresholds) attr(qc.lib2, &quot;thresholds&quot;) ## lower higher ## 434082.9 Inf attr(qc.nexprs2, &quot;thresholds&quot;) ## lower higher ## 5231.468 Inf # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib2), NExprs = sum(qc.nexprs2), SpikeProp = sum(qc.spike2), MitoProp = sum(qc.mito2), Total = sum(discard2) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 4 0 1 2 6 ## Más pruebas plotColData(sce.416b, x = &quot;block&quot;, y = &quot;detected&quot;, other_fields = &quot;phenotype&quot; ) + scale_y_log10() + facet_wrap(~phenotype) ## Determino el bloque (batch) de muestras batch &lt;- paste0(sce.416b$phenotype, &quot;-&quot;, sce.416b$block) ## Versión de isOutlier() que toma en cuenta los bloques de muestras qc.lib3 &lt;- isOutlier(sce.416b$sum, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.nexprs3 &lt;- isOutlier(sce.416b$detected, log = TRUE, type = &quot;lower&quot;, batch = batch ) qc.spike3 &lt;- isOutlier(sce.416b$altexps_ERCC_percent, type = &quot;higher&quot;, batch = batch ) qc.mito3 &lt;- isOutlier(sce.416b$subsets_Mito_percent, type = &quot;higher&quot;, batch = batch ) discard3 &lt;- qc.lib3 | qc.nexprs3 | qc.spike3 | qc.mito3 # Extraemos los límites de valores (thresholds) attr(qc.lib3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 461073.1 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 399133.7 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 599794.9 370316.5 ## higher Inf Inf attr(qc.nexprs3, &quot;thresholds&quot;) ## induced CBFB-MYH11 oncogene expression-20160113 ## lower 5399.24 ## higher Inf ## induced CBFB-MYH11 oncogene expression-20160325 ## lower 6519.74 ## higher Inf ## wild type phenotype-20160113 wild type phenotype-20160325 ## lower 7215.887 7586.402 ## higher Inf Inf # Obtenemos un resumen del número de células # eliminadas por cada filtro DataFrame( LibSize = sum(qc.lib3), NExprs = sum(qc.nexprs3), SpikeProp = sum(qc.spike3), MitoProp = sum(qc.mito3), Total = sum(discard3) ) ## DataFrame with 1 row and 5 columns ## LibSize NExprs SpikeProp MitoProp Total ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## 1 5 4 6 2 9 5.5 Ejercicio: filtrado de células ¿Fue necesario qc.lib para crear discard? 3 ¿Cúal filtro fue más estricto? ¿discard o discard2? 4 Al considerar el grupo de cada muestra (batch), ¿descartamos más células usando un valor de límite automático? 5 5.6 Datos de Grun et al ¿Qué patrón revela esta gráfica? sce.grun &lt;- GrunPancreasData() ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## downloading 1 resources ## retrieving 1 resource ## loading from cache ## snapshotDate(): 2021-05-18 ## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation ## loading from cache sce.grun &lt;- addPerCellQC(sce.grun) ## ¿Qué patrón revela esta gráfica? plotColData(sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ¿Cúal de las siguientes gráficas identifica mejor las células de baja calidad? ## isOutlier() puede ayudarnos cuando un grupo de muestras ## tuvo más problemas que el resto discard.ercc &lt;- isOutlier(sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection discard.ercc2 &lt;- isOutlier( sce.grun$altexps_ERCC_percent, type = &quot;higher&quot;, batch = sce.grun$donor, subset = sce.grun$donor %in% c(&quot;D17&quot;, &quot;D2&quot;, &quot;D7&quot;) ) ## Warning in .get_med_and_mad(metric, batch = batch, subset = subset, ## share.medians = share.medians, : missing values ignored during outlier detection ## isOutlier() tomando en cuenta el batch plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). ## isOutlier() tomando en cuenta batch y muestras que fallaron plotColData( sce.grun, x = &quot;donor&quot;, y = &quot;altexps_ERCC_percent&quot;, colour_by = data.frame(discard = discard.ercc2) ) ## Warning: Removed 10 rows containing non-finite values (stat_ydensity). ## Warning: Removed 10 rows containing missing values (position_quasirandom). 5.7 Gráficas de QC extra Otras gráficas que podemos hacer. # Agregamos información sobre que células # tienen valores extremos sce.416b$discard &lt;- discard2 # Haz esta gráfica para cada medida de # control de calidad (QC) plotColData( sce.416b, x = &quot;block&quot;, y = &quot;sum&quot;, colour_by = &quot;discard&quot;, other_fields = &quot;phenotype&quot; ) + facet_wrap(~phenotype) + scale_y_log10() # Otra gráfica de diagnóstico útil plotColData( sce.416b, x = &quot;sum&quot;, y = &quot;subsets_Mito_percent&quot;, colour_by = &quot;discard&quot;, other_fields = c(&quot;block&quot;, &quot;phenotype&quot;) ) + facet_grid(block ~ phenotype) 5.8 Ejercicio: ERCC Grun et al Adapta el código de sce.416b para los datos de Grun et al y reproduce la imagen siguiente. Fíjate en que variables de colData() estamos graficando. ¿Existe la variable discard en colData()? ¿Qué variable tiene valores de D10, D17, D2, D3 y D7? 5.9 Identificando droplets vacíos con datos de PBMC Descripción gráfica la tecnología Next GEM de 10x Genomics. Fuente: 10x Genomics. Opciones algorítmicas para detecar los droplets vacíos. Fuente: Lun et al, Genome Biology, 2019. ## Descarguemos los datos library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath( bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; ) ) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) ## Leamos los datos en R library(&quot;DropletUtils&quot;) library(&quot;Matrix&quot;) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) bcrank &lt;- barcodeRanks(counts(sce.pbmc)) # Mostremos solo los puntos únicos para acelerar # el proceso de hacer esta gráfica uniq &lt;- !duplicated(bcrank$rank) plot( bcrank$rank[uniq], bcrank$total[uniq], log = &quot;xy&quot;, xlab = &quot;Rank&quot;, ylab = &quot;Total UMI count&quot;, cex.lab = 1.2 ) ## Warning in xy.coords(x, y, xlabel, ylabel, log): 1 y value &lt;= 0 omitted from ## logarithmic plot abline( h = metadata(bcrank)$inflection, col = &quot;darkgreen&quot;, lty = 2 ) abline( h = metadata(bcrank)$knee, col = &quot;dodgerblue&quot;, lty = 2 ) legend( &quot;bottomleft&quot;, legend = c(&quot;Inflection&quot;, &quot;Knee&quot;), col = c(&quot;darkgreen&quot;, &quot;dodgerblue&quot;), lty = 2, cex = 1.2 ) Encontremos los droplets vacíos usando emptyDrops(). ## Usemos DropletUtils para encontrar los droplets set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) # Revisa ?emptyDrops para una explicación de porque hay valores NA summary(e.out$FDR &lt;= 0.001) ## Mode FALSE TRUE NA&#39;s ## logical 989 4300 731991 set.seed(100) limit &lt;- 100 all.out &lt;- emptyDrops(counts(sce.pbmc), lower = limit, test.ambient = TRUE) # Idealmente, este histograma debería verse uniforme. # Picos grandes cerca de cero indican que los _barcodes_ # con un número total de cuentas menor a &quot;lower&quot; no son # de origen ambiental. hist(all.out$PValue[all.out$Total &lt;= limit &amp; all.out$Total &gt; 0], xlab = &quot;P-value&quot;, main = &quot;&quot;, col = &quot;grey80&quot; ) 5.10 Ejercicio: detección de droplets vacíos ¿Por qué emptyDrops() regresa valores NA? 6 ¿Los valores p son iguales entre e.out y all.out? 7 ¿Son iguales si obtienes el subconjunto de valores que no son NA? 8 5.11 Filtrado de expresión mitocondrial adicional Después de filtar los droplets, el filtrado por expresión mitocondrial nos va a ayudar a eliminar células de baja calidad. sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] is.mito &lt;- grep(&quot;^MT-&quot;, rowData(sce.pbmc)$Symbol) sce.pmbc &lt;- addPerCellQC(sce.pbmc, subsets = list(MT = is.mito)) discard.mito &lt;- isOutlier(sce.pmbc$subsets_MT_percent, type = &quot;higher&quot;) plot( sce.pmbc$sum, sce.pmbc$subsets_MT_percent, log = &quot;x&quot;, xlab = &quot;Total count&quot;, ylab = &quot;Mitochondrial %&quot; ) abline(h = attr(discard.mito, &quot;thresholds&quot;)[&quot;higher&quot;], col = &quot;red&quot;) 5.12 Ejercicio avanzado Volvamos a crear sce.pbmc para poder usar plotColData() y visualizar la relación entre total y los niveles de expresión mitocondrial (en porcentaje) separando lo que pensamos que son droplets vacíos y las células de acuerdo a los resultados que ya calculamos de emptyDrops(). El resultado final se verá como en la siguiente imagen. No podemos usar nuestro objeto sce.pbmc porque ya eliminamos los droplets vacíos al correr sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)]. Por eso tendremos que volver a usar sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE). Una vez que hayamos vuelto a hacer sce.pbmc, tenemos que guardar en ese objeto los resultados de emptyDrops(). Por ejemplo, con sce.pbmc$is_cell &lt;- e.out$FDR &lt;= 0.001. Como e.out$FDR tiene muchos NA, nos conviene filtrar esos datos. Tendremos que volver a correr addPerCellQC() y guardar los resultados en nuestro objeto sce.pbmc. Al final usaremos plotColData() junto con facet_grid(~ sce.pbmc$is_cell). 5.13 Discusión ¿Conviene eliminar datos? # Eliminemos las células de calidad baja # al quedarnos con las columnas del objeto sce que NO # queremos descartar (eso hace el !) filtered &lt;- sce.416b[, !discard2] # Alternativamente, podemos marcar # las células de baja calidad marked &lt;- sce.416b marked$discard &lt;- discard2 ¿Cúal de estos objetos es más grande? 9 ¿Cúal prefieres usar? 10 5.13.1 Un nuevo paquete: ExperimentSubset En BioC2021 presentaron ExperimentSubset que provee otro camino para resolver este dilema. Descripción gráfica de ExperimentSubset. Fuente: vignette ExperimentSubset. 5.14 Explorando datos de forma interactiva con iSEE #rstats / @Bioconductor congrats winners of the 1st Shiny Contest: iSEE https://t.co/oHgGkWqRsJ https://t.co/vZLFvcMBIS ! — Bioconductor (@Bioconductor) April 7, 2019 http://bioconductor.org/packages/release/bioc/html/iSEE.html http://bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html ## Hagamos un objeto sencillo de tipo RangedSummarizedExperiment library(&quot;SummarizedExperiment&quot;) ## ?SummarizedExperiment ## De los ejemplos en la ayuda oficial ## Creamos los datos para nuestro objeto de tipo SummarizedExperiment ## para 200 genes a lo largo de 6 muestras nrows &lt;- 200 ncols &lt;- 6 ## Números al azar de cuentas set.seed(20210223) counts &lt;- matrix(runif(nrows * ncols, 1, 1e4), nrows) ## Información de nuestros genes rowRanges &lt;- GRanges( rep(c(&quot;chr1&quot;, &quot;chr2&quot;), c(50, 150)), IRanges(floor(runif(200, 1e5, 1e6)), width = 100), strand = sample(c(&quot;+&quot;, &quot;-&quot;), 200, TRUE), feature_id = sprintf(&quot;ID%03d&quot;, 1:200) ) names(rowRanges) &lt;- paste0(&quot;gene_&quot;, seq_len(length(rowRanges))) ## Información de nuestras muestras colData &lt;- DataFrame( Treatment = rep(c(&quot;ChIP&quot;, &quot;Input&quot;), 3), row.names = LETTERS[1:6] ) ## Juntamos ahora toda la información en un solo objeto de R rse &lt;- SummarizedExperiment( assays = SimpleList(counts = counts), rowRanges = rowRanges, colData = colData ) ## Exploremos el objeto resultante rse ## class: RangedSummarizedExperiment ## dim: 200 6 ## metadata(0): ## assays(1): counts ## rownames(200): gene_1 gene_2 ... gene_199 gene_200 ## rowData names(1): feature_id ## colnames(6): A B ... E F ## colData names(1): Treatment ## Explora el objeto rse de forma interactiva library(&quot;iSEE&quot;) if (interactive()) { iSEE::iSEE(rse) } 5.14.1 Ejercicio iSEE con sce.416b Repitamos la imagen que hicimos anteriormente. ## Explora el objeto sce.416b de forma interactiva if (interactive()) { iSEE::iSEE(sce.416b, appTitle = &quot;sce.416b&quot;) } 5.14.2 Datos de LIBD de Tran et al Datos de Tran et al, bioRxiv, 2020. Código de R para el sitio web: https://github.com/LieberInstitute/10xPilot_snRNAseq-human/tree/master/shiny_apps/tran2021_AMY. 5.14.3 Más detalles de iSEE Notas en inglés. 5.15 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:14:03 UTC&quot; proc.time() ## user system elapsed ## 217.461 5.062 245.697 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub * 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE * 2.4.0 2021-05-19 [1] Bioconductor ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Ahora tenemos más información en colData(sce.416b)↩︎ with(colData(sce.416b), boxplot(detected ~ block))↩︎ Sí, usando table(qc.lib , qc.spike) y table(qc.lib , qc.mito).↩︎ discard de table(discard, discard2)↩︎ Sí, usando table(discard, discard2, discard3)↩︎ Debajo de lower son considerados droplets vacíos. Solo se usan para la correción estadística de pruebas múltiples.↩︎ No, debido a los NAs.↩︎ Sí: identical(e.out$PValue[!is.na(e.out$FDR)], all.out$PValue[!is.na(e.out$FDR)]).↩︎ marked es más grande que filtered↩︎ Yo prefiero usar marked si tengo suficiente memoria para usarlo.↩︎ "],["normalización-de-datos.html", "6 Normalización de datos 6.1 Material 6.2 Motivación 6.3 Datos 6.4 Normalización por escalamiento (scaling normalization) 6.5 Normalización por decircunvolución (deconvolution) 6.6 Transformación logatítmica 6.7 Otras normalizaciones 6.8 Notas finales 6.9 Adicionales 6.10 Agradecimientos 6.11 Detalles de la sesión de R Patrocinadores", " 6 Normalización de datos Instructora: Ana Beatriz Villaseñor Altamirano 6.1 Material Diapositivas de Peter Hickey: Ve las diapositivas aquí Capítulo de OSCA: Ve el capítulo del libro OSCA aquí 6.2 Motivación Al igual que otras tecnologías, single-cell RNA-seq (scRNA-seq) tiene errores sistemáticos y es importante conocerlos. Dentro de los más comunes se encuentran la captura de cDNA y la amplificación de PCR que se lleva acabo por célula. Tener poco material de inicio dificulta lograr una preparación de libreria consistente dando lugar a errores sistemáticos. Figura tomada de [1] La normalización tiene como objetivo remover estás diferencias sistemáticas para que no interfieran cuando comparamos los perfiles de expresión entre células. Al normalizar los datos, las diferencias observadas entre poblaciones célulares o condiciones son debido a la biología y no por factores técnicos. 6.2.1 Ejercicio: Conceptos básicos Da ejemplos de sesgos técnicos (TIP: ¿Qué es RPKM?). ¿Qué es correción por lote (batch effect correction)? Da un ejemplo. ¿Cuáles son las diferencias entre correción por lote y normalización? 6.3 Datos Usaremos el dataset de Zeisel. Tipos celulares en cerebro de ratón (oligodendrocitos, microglias, neuronas, etc.) Procesado con STRT-seq (similar a CEL-seq), un sistema de microfluio. 3005 células y 18441 genes Contiene UMIs library(&quot;scRNAseq&quot;) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) sce.zeisel ## class: SingleCellExperiment ## dim: 18441 3005 ## metadata(0): ## assays(1): counts ## rownames(18441): ENSMUSG00000029669 ENSMUSG00000046982 ... ## ENSMUSG00000064337 ENSMUSG00000065947 ## rowData names(2): featureType originalName ## colnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12 ## 1772058148_F03 ## colData names(10): tissue group # ... level1class level2class ## reducedDimNames(0): ## mainExpName: endogenous ## altExpNames(2): ERCC repeat 6.3.1 Ejercicio: QC ¿Cuántos genes son mitocondriales? (TIP: is.mito) ¿Cuántos genes tienen: bajas cuentas de librería, bajos features, alto porcentaje de expresión de ERCC, alto porcentaje de genes MT? ¿Cuántas células descartamos? (TIP: perCellQCMetrics y quickPerCellQC) Gráfica los resultados 6.4 Normalización por escalamiento (scaling normalization) La normalización por escalamiento es la estrategia más simple y usada. Representa el estimado del sesgo relativo en cada célula. Se realiza dividiendo todas las cuentas de cada célula por un factor de escalamiento específico para cada una. Este factor de escalamiento se le conoce como Library Size factor. \\[ CuentasNormalizadas = Cuentas / Library Size factor\\] Suposición: Cualquier sesgo específico en cada célula (e.j. eficiencia en la captura o en la amplificación) afecta a todos los genes de igual manera a través de escalar por el promedio esperado de cuentas para dicha célula. Los valores de expresión normalizados pueden ser usados por análisis posteriores como clustering o reducción de dimenciones. 6.4.1 Tamaño de biblioteca (Library Size) Tamaño de biblioteca (Library Size): La suma total de las cuentas a tráves de todos los genes en una célula. \\[Library Size_{cell} = \\sum_{n=1}^{j} gene\\] Donde \\(j\\) es el número total de genes y \\(gene\\) es el número de cuentas por gen para cada célula. El valor de library size es el que asumimos que escala con cualquier sesgo específico en cada célula. Para escalar los datos ocuparemos un factor de escalamiento llamado Library Size factor. \\[ Library Size \\propto Library Size factor \\] Se calcula usando library size: \\[ Library Size factor = {Library Size} / {mean(Library Size)}\\] Y se define de tal manera que el promedio de Library Size factor en todas las células es igual a 1. \\[ mean(Library Size factor) = 1 \\] Lo que nos permite que los valores normalizados están en la misma escala y pueden ser útiles para la interpretación. # Estimar tamaños de librerías lib.sf.zeisel &lt;- librarySizeFactors(sce.zeisel) # Examina la distribución de los tamaños de librerías # que acabamos de estimar summary(lib.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 hist(log10(lib.sf.zeisel), xlab = &quot;Log10[Library Size factor]&quot;, col = &quot;grey80&quot;) 6.4.2 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library Size ls.zeisel ¿Son idénticos ls.zeisel y lib.sf.zeisel? ¿Son proporcionales? Calcula lib.sf.zeisel de forma manual. TIP: Checa el código fuente 6.4.3 Puntos finales Normalizar por Library Size factor asume que no hay desigualdad en la cantidad de genes differencialmente expresados (DE) entre dos células. Es decir, que para cada grupo de genes sobre-expresados, debe existir un grupo de genes sub-expresados en la misma magnitud, cuando esto no pasa se le conoce como sesgo de composición (Veáse a continuación). Para análisis exploratorios, la precisión de la normalización no es un punto mayor a considerar. El sesgo por composición normalmente no afecta la separación de los clusters, solo la magnitud. La normalización por Library Size factor suele ser suficiente en algunas ocasiones donde se busca identificar clusters y los marcadores de los clusters. 6.5 Normalización por decircunvolución (deconvolution) Un sesgo técnico que es importante considerar es el sesgo de composición de RNA (transcriptoma). Supongamos que un gen X (o grupo de genes) se expresa en mayor cantidad en la célula A comparado a la célula B. Esto significa que más recursos fueron tomados por el gen X, disminuyendo la covertura de los demás. ¿Qué pasa si escalamos por tamaño de biblioteca? Figura tomada de [2] Este problema ha sido estudiado en bulk RNA-seq, DESeq2::estimateSizeFactorsFromMatrix() y edgeR::calcNormFactors(), contemplan este sesgo. Se assume que la mayoría de genes no estarán DE entre las muestras (en nuestro caso células) y cualquier diferencia entre los genes non-DE representa un sesgo el cual se remueve (calculando un factor de normalización). Sin embargo, single-cell RNA-seq tiene muchas cuentas bajas y ceros debido a limitaciones en la tecnología y no necesariamente indica ausencia de expresión. El método de scran resuelve este problema juntando las cuentas de varias células (pool) para incrementar el tamaño de las cuentas y obtener un factor de estimación que remueva el sesgo de composición de manera más precisa. Este factor calculado con las cuentas pool se les regresa individualmente a cada célula mediante decircunvolución (deconvolution). Utilizando este factor se normalizan los datos con scran::calculateSumFactors(). # Normalización por decircunvolución (deconvolution) library(&quot;scran&quot;) # Pre-clustering set.seed(100) clust.zeisel &lt;- quickCluster(sce.zeisel) # Calcula factores de tamaño para la decircunvolución (deconvolution) deconv.sf.zeisel &lt;- calculateSumFactors(sce.zeisel, clusters = clust.zeisel, min.mean = 0.1) # Examina la distribución de los factores de tamaño summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 hist(log10(deconv.sf.zeisel), xlab = &quot;Log10[Deconvolution size factor]&quot;, col = &quot;grey80&quot; ) plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16 ) abline(a = 0, b = 1, col = &quot;red&quot;) 6.5.1 Ejercicios: deconvolution ¿Cúantos clusters rápidos obtuvimos? ¿Cúantas células por cluster obtuvimos? ¿Cúantos clusters rápidos obtendríamos si cambiamos el tamaño mínimo a 200? Usa 100 como la semilla (seed). ¿Cúantas líneas ves en la gráfica? 6.5.2 Puntos finales La normalización por decircunvolución (deconvolution) mejora los resultados para análisis posteriores de una manera más precisa que los métodos para bulk RNA-seq. scran algunas veces alcula factores negativos o ceros lo cual altera la matrix de expresión normalizada. ¡Checa los factores que calculas! summary(deconv.sf.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1282 0.4859 0.8248 1.0000 1.3194 4.6521 Si obtienes factores negativos intenta variar el número de clusters, checa si incrementar el número de células por cluster te dan factores positivos. 6.6 Transformación logatítmica 6.6.1 Motivación ¿Qué gen es más interesante? Gen X: el promedio de expresión en el tipo celular A: 50 y B: 10 Gen Y: el promedio de expresión en el tipo celular A: 1100 y B: 1000 50 - 10 ## [1] 40 1100 - 1000 ## [1] 100 log(50) - log(10) ## [1] 1.609438 log(1100) - log(1000) ## [1] 0.09531018 Una vez calculados los factores de normalización con computeSumFactors(), podemos calular las cuentas en escala logaritmica usando logNormCounts(). Estos valores resultantes son valores de expresión normalizados transformados en escala logarítmica. # Normalization # set.seed(100) # clust.zeisel &lt;- quickCluster(sce.zeisel) # sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster=clust.zeisel, min.mean=0.1) # Log transformation sce.zeisel &lt;- scater::logNormCounts(sce.zeisel) assayNames(sce.zeisel) ## [1] &quot;counts&quot; &quot;logcounts&quot; 6.6.2 Ejercicio: Transformación logatítmica ¿Qué es una pseudo-cuenta? ¿Porqué se usa? ¿Qué valor de pseudo-cuenta usa logNormCounts()? ¿Qué es la opción downsample=TRUE? 6.7 Otras normalizaciones Te invitamos a leer más sobre otras formas de normalizar, un lugar para empezar lo puedes encontrar en el curso del Sanger Institute. Si estas interesad@ en diferencias en el contenido total de RNA en cada célula checa la normalización por spike-ins. La cual asume que los spike-ins fueron añadidos en un nivel constante en cada célula. Si tienes resultados donde el library size está asociado a tus datos a pesar de haber normalizado checa la opción de downsample=TRUE dentro de la función de logNormCounts(). 6.7.1 Seurat La normalización de Seurat con NormalizeData() (tomado de aquí): Dividir cada célula por el número total de moléculas medidas en la célula. - ¿Será library size? Multiplicar ese número por un scaling factor (e.j. 10000) Sumar 1 y tomar el logaritmo natural. library(&quot;Seurat&quot;) # Create a Seurat obj sce &lt;- sce.zeisel sce &lt;- removeAltExps(sce) seurat.zeisel &lt;- as.Seurat(sce, counts = &quot;counts&quot;, data = NULL) seurat.zeisel ## An object of class Seurat ## 18441 features across 2815 samples within 1 assay ## Active assay: endogenous (18441 features, 0 variable features) # Normalize using Seurat function seurat.zeisel &lt;- NormalizeData(seurat.zeisel, normalization.method = &quot;LogNormalize&quot;) # Compare Total counts per cell after normalization ls.seurat &lt;- colSums(seurat.zeisel[[SingleCellExperiment::mainExpName(x = sce)]]@data) ## Relacionado a ## https://github.com/satijalab/seurat/blob/9b3892961c9e1bf418af3bbb1bc79950adb481d7/R/objects.R#L1041-L1046 ## donde podemos ver como Seurat convierte el objeto de SingleCellExperiment ## a un objeto de Seurat summary(ls.seurat) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 hist(ls.seurat) # Trying to replicate it ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 step1 &lt;- t(counts(sce.zeisel)) / ls.zeisel # matrix(2,2,2,2) /c(1,2) step2 &lt;- step1 * 10000 step3 &lt;- t(log1p(step2)) ls.steps &lt;- colSums(step3) summary(ls.steps) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1460 2942 3693 3534 4097 4778 plot(ls.seurat, ls.steps) # Compare with deconv normalization ls.log &lt;- colSums(logcounts(sce.zeisel)) plot(ls.seurat, ls.log) Nota: scanpy ocupa un factor de normalización igual que Seurat. 6.8 Notas finales 6.8.1 Ejercicio: Conceptos básicos Da ejemplos de sesgos técnicos (TIP: ¿Qué es RPKM?). “Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content)” - hbctraining Algunos ejemplos de los sesgos técnicos que se contemplan son la profundidad de secuenciación y la longitud del gen. Profundidad de secuenciación: Es necesario contemplarlo para comparar entre muestras, en este caso células. Figura tomada de [2] Longitud del gen: Es necesario contemplarlo para comparar entre genes. Figura tomada de [2] ¿Qué es correción por lote (batch effect correction)? Da un ejemplo. “Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints. However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality. This results in systematic differences in the observed expression in cells from different batches, which we refer to as “batch effects”. Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results\" -OSCA ¿Cuáles son las diferencias entre correción por lote y normalización? “Normalization occurs regardless of the batch structure and only considers technical biases, while batch correction - as the name suggests - only occurs across batches and must consider both technical biases and biological differences. Technical biases tend to affect genes in a similar manner, or at least in a manner related to their biophysical properties (e.g., length, GC content), while biological differences between batches can be highly unpredictable” -OSCA 6.8.2 Ejercicio: QC ¿Cuántos genes son mitocondriales? (recuerdas is.mito) length(is.mito) ## [1] 34 ¿Cuántos genes tienen: bajas cuentas de librería, bajos features, alto porcentaje de expresión de ERCC, alto porcentaje de genes MT? ¿Cuántas células descartamos? (TIP: perCellQCMetrics y quickPerCellQC) colSums(as.data.frame(qc)) ## low_lib_size low_n_features high_altexps_ERCC_percent ## 0 3 66 ## high_subsets_Mt_percent discard ## 128 190 Gráfica los resultados # Plots colData(unfiltered) &lt;- cbind(colData(unfiltered), stats) unfiltered$discard &lt;- qc$discard gridExtra::grid.arrange( plotColData(unfiltered, y = &quot;sum&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Cuentas Totales&quot;), plotColData(unfiltered, y = &quot;detected&quot;, colour_by = &quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Features (genes) detectados&quot;), plotColData(unfiltered, y = &quot;altexps_ERCC_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;ERCC %&quot;), plotColData(unfiltered, y = &quot;subsets_Mt_percent&quot;, colour_by = &quot;discard&quot; ) + ggtitle(&quot;Mito %&quot;), ncol = 2 ) 6.8.3 Ejercicio: library Size Revisa los detalles (Details) en ?scater::librarySizeFactors Calcula library size ls.zeisel ls.zeisel &lt;- colSums(counts(sce.zeisel)) summary(ls.zeisel) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2623 8497 12964 14955 19080 60792 hist(log10(ls.zeisel), xlab = &quot;Log10[Library size]&quot;, col = &quot;grey80&quot;) ¿Son idénticos ls.zeisel y lib.sf.zeisel? identical(lib.sf.zeisel, ls.zeisel) ## [1] FALSE ¿Son proporcionales? # Checamos proporcionalidad plot( ls.zeisel, lib.sf.zeisel, log = &quot;xy&quot;, main = &quot;Proporcionalidad&quot;, xlab = &quot;Library size&quot;, ylab = &quot; Library size factor&quot; ) Calcula lib.sf.zeisel de forma manual. TIP: Checa el código fuente ## Ahora asegurate que su media sea 1 (unity mean) lib_size_factors &lt;- ls.zeisel / mean(ls.zeisel) summary(lib_size_factors) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1754 0.5682 0.8669 1.0000 1.2758 4.0651 identical(lib_size_factors, lib.sf.zeisel) ## [1] TRUE 6.8.4 Ejercicios: deconvolution ¿Cúantos clusters rápidos obtuvimos? levels(clust.zeisel) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ¿Cúantas células por cluster obtuvimos? cells_cluster &lt;- sort(table(clust.zeisel)) cells_cluster ## clust.zeisel ## 12 7 4 6 10 1 3 11 2 8 5 9 ## 113 123 140 224 231 243 252 259 281 300 324 325 barplot(cells_cluster) ¿Cúantos clusters rápidos obtendríamos si cambiamos el tamaño mínimo a 200? Usa 100 como la semilla (seed). set.seed(100) sort(table(quickCluster(sce.zeisel, min.size = 200))) ## ## 5 9 6 1 3 10 2 4 8 7 ## 224 231 236 243 252 259 281 324 325 440 ¿Cúantas líneas ves en la gráfica? plot(lib.sf.zeisel, deconv.sf.zeisel, xlab = &quot;Library size factor&quot;, ylab = &quot;Deconvolution size factor&quot;, log = &quot;xy&quot;, pch = 16, col = as.integer(factor(sce.zeisel$level1class)) ) abline(a = 0, b = 1, col = &quot;red&quot;) abline(a = -.2, b = 0.95, col = &quot;red&quot;) abline(a = 0.08, b = 1, col = &quot;red&quot;) 6.8.5 Ejercicio: Transformación logatítmica ¿Qué es una pseudo-cuenta? Un número que se agrega para poder sacar el logarítmo ¿Porqué se usa? Por que log(0) = -Inf y produce error más adelante. ¿Qué valor de pseudo-cuenta usa logNormCounts()? pseudo.count = 1 ¿Qué es la opción downsample=TRUE? OSCA: Downsampling. Para cuando existe un efecto en los valores que se asocia a la library size a pesar de haber nomalizado. Funciones interesantes para después de normalizar # sce.zeisel &lt;- runPCA(sce.zeisel) # plotPCA(sce.zeisel, colour_by = &quot;level1class&quot;) # plotRLE(sce.zeisel, exprs_values = &quot;logcounts&quot;, colour_by = &quot;level1class&quot;) 6.9 Adicionales [1] 2018 BioInfoSummer Workshop [2] HBC training 6.10 Agradecimientos Este curso está basado en el libro Orchestrating Single Cell Analysis with Bioconductor de Aaron Lun, Robert Amezquita, Stephanie Hicks y Raphael Gottardo, además del curso de scRNA-seq para WEHI creado por Peter Hickey. Y en el material de la comunidadbioinfo/cdsb2020 con el permiso de Leonardo Collado-Torres. 6.11 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:15:33 UTC&quot; proc.time() ## user system elapsed ## 80.963 5.254 89.812 options(width = 120) sessioninfo::session_info() ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.7.0 2021-01-04 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## survival 3.2-11 2021-04-26 [3] CRAN (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["selección-de-genes.html", "7 Selección de genes 7.1 Diapositivas de Peter Hickey 7.2 Motivación 7.3 Selección de features (genes) 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.5 Cuantificando la varianza por gen 7.6 Coeficiente de variación de las cuentas 7.7 Varianza de los log-counts vs coeficiente de variación 7.8 Detalles de la sesión de R Patrocinadores", " 7 Selección de genes Instructora: Yalbi I. Balderas-Martínez 7.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 7.2 Motivación Usualmente usamos datos scRNA-seq para caracterizar la heterogeneidad entre células Para hacer esto, usamos métodos como el clustering y la reducción de dimensionalidad Esto involucra resumir las diferencias por gen en una sola medida de (dis)similitud entre un par de células ¿Cuáles genes deberíamos usar para calcular esta medida de (dis)similitud? 7.3 Selección de features (genes) La elección de los features tiene un mayor impacto en qué tan similares decidimos que son las células ➕ Features que contienen información útil biológica ➖ Features que contienen ruido aleatorio 👉 Efectos laterales al reducir la dimensionalidad de los datos Deseamos seleccionar los genes altamente variables (High Variable Genes HVGs). Genes con una variación incrementada en comparación con otros genes que están siendo afectados por ruido técnico u otra variación biológica que no es de nuestro interés. 7.4 Dataset ilustrativo: PBMC4k 10X sin filtrar 7.4.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) sce.pbmc ## class: SingleCellExperiment ## dim: 33694 737280 ## metadata(1): Samples ## assays(1): counts ## rownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(2): ID Symbol ## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ... ## TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1 ## colData names(2): Sample Barcode ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 11 7.4.2 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 7.4.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 7.5 Cuantificando la varianza por gen 7.5.1 Varianza de los log-counts El enfoque más simple para cuantificar la variación per-feature es simplemente calcular la varianza de los log-counts ➕ Selección del feature basado en los log-counts (que serán usadas en los análisis más adelante) ⚠️ La transformación log no logra la estabilización de la varianza perfecta, así que se requiere modelar la relación de la varianza-media de los features. 7.5.2 Enfoque simple Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Ordenar los genes del más-al-menos variable 7.5.3 Un enfoque más sofisticado Calcular la varianza de los log-counts para cada gen (ignorando grupos experimentales) Modelar la relación de la media de la varianza de los log-counts para estimar la variación técnica Estimar la varianza biológica sustrayendo la varianza técnica de la varianza total Ordenar los genes de la variable de mayor-a-menor biológicamente 7.5.4 Supuestos # Varianza de las log-counts library(scran) dec.pbmc &lt;- modelGeneVar(sce.pbmc) 🤓 El supuesto es que a cualquier abundancia dada, la abundancia de los perfiles de expresión de la mayoría de los genes están dominados por el ruido aleatorio técnico 🤓 Por lo consiguiente, una tendencia representa un estimado del ruido técnico como una función de la abundancia 🤓 Podemos entonces descomponer la varianza total de cada gen en un componente técnico y uno biológico 🤓 Genes con una gran varianza biológica son considerados interesantes 7.5.5 Visualizando la media y varianza # Visualicemos la relación entre la media y la varianza fit.pbmc &lt;- metadata(dec.pbmc) plot(fit.pbmc$mean, fit.pbmc$var, xlab = &quot;Mean of log-expression&quot;, ylab = &quot;Variance of log-expression&quot; ) curve(fit.pbmc$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) 7.5.6 Ordenando genes interesantes # Ordenemos por los genes más interesantes para checar # los datos dec.pbmc[order(dec.pbmc$bio, decreasing = TRUE), ] ## DataFrame with 33694 rows and 6 columns ## mean total tech bio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## LYZ 1.95605 5.05854 0.835343 4.22320 1.10535e-270 2.17412e-266 ## S100A9 1.93416 4.53551 0.835439 3.70007 2.71038e-208 7.61579e-205 ## S100A8 1.69961 4.41084 0.824342 3.58650 4.31574e-201 9.43181e-198 ## HLA-DRA 2.09785 3.75174 0.831239 2.92050 5.93943e-132 4.86761e-129 ## CD74 2.90176 3.36879 0.793188 2.57560 4.83932e-113 2.50486e-110 ## ... ... ... ... ... ... ... ## TMSB4X 6.08142 0.441718 0.679215 -0.237497 0.992447 1 ## PTMA 3.82978 0.486454 0.731275 -0.244821 0.990002 1 ## HLA-B 4.50032 0.486130 0.739577 -0.253447 0.991376 1 ## EIF1 3.23488 0.482869 0.768946 -0.286078 0.995135 1 ## B2M 5.95196 0.314948 0.654228 -0.339280 0.999843 1 7.6 Coeficiente de variación de las cuentas El coeficiente de variación de las cuentas al cuadrado (CV2) es una alternativa a la varianza de los log-counts 👉 Se calcula usando las cuentas en lugar de los log-counts 🤓 CV es la tasa de la desviación estándar a la media y está muy relacionada con el parámetro de dispersión de la distribución binomial negativa usada en edgeR y DESeq2 7.6.1 Coeficiente de variación # Coeficiente de variación dec.cv2.pbmc &lt;- modelGeneCV2(sce.pbmc) 🤓 Modela la relación de la media de la varianza cuando se considera la relevancia de cada gen 🤓 Asume que la mayoría de los genes contienen ruido aleatorio y que la tendencia captura la mayoría de la variación técnica 🤓 Genes con un gran CV2 que se desvían fuertemente de la tendencia es probable que representen genes afectados por la estructura biológica 🤓 Usa la tasa (en lugar de la diferencia) del CV2 a la tendencia 7.6.2 Visualizando el coeficiente de variación 7.6.3 Genes por coeficiente de variación # Ordenemos por los genes más interesantes para checar # los datos dec.cv2.pbmc[order(dec.cv2.pbmc$ratio, decreasing = TRUE ), ] ## DataFrame with 33694 rows and 6 columns ## mean total trend ratio p.value FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## PPBP 2.2437397 132.364 0.803689 164.696 0 0 ## PRTFDC1 0.0658743 3197.564 20.266829 157.773 0 0 ## HIST1H2AC 1.3731487 175.035 1.176934 148.721 0 0 ## FAM81B 0.0477082 3654.419 27.902078 130.973 0 0 ## PF4 1.8333127 109.451 0.935484 116.999 0 0 ## ... ... ... ... ... ... ... ## AC023491.2 0 NaN Inf NaN NaN NaN ## AC233755.2 0 NaN Inf NaN NaN NaN ## AC233755.1 0 NaN Inf NaN NaN NaN ## AC213203.1 0 NaN Inf NaN NaN NaN ## FAM231B 0 NaN Inf NaN NaN NaN 7.7 Varianza de los log-counts vs coeficiente de variación Generalmente se usa la varianza de los log-counts Ambas son medidas efectivas para cuantificar la variación en la expresión génica CV2 tiende a tener otorgar rangos altos en abundancias bajas de genes altamente variables Éstos son dirigidos por una sobreregulación en subpoblaciones raras Puede asignar un alto rango a genes que no son de nuestro interés con varianza baja absoluta La variación descrita por el CV2 de las cuentas es menos relevante para los procedimientos que operan en los log-counts 7.8 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:17:42 UTC&quot; proc.time() ## user system elapsed ## 126.739 3.218 128.331 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ "],["reducción-de-dimensiones.html", "8 Reducción de dimensiones 8.1 Diapositivas de Peter Hickey 8.2 Motivación 8.3 Reducción de dimensionalidad 8.4 Dataset ilustrativo: Zeisel 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas 8.6 Análisis de Componentes Principales 8.7 Reducción de dimensionalidad para visualización 8.8 Donde estamos 8.9 Detalles de la sesión de R Patrocinadores", " 8 Reducción de dimensiones Instructora: Laura Gómez-Romero 8.1 Diapositivas de Peter Hickey Contenido adaptado de: aquí 8.2 Motivación El siguiente paso en el análisis de scRNA-seq usualmente consiste en identificar grupos de células “similares” Por ejemplo: un análisis de clustering busca identificar células con un perfil transcriptómico similar al calcular distancias entre ellas Si tuviéramos un dataset con dos genes podríamos hacer una gráfica de dos dimensiones para identificar clusters de células Pero… tenemos decenas de miles de genes : Reducción de dimensionalidad 8.3 Reducción de dimensionalidad Es poible porque la expresión de diferentes genes estará correlacionada si estos genes son afectados por el mismo proceso biológico. Por lo tanto, no necesitamos almacenar información independiente para genes individuales. Podemos comprimir móltiples “features” (genes) en una ónica dimensión. Ventajas: Reduce trabajo computacional en análisis posteriores Reduce el ruido al “promediar” mútiples genes obteniendo una representación mós precisa de los patrones en los datos Permite una graficación efectiva en dos dimensiones 8.4 Dataset ilustrativo: Zeisel library(scRNAseq) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) Estudio de tipos celulares en el cerebro de ratón (oligodendrocitos, microglia, neuronas, etc) procesados con el sistema STRT-seq (similar a CEL-Seq) Descripción aquí Zeisel, A. et al. Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq. Science 347, 1138-1142 (2015) # Quality control library(scater) is.mito &lt;- which(rowData(sce.zeisel)$featureType == &quot;mito&quot;) stats &lt;- perCellQCMetrics(sce.zeisel, subsets = list(Mt = is.mito) ) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;altexps_ERCC_percent&quot;, &quot;subsets_Mt_percent&quot;) ) sce.zeisel &lt;- sce.zeisel[, !qc$discard] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.zeisel) sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster = clusters ) sce.zeisel &lt;- logNormCounts(sce.zeisel) # variance-modelling dec.zeisel &lt;- modelGeneVarWithSpikes( sce.zeisel, &quot;ERCC&quot; ) 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 8.6 Análisis de Componentes Principales PCA es el arma principal de la reducción de dimensionalidad PCA descubre las combinaciones (lineales) de “features” que capturan la cantidad más grande de variación In PCA, la primer combinación lineal (componente principal) se elige tal que permite capturar la mayor varianza a través de las células. El siguiente PC se elige tal que es “ortogonal” al primero y captura la cantidad más grande de la variación restante, y así sucesivamente… 8.6.1 PCA aplicado a datos de scRNA-seq Podemos realizar reducción de dimensionalidad al aplicar PCA en la matriz de cuentas transformadas (log-counts matrix) y restringiendo los análisis posteriores a los primeros PCs (top PCs) Esto puede reducir nuestro dataset de 20,000 dimensiones a, digamos, 10, sin perder demasiada información La técnica de PCA tiene muchas propiedades teóricas bien estudiadas. Hay varias formas rápidas de realizar PCA en datasets grandes. 8.6.2 Suposiciones de PCA aplicadas a los datos de scRNA-seq Los procesos biológicos afectan múltiples genes en una manera coordinada Los primeros PCs probablemente representan la estructura biológica dado que más variación puede ser capturada considerando el comportamiento correlacionado de muchos genes Se espera que el ruido técnico azaroso afecte cada gen independientemente Consideración: Los primeros PCs capturarán “batch effects” (efectos de lote) que afectan muchos genes en una manera coordinada library(scran) top.zeisel &lt;- getTopHVGs(dec.zeisel, n = 2000) library(scater) set.seed(100) sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel ) Por default, runPCA() usa un método rápido aproximado que realiza simulaciones, por lo tanto, es necesario ‘configurar la semilla’ para obtener resultados reproducibles 8.6.3 Eligiendo el número de PCs Esta elección en análoga a la elección del numero de HVGs. Elegir más PCs evitará descartar señal biológica a expensas de retener más ruido Es común seleccionar un número de PCs “razonable” pero arbitrario (10-50), continuar con el análisis y regresar para checar la robustez de los resultados en cierto rango de valores Ahora exploraremos algunas estrategias guiadas por los datos (data-driven) para hacer esta selección 8.6.3.1 Usando el punto del codo library(PCAtools) percent.var &lt;- attr(reducedDim(sce.zeisel), &quot;percentVar&quot;) chosen.elbow &lt;- PCAtools::findElbowPoint(percent.var) plot(percent.var, xlab = &quot;PC&quot;, ylab = &quot;Variance explained (%)&quot;) abline(v = chosen.elbow, col = &quot;red&quot;) Una heurística simple es elegir el número de PCs basado en el porcentaje de varianza explicado por PCs sucesivos 8.6.3.2 Basados en la estructura de la población choices &lt;- getClusteredPCs(reducedDim(sce.zeisel)) chosen.clusters &lt;- metadata(choices)$chosen Esta es una aproximación heurística más sofisticada que usa el número de clusters como un proxy del número de subpoblaciones Supongamos que esperamos d subpoblaciones de células, en ese caso, necesitamos d-1 dimensiones para garantizar la separación de todas las subpoblaciones Pero… en un escenario real realmente no sabes cuántas poblaciones hay… Intenta con un rango para d y únicamente considera valores que produzcan a lo más d+1 clusters Cuando se seleccionan más clusters con menos dimensiones se produce ‘overclustering’ Elige una d que maximice el número de clusters sin caer en ‘overclustering’ Ventaja: Es una solución pragmática que soluciona el equilibrio sesgo-varianza en los análisis posteriores (especialmente clustering) Desventaja: Hace suposiciones fuertes sobre la naturaleza de las diferencias biológicas entre los clusters, y de hecho supone la existencia de clusters, los cuales podrían no existir en procesos biológicos como la diferenciación 8.6.4 Juntando todo set.seed(100) # Compute and store the &#39;full&#39; set of PCs sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel) # Can also select d and store the reduced set of PCs # e.g., using the elbow point reducedDim(sce.zeisel, &quot;PCA_elbow&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.elbow] # e.g., based on population structure reducedDim(sce.zeisel, &quot;PCA_clusters&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.clusters] 8.6.5 Usando el ruido técnico library(scran) set.seed(111001001) denoised.pbmc &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc, subset.row = top.pbmc ) Conserva todos los PCs hasta que el % de variación explicado alcance algun límite (por ejemplo, basado en la estimación de la variación técnica) denoisePCA() automáticamente selecciona el número de PCs Por default, denoisePCA() realiza algunas simulaciones, por lo tanto necesitamos ‘configurar la semilla’ para obtener resultados reproducibles dim(reducedDim(denoised.pbmc, &quot;PCA&quot;)) ## [1] 3985 9 La dimensionalidad del output es el límite inferior para el número de PCs requeridos para explicar toda la variación biológica. Lo que significa que cualquier número menor de PCs definitivamente descartaría algún aspecto de la señal biológica Esto no grantiza que los PCs retenidos capturen toda la señal biológica Esta técnica usualmente retiene más PCs que el método del punto del codo set.seed(001001001) denoised.zeisel &lt;- denoisePCA(sce.zeisel, technical = dec.zeisel, subset.row = top.zeisel ) dim(reducedDim(denoised.zeisel)) ## [1] 2815 50 scran::denoisePCA() internamente limita el numero de PCs, por default 5-50, para evitar la selección de excesivamente pocos PCs (cuando el ruido técnico es alto relativo al ruido biológico) o excesivamente muchos PCs (cuando el ruido técnico es demasiado bajo) Los datos de cerebro de Zeisel están cerca de este límite superior dec.pbmc2 &lt;- modelGeneVar(sce.pbmc) denoised.pbmc2 &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc2, subset.row = top.pbmc ) dim(reducedDim(denoised.pbmc2)) ## [1] 3985 5 scran::denoisePCA() tiende a funcionar mejor cuando la relación media-varianza refleja el ruiudo técnico verdadero, i.e estimado por scran::modelGeneVarByPoisson() o scran::modelGeneVarWithSpikes() en vez de scran::modelGeneVar() El dataset PBMC está cerca de este límite inferior 8.7 Reducción de dimensionalidad para visualización 8.7.1 Motivación Clustering y otros algoritmos operaran fácilmente sobre 10-50 (a lo más) PCs, pero ese número es aún demasiado para la visualización Por lo tanto, necesitamos estrategias adicionales para la reducción de dimensionalidad si queremos visualizar los datos 8.7.2 Visualizando con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, colour_by = &quot;level1class&quot; ) PCA es una técnica lineal, por lo tanto, no es eficiente para comprimir diferencias en más de 2 dimensiones en los primeros 2 PCs 8.7.3 Retos y resumen de la visualización con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, ncomponents = 4, colour_by = &quot;level1class&quot; ) Ventajas: PCA es predecible y no introducirá estructura aritficial en los datos Es deterministico y robusto a cambios pequeños en los valores de entrada Desventajas: Usualmente no es satisfactoria paara visualizar la naturaleza compleja de los datos de scRNA-seq 8.7.4 Visualización con t-SNE set.seed(00101001101) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) t-stochastic neighbour embedding (t-SNE) es la visualización por excelencia de datos de scRNA-seq. Intenta encontrar una representación (no-lineal) de los datos usando pocas dimensiones que preserve las distancias entre cada punto y sus vecinos en el espacio multi-dimensional 8.7.4.1 Retos de la visualización con t-SNE set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 30 ) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot; ) 8.7.4.2 Preguntas ¿Qué pasa si vuelves a correr runTSNE() sin especifica la semilla? ¿Qué pasa si especificas la semilla pero cambas el valor del parámetro perplexity? 8.7.4.3 Continuando Baja perplejidad favorece la resolución de la estrucutura fina, posiblemente al grado de que la visualización parece rudio random. El siguiente foro discute la selección de parámetros para t-SNE con cierta profundidad No sobreinterpretes los resultados de t-SNE como un ‘mapa’ de las identidades de las células individuales Componentes aleatorios y selección de parámetors cambiarán la visualización La interpretación puede ser engañada por el tamaño y posición de los clusters t-SNE infla clusters densos y comprime clusters escasos t-SNE no está obligado a preservar las localizaciones relativas de clusters no-vecinos (no puedes interpretar distancias no locales) Aún así: t-SNE es una herramienta probada para visualización general de datos de scRNA-seq y sigue siendo muy popular 8.7.5 Visualización con UMAP Uniform manifold approximation and project (UMAP) es una alternativa a t-SNE Así como t-SNE, UMAP intenta encontrar una representación (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional t-SNE y UMAP están basados en diferentes teorías matemáticas set.seed(1100101001) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) Comparado con t-SNE: UMAP tiende a tener clusters visualmente más compactos Intenta preservar más de la estructura global que t-SNE Tiende a ser más rápido que t-SNE, lo cual puede ser importante para datasets grandes. La diferencia desaprece cuando se aplican a PCs 8.7.5.1 Retos de la visualización con UMAP set.seed(100) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;, n_neighbors = 15 ) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) 8.7.5.2 Preguntas ¿Qué pasa si vuelves a correr runUMAP() sin especifica la semilla? ¿Qué pasa si especificas la semilla pero cambas el valor del parámetro n_neighbors? 8.7.5.3 Continuando Igual que para t-SNE, es necesario configurar una semilla y diferentes valores para los parámetros cambiarán la visualización Si el valor para los parámetros n_neighbors o min_dist es demasiado bajo entonces el ruido aleatorio se interpretará como estructura de alta-resolución, si son demasiado altos entonces se perderá la estructura fina TIP: Trata un rango de valores para cada parámetro para asegurarte de que no comprometen ninguna de las conclusiones derivadas de la gráfica UMAP 8.7.6 Interpretando las gráficas Recuerda: Reducción de dimensionalidad para la visualización de los datos necesariamente involucra descartar información y distorsionar las distancias entre las células No sobre interpretes las gráficas bonitas 8.7.7 Resumen y recomendaciones Las gráficas de t-SNE y UMAP son herramientas diagnóstico importantes, por ejemplo: para checar si dos clusters son realmente subclusters vecinos o si un cluster puede ser dividido en más de un cluster Es debatible cual visualización, t-SNE o UMAP, es más útil o estéticamente agradable. Está bien elegir aquélla que funcione mejor para tu análisis (tomando en cuenta que tratarás la gráfica únicamente como una herramienta de visualización/diagnóstico y que no llegarás a ninguna conclusión fuerte basado únicamente en la gráfica ) 8.8 Donde estamos 8.9 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:22:34 UTC&quot; proc.time() ## user system elapsed ## 287.929 6.946 290.933 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel * 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## PCAtools * 2.4.0 2021-05-19 [1] Bioconductor ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq * 2.6.1 2021-05-25 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["clustering.html", "9 Clustering 9.1 Diapositivas de Peter Hickey 9.2 Dataset ilustrativo: 10X PBMC4k no filtrado 9.3 Motivación 9.4 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? 9.5 ¿Cuál es el verdadero clustering? 9.6 Clustering basado en grafos 9.7 Implementación 9.8 Clustering basado en grafos 9.9 Otros métodos de clustering 9.10 Evaluando estabilidad de los clusters 9.11 Subclustering 9.12 Resumen y recomendaciones 9.13 Donde estamos 9.14 Detalles de la sesión de R Patrocinadores", " 9 Clustering Instructora: Laura Gómez-Romero 9.1 Diapositivas de Peter Hickey Ve las diapositivas aquí 9.2 Dataset ilustrativo: 10X PBMC4k no filtrado library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset de células mononucleares de sangre periférica humana (PBMC) de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) # dimensionality-reduction set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 9.3 Motivación Clustering es un procedimiento no supervisado par definir grupos de células con perfiles de expresión similares Su propósito principal es resumir los datos en un formato digerido susceptible a interpretación humana Nos permite asignar etiquetas (por ejemplo, tipos celulares) a las células 9.4 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? Las técnicas de t-SNE/UMAP han comprimido datos altamente multi-dimensionales en dos dimensiones Esta compresión inevitablemente ha provocado la perdida de información Por lo tanto, agrupamos sobre los PCs y después visualizamos las identidades de los clusters en la gráfica t-SNE/UMAP 9.5 ¿Cuál es el verdadero clustering? Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido 9.6 Clustering basado en grafos 9.6.1 Antecedentes El clustering basado en grafos fue popularizado (más no inventado) por su uso en Seurat Objetivo: Construir un grafo en el que cada nodo es una célula que está conectada a sus vecinos más cercanos en el espacio multidimensional 9.6.2 Gráfica de los k vecinos más cercanos (k-nearest neighbour -KNN- graph) Ilustremos como funciona para 20 células 9.6.3 Gráfica de los vecinos más próximos compartidos (SNN) De una gráfica KNN se puede construir una grafica SNN Podemos asignar pesos a cada arista del grafo, basándonos en la similaridad de las células involucradas, dándole pesos más altos a células que están más cercanamente relacionadas 9.6.4 Gráfica SNN con pesos en las aristas 9.6.5 Pasando de una gráfica SNN pesada cluster mediante detección de comunidades A partir de una gráfica SNN pesada podemos aplicar algoritmos para identificar comunidades de células Comunidades son grupos de células que están más conectadas a células en el mismo grupo que lo que están a células de un grupo diferente Cada comunidad representa un cluster 9.6.6 Resumen de clustering basado en grafos La construcción y búsqueda de una red KNN es rápida, por lo tanto, es escalable para datasets grandes Debes evitar obtener conclusiones fuertes acerca de la forma de los clusters o la distribución de células dentro de cada cluster Cada célula es conectada con un número mínimo de células vecinas obligatoriamente, esto reduce el riesgo de cluster no informativos con unos pocos outliers Después de la construcción del grafo, no se almacena información adicional más alla de las células vecinas. Esto puede producir subclusters artificiales en regiones con muchas células 9.7 Implementación ¿Cuántas céulas vecinas debo considerar durante la construcción del grafo? ¿Cómo debo pesar las aristas? ¿Cuál algoritmo de detección de comunidades se debe usar para definir los clusters? 9.8 Clustering basado en grafos library(scran) # Build graph using k = 10 nearest neighbours in PCA-space g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust &lt;- igraph::cluster_walktrap(g)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster &lt;- factor(clust) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) ¿Qué pasa si utilizas una k más grande o más pequeña? 9.8.1 Detalles adicionales del ejemplo previo KNNs se basan en la distancia Euclideana entre células Las aristas se crean entre todos los pares de células que comparten por lo menos un vecino Usa el esquema de peso de: Xu and Su (2015) 9.8.2 Eligiendo un valor de k El valor de k puede ser toscamente interpretado como el tamaño anticipado de la subpoblación más pequeña Si una subpoblación tiene menos que (k+1) células entonces el método será forzado a construir aristas entre células de esa subpoblación y células de otras subpoblaciones Esto incrementa el riesgo de que la subpoblación en cuestión no forme su propio cluster 9.8.3 Estilo Seurat # Jaccard-based weights followed by Louvain clustering # aka &#39;Seurat-style&#39; clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) clust2 &lt;- igraph::cluster_louvain(g)$membership sce.pbmc$cluster2 &lt;- factor(clust2) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) 9.8.4 Clustering basado en un grafo Pipelines basados en Seurat: Pesos basados en Jacard Clustering Louvain Pipelines basados en Scran: Pesos basados en Randos Clustering Walktrap Para detalles sobre la seleccion de parámetros y comparaciones: visitar esta página 9.8.5 Evaluando la separación de los clusters Modularidad es una métrica natural para evaluar la separación entre comunidades/clusters Definido como la diferencia (escalada) entre el peso total observado de las aristas entre los nodos en el mismo cluster y el peso total esperado si los pesos fueran distribuidos aleatoriamente entre todos los pares de nodos Nosotros computaremos un score de modularidad para cada cluster (usando las tasas en vez de las diferencias) library(bluster) ratio &lt;- pairwiseModularity(g, clust, as.ratio = TRUE) dim(ratio) ## [1] 16 16 library(pheatmap) pheatmap(log2(ratio + 1), cluster_rows = FALSE, cluster_cols = FALSE, color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(100) ) Un dataset que contiene clusters bien separados debería contener la mayoría del peso total observado en las entradas diagonales, i.e la mayoría de las aristas ocurren entre células del mismo cluster Para más detalles sobre evaluación de la separación entre clusters visite esta página 9.9 Otros métodos de clustering Clustering por k-means Rápido Se debe especificar el número de clusters de antemano Favorece clusters esféricos Clustering jerárquico Produce un dendograma (árbol) representando las células y la similaridad entre subpoblaciones a varias resoluciones Demasiado lento para correrse en algo más grande que los datasets más pequeños de scRNA-seq 9.10 Evaluando estabilidad de los clusters Una propiedad deseable de un cluster dado es que éste sea estable a las perturbaciones en los datos de entrada: Pequeños cambios al procesamiento no cambiarán el resultado Esto incrementa la probabilida de que las conclusiones puedan ser replicadas en un estudio independiente Uno puede hacer un proceso de bootstrap para evaluar la estabilidad de un algoritmo de clustering en un dataset dado myClusterFUN &lt;- function(x) { g &lt;- buildSNNGraph(x, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) igraph::cluster_louvain(g)$membership } originals &lt;- myClusterFUN(sce.pbmc) set.seed(0010010100) coassign &lt;- bootstrapStability(sce.pbmc, FUN = myClusterFUN, clusters = originals ) Coasignación es la probabilidad de que células elegidas al azar del cluster X y Y sean asignadas al mismo cluster en la réplica del proceso de bootstrap pheatmap(coassign, cluster_row = FALSE, cluster_col = FALSE, color = rev(viridis::magma(100)) ) Probabilidad alta de coasignación indica que X no es estable con respecto a su separación de Y. Queremos altas probabilidades de coasignación en la diagonal Bootstraping solo considera el efecto del ruido de muestreo e ignora otros factores que pueden afectar la reproducinilidad (efectos de batch, variación entre los donadores) Pobre separación puede ser altamente estable 9.11 Subclustering Mejora la resolucón al repetir el proceso de feature selection y clustering dentro de un único cluster Se enfoca en los HGVs y PCs que son los más relevantes para un cluster específico g.full &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) clust.full &lt;- igraph::cluster_walktrap(g.full)$membership sce.pbmc$clust.full &lt;- factor(clust.full) plotExpression(sce.pbmc, features = c(&quot;CD3E&quot;, &quot;CCR7&quot;, &quot;CD69&quot;, &quot;CD44&quot;), x = &quot;clust.full&quot;, colour_by = &quot;clust.full&quot; ) CD3E, CCR7, CD69, y CD44 son marcadores de células T de memoria. Dentro de las células T de memoria, ¿dónde están las subpoblaciones CD4+ y CD8+? # Repeating modelling and PCA on the subset of cells we have # identified as memory T-cells (cluster 6). memory &lt;- 6 sce.memory &lt;- sce.pbmc[, clust.full == memory] dec.memory &lt;- modelGeneVar(sce.memory) sce.memory &lt;- denoisePCA(sce.memory, technical = dec.memory, subset.row = getTopHVGs(dec.memory, prop = 0.1) ) # Repeating clustering on the subset. g.memory &lt;- buildSNNGraph(sce.memory, use.dimred = &quot;PCA&quot;) clust.memory &lt;- igraph::cluster_walktrap(g.memory)$membership sce.memory$clust.memory &lt;- factor(clust.memory) plotExpression(sce.memory, features = c(&quot;CD8A&quot;, &quot;CD4&quot;), x = &quot;clust.memory&quot; ) Expresión de CD4 es bajo, por lo tanto, su cambio es modesto, pero la interpretación es clara scran::quickSubCluster() ciclará sobre los clusters y realizará el proceso de subclustering de acuerdo a una función especificada por el usuario. Esto asume que la misma función es apropiada para todos los clusters Si tipos celulares o estados celulares se extienden sobre las fronteras de los clusters, entonces un subcluster podría representar contaminación de un tipo celular en un cluster separado 9.12 Resumen y recomendaciones Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido Clustering basado en grafos es rápido y evita tener que hacer suposiciones fuertes sobre la forma de los clusters o la distribución de las células dentro de cada cluster: scran::buildSNNGraph() igraph::cluster_walktrap() o igraph::cluster_louvain() Modularidad y estabilidad de los clusters son diagnósticos útiles El proceso de subclustering podría mejorar la resolución dentro de clusters grandes 9.13 Donde estamos 9.14 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:25:57 UTC&quot; proc.time() ## user system elapsed ## 201.297 4.917 202.927 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster * 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["identificación-de-genes-marcadores.html", "10 Identificación de genes marcadores 10.1 Diapositivas de Peter Hickey 10.2 Motivación 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.4 Motivación - continuación 10.5 Prueba t modificada de Welch pareada 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.7 Aplicación estándar 10.8 Usando el log-fold change 10.9 Encontrando marcadores específicos de clústeres 10.10 Pruebas alternas 10.11 Prueba de rangos de Wilcoxon 10.12 Prueba binomial 10.13 Métodos de expresión diferencial personalizados 10.14 Problemas estadísticos 10.15 Resumen y recomendaciones 10.16 Detalles de la sesión de R Patrocinadores", " 10 Identificación de genes marcadores Instructora: Yalbi I. Balderas-Martínez. 10.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 10.2 Motivación Ahora que hemos obtenido los clústeres, nos preguntamos, pero qué son? (e.g. ¿qué tipo celular es el clúster 1?) ¿Cuáles genes están dirigiendo el agrupamiento (e.g., ¿cuáles son los genes diferencialmente expresados entre los clústeres 1 y 2?) Idea: Mirar las diferencias en los perfiles de expresión de las células de los diferentes clústeres 10.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 10.3.1 Descargar datos # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 12 10.3.2 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 10.3.3 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 10.3.4 Genes variables ## Identificación de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 10.3.5 Reducción de dimensiones ## Reducción de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 10.3.6 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 10.4 Motivación - continuación ¿Algunos de estos genes están asociados con los resultados de clustering? Ver una gráfica como una forma de encontrar los genes marcadores obviamente no nos sirve a gran escala Necesitamos un método estadístico para identificar estos genes marcadores 👉 La prueba t de Welch es una opción obvia para probar las diferencias en la expresión entre clústeres 10.5 Prueba t modificada de Welch pareada ➕ Rápidas y buenas propiedades estadísticas para un gran número de células (Soneson and Robinson, 2018) ➕ Las comparaciones pareadas proveen un log-fold change para indicar cuáles clústerse son distinguidos por cada gen 🤔 ¿Por qué no comparar cada clúster con el promedio de todas las otras células? Sensible a la composición poblacional, una subpoblación dominante sola que dirige la selección de los marcadores top para cualquier otro clúster 10.6 Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X 10.6.1 Pruebas pareadas comparison logFC Pval 1 vs 2 1.50 1.7e-198 1 vs 3 -0.08 0.11 … … … 2 vs 1 1.39 1.7e-198 … … … 18 vs 17 0.11 0.46 K = 18 clústeres K!/(K-2)! = 306 comparaciones La mitad de ellas son redundantes 10.6.2 Combinando comparaciones del gen CD3E para el clúster 1 “Me interesa saber si el gen CD3 está diferencialmente expresado entre el clúster 1 y ..” cualquier (any) otro clúster = P = 1.3 x 10-205 (Simes adjusted P-value) todos (all) los otros clústeres = P = 0.11 (Berger’s intersection-union test) algunos (some) de los otros clústeres = P = 2.0 x 10-44 (mediana u otro cuantil, Holm-adjusted P-values) 10.6.2.1 Extendiendo a todos los genes scran::pairwiseTTests() scran::combineMarkers() M = 33,694 genes 🤓 K x M = 10,310,364 pruebas Comparaciones involucrando clúster 1… Comparaciones involucrando clúster … Comparaciones involucrando clúster 18 10.7 Aplicación estándar Para cada clúster, usar pruebas t de Welch para identificar los genes que están diferencialmente expresados entre éste y cualquier (any) otro clúster # scran::findMarkers() library(scran) markers.pbmc &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, pval.type = &quot;any&quot; ) 10.7.1 Explorando los resultados chosen &lt;- &quot;9&quot; interesting &lt;- markers.pbmc[[chosen]] 10.7.2 Con un heatmap best.set &lt;- interesting[interesting$Top &lt;= 6, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) library(pheatmap) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) 👉 Usamos el campo Top para identificar un conjunto de genes que distinguen el clúster 9 de cualquier otro clúster 10.8 Usando el log-fold change 10.8.1 Sin espeficiar el lfc Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados entre éste y cualquier otro clúster markers.pbmc.up &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.up &lt;- markers.pbmc.up[[chosen]] 10.8.2 Especificando el lfc Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados con un log-fold change (lfc) o al menos 1 entre éste y cualquier otro clúster markers.pbmc.up2 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;t&quot;, direction = &quot;up&quot;, lfc = 1, pval.type = &quot;any&quot; ) interesting.up2 &lt;- markers.pbmc.up2[[chosen]] 👉 La prueba t también nos permite especificar un log-fold change diferente de cero como la hipótesis nula 🤓 Es más riguroso que simplemente filtrar por log-fold change TREAT 10.8.3 Heatmap best.set &lt;- interesting.up2[interesting.up2$Top &lt;= 5, ] logFCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(logFCs) &lt;- sub(&quot;logFC.&quot;, &quot;&quot;, colnames(logFCs)) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) 👉 Los promedios están más centrados en un conjunto de genes marcadores candidatos que están sobreexpresados en el clúster 9 ⚠️ El incremento del rigor no se da sin costo ⚠️ Si el lfc es muy grande podría descartar genes útiles E.g., un gen sobreexpresado en una proporción pequeña de células en un clúster sigue siendo un marcador efectivo si el foco está en la especificidad más que en la sensibilidad 10.9 Encontrando marcadores específicos de clústeres 👉 Por defecto, scran::findMarkers() dará un alto rango a genes que están DE en cualquier comparación pareada 🤔 Quiero genes que son específicos de cada clúster 👉 Tú quieres genes que son DE en todas las comparaciones pareadas Para cada clúster, usa pruebas t de Welch para identificar genes que están sobreexpresados entre éste y todos los otros clústeres markers.pbmc.up3 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;all&quot; ) interesting.up3 &lt;- markers.pbmc.up3[[chosen]] 🤓 Usa una prueba de unión-intersección para combinar los P-values que es el máximo P-value de todas las comparaciones pareadas 10.9.1 Pros/cons de los genes marcadores específicos de los clústeres Poblacion Expresion_CD4 Expresion_CD8 DN(CD4-/CD8-) No No CD4+&gt; Si No CD8+&gt; No Si DP(CD4+/CD8+) Si Si 10.9.2 findMarkers con pval.type some Para cada clúster, usa pruebas t de Welch para identificar los genes que están sobreexpresados entre éste y algunos de los otros clústers markers.pbmc.up4 &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, direction = &quot;up&quot;, pval.type = &quot;some&quot; ) interesting.up4 &lt;- markers.pbmc.up4[[chosen]] 👉 Para cuando pval.type=\"all\" es muy estricto todavía pval.type=\"any\" es muy generoso 🤓 Aplica la corrección Holm-Bonferroni a los P-values y toma el mejor valor de en medio como el P-value combinado ⚠️ Perderás algunas garantías ofrecidas por los otros métodos 10.10 Pruebas alternas 10.10.1 Motivación La prueba t no es la única forma de comparar dos grupos de mediciones 🤔 Quiero una prueba que pueda ser usada perfectamente para distinguir dos clústeres uno del otro 👉 Prueba de rangos Wilcoxon 🤔 Quiero identificar genes que son expresados más frecuentemente en un clúster que en otro 👉 Prueba Binomial 10.11 Prueba de rangos de Wilcoxon Evalúa directamente la separación entre la distribución de la expresión de los diferentes clústeres 🤓 Es proporcional al área bajo la curva (AUC), que es la probabilidad de que una célula al azar de un clúster tenga mayor que expresión que una célula al azar de otro clúster 👉 AUCs de 1 o 0 indican que los dos clústeres tienen distribuciones de expresión separadas 🤓 También se conoce como prueba Wilcoxon-Mann-Whitney (WMW) 10.11.1 findMarkers para Wilcoxon Para cada clúster, usa la prueba de rangos de Wilcoxon para identificar genes que están sobreexpresados entre éste y cualquier otro clúster markers.pbmc.wmw &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;wilcox&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.wmw &lt;- markers.pbmc.wmw[[chosen]] 10.11.2 Heatmap de genes marcadores con Wilcoxon best.set &lt;- interesting.wmw[interesting.wmw$Top &lt;= 5, ] AUCs &lt;- as.matrix(best.set[, -(1:3)]) colnames(AUCs) &lt;- sub(&quot;AUC.&quot;, &quot;&quot;, colnames(AUCs)) pheatmap(AUCs, breaks = seq(0, 1, length.out = 21), color = viridis::viridis(21) ) 10.11.3 Resumen de la prueba de rangos de Wilcoxon ➕ Ofrece directamente la propiedad deseable de un gen marcador (i.e. que el gen distinga perfectamente entre dos clústeres) ➕ Es simétrico con respecto a las diferencias en el tamaño de los grupos comparados ➖ Es mucho más lento comparado con la prueba t (aunque esto en general no es un problema en la práctica) 10.12 Prueba binomial Es una prueba que identifica los genes que difieren en la proporción de células que se expresan entre clústeres Una definición mucho más estricta de genes marcadores 🤓 Convierte la expresión en una medida binaria de presencia/ausencia, por lo que toda la información cuantitativa es ignorada Desde una perspectiva práctica, puede ser más fácil para validar 10.12.1 findMarkers para binomial Para cada clúster, usa la prueba Binomial para identificar genes que están más frecuentemente expresados (sobreexpresados) en comparación con cualquier otro clúster markers.pbmc.binom &lt;- findMarkers(sce.pbmc, groups = sce.pbmc$cluster, test.type = &quot;binom&quot;, direction = &quot;up&quot;, pval.type = &quot;any&quot; ) interesting.binom &lt;- markers.pbmc.binom[[chosen]] 🤓 El efecto en el tamaño se reporta como el log-fold change en la proporción de las células que se expresan entre clústeres 👉 Log-fold changes grandes positivos, indican que el gen está más frecuentemente expresado en un clúster comparado con otro 10.12.2 Visualizando genes marcadores de la prueba bionomial 10.12.3 Resumen de la prueba binomial La prueba Binomial no toma en cuenta la normalización ➕ Produce genes marcadores que pueden ser más fáciles de validar ➖ Ser más estricto puede llevar a la pérdida de buenos marcadores candidatos 10.13 Métodos de expresión diferencial personalizados 🤔 ¿Por qué no usar edgeR/DESeq2/limma-voom u otros métodos personalizados (e.g., MAST)? 👉 Claro que puedes! Checa OSCA 👉 Pero éstos son tal vez algo exagerados para identificar genes marcadores 🤓 Las células son nuestras “réplicas” para el propósito de identificar genes marcadores 🤓 edgeR/DESeq2/limma-voom hacen asunciones más fuertes acerca de los datos que es más probable que no se cumplan para células individuales en scRNA-seq 10.14 Problemas estadísticos 10.14.1 Invalidez de P-values Todas las estrategias de DE para detectar genes marcadores entre clústeres son estadísticamente defectuosas de alguna manera 🤓 “Dragado de datos”: El análisis DE se realiza usando los mismos datos usados para obtener los clústeres 👉 Las pruebas para genes DE entre clústeres producirá inevitablemente algunos resultados significativos y así es como los clústeres serán definidos! 👉 Aún cuando los P-values son defectuosos, el efecto no es muy dañino para la detección de genes ya que los P-values solo son usados para los rangos 🤓 No se pueden usar P-values para definir “diferencias significativas” entre los clústeres con respecto a un umbral de la tasa de error 10.14.2 Naturaleza de la replicación 👉 Idealmente, validar algunos de los marcadores con una población de células independientes (y idealmente usando una técnica diferente, e.g., hibridación fluorescente in situ o qPCR) 10.14.3 Comentarios adicionales 👉 La estrategia de análisis DE es que los marcadores son definidos relativo a subpoblaciones en el mismo dataset 👉 Si un gen se expresa uniformemente a través de la población no servirá como un marcador e.g., los marcadores de las células T no serán detectados si solamente hay células T en los datos usualmente no es un problema, ya que tenemos idea de las células que se capturaron 👉 Existen métodos de machine learning para hacer la identificación de los genes marcadores, pero la humilde prueba t sigue siendo muy buena 10.15 Resumen y recomendaciones 👉 Crea múltiples listas de genes marcadores con diferentes niveles de rigor 👉 La forma más simple de interpretar los genes marcadores es que son los sobreexpresados de “forma única”, o son “genes específicos de clústeres”, especialmente si queremos imponer un log-fold change mínimo 👉 Puedes requerir hacer una identificación de genes marcadores más enfocada, e.g., subset de los datos de solo 2 clústeres de interés y entonces correr scran::findMarkers() 10.16 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:31:24 UTC&quot; proc.time() ## user system elapsed ## 324.825 4.355 326.426 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## kableExtra * 1.3.4 2021-02-20 [1] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rvest 1.0.1 2021-07-26 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## svglite 2.0.0 2021-02-20 [1] RSPM (R 4.1.0) ## systemfonts 1.0.2 2021-05-11 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## webshot 0.5.2 2019-11-22 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ "],["anotación-de-clusters-de-células.html", "11 Anotación de clusters de células 11.1 Diapositivas de Peter Hickey 11.2 Motivación 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.5 SingleR 11.6 Resumen de la anotación basada en una referencia (e.g., SingleR) 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores 11.8 Resumen y recomendaciones 11.9 Detalles de la sesión de R Patrocinadores", " 11 Anotación de clusters de células Instructora: Yalbi I. Balderas-Martínez. 11.1 Diapositivas de Peter Hickey Ver las diapositivas originales aquí 11.2 Motivación Ahora estamos a punto de obtener la interpretación biológica de los resultados Esta es la tarea más retadora en los análisis de datos scRNA-seq 👉 La obtención de clústeres es más o menos directa 🤔 ¿Cuál es el estado biológico que está representado por cada uno de los clústeres? 👉 Necesitamos hacer un puente entre el gap del dataset actual y el conocimiento biológico a priori (no siempre está disponible en una forma consistente y cualitativa) 🤔 ¿Qué es un tipo celular? 🔬 “Lo sabré cuando lo vea” 💻 “No” Aplicaremos varios métodos computacionales que explotan la información a priori para asignar el significado a un dataset no caracterizado de scRNA-seq. Algunas fuentes de información a priori Conjuntos de genes curados (e.g. Gene Ontology) Perfiles de expresión de bases de datos publicadas de referencia Los datos raros que tú hayas escondido en tu cerebro Google 11.3 Dataset ilustrativo: PBMC4k 10X sin filtrar # Usemos datos de pbmc4k library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí 13 11.3.1 Anotación # Anotación de los genes library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # Detección de _droplets_ con células set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] 11.3.2 Control de calidad # Control de calidad stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # Normalización de los datos library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) 11.3.3 Genes variables ## Identificación de genes altamente variables set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 11.3.4 Reducción de dimensiones ## Reducción de dimensiones set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 11.3.5 Clustering # clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) clust &lt;- igraph::cluster_walktrap(g)$membership sce.pbmc$cluster &lt;- factor(clust) 11.4 Asignando las etiquetas celulares a partir de los datos de referencia 11.4.1 Visión general 👉 Un enfoque directo es comparar los perfiles de expresión single-cell con datasets previamente anotados 👉 Las etiquetas pueden entonces ser asignadas a cada célula en nuestro dataset no caracterizado de prueba basado en la muestra de referencia más similar, por dar alguna definición de “similar” 👉 Cualquier dataset de expresión génica etiquetado (microarreglos, RNA-seq bulk, scRNA-seq) puede ser usado como una referencia ⚠️ Sin embargo, su confiabilidad depende enormemente en la calidad de los datos originales y la experiencia de los autores originales quienes asignaron las etiquetas en primer lugar 👉 Asignar las etiquetas a un dataset de “prueba” a partir de un dataset de “entrenamiento” (referencia), es un problema estándar en estadística / machine learning 👉 Usaremos el método SingleR (Aran et al. 2019) 11.5 SingleR 🤓 Asigna las etiquetas a las células basado en las muestras de referencia con las correlaciones de rangos más altas de Spearman 🤓 Para reducir el ruido, identifica genes marcadores entre pares de etiquetas (en la referencia) y calcula la correlación usando solamente esos marcadores 🤓 Hace algún tipo de tuneado fino, repitiendo las correlaciones solamente con los genes marcadores de las etiquetas con el mejor score, ayudando a resolver cualquier ambigüedad entre esas etiquetas al eliminar el ruido a partir de marcadores irrelevantes para otras etiquetas 11.5.1 SingleR incluye varias referencias Ver referencias # Human SingleR::BlueprintEncodeData() SingleR::DatabaseImmuneCellExpressionData() SingleR::HumanPrimaryCellAtlasData() SingleR::MonacoImmuneData() SingleR::NovershternHematopoieticData() # Mice SingleR::ImmGenData() SingleR::MouseRNASeqData() 11.5.2 Usando las referencias # if needed install celldex # create directory? y library(celldex) ref &lt;- celldex::BlueprintEncodeData() ❓ ¿Qué tipos celulares están disponibles en este dataset de referencia? 11.5.3 Usando las referencias integradas library(SingleR) pred &lt;- SingleR( test = sce.pbmc, ref = ref, labels = ref$label.main ) ❓ ¿Qué etiquetas han sido asignadas a los datos single-cell? ❓ ¿Cómo usaríamos las etiquetas “finas” con SingleR? 👉 Inspeccionamos los resultados usando un heatmap de los scores por célula y por etiqueta 👉 Idealmente, cada célula debería exhibir un score alto en una etiqueta relativa a todas las otras 👉 Los scores se muestran antes de cualquier tuneado fino y son normalizadas a [0, 1] dentro de cada célula 11.5.4 Podado de etiquetas (Label pruning) total_pruned &lt;- sum(is.na(pred$pruned.labels)) plotScoreHeatmap(pred, show.pruned = TRUE) 👉 SingleR intentará podar aquellas asignaciones de baja calidad marcándolas como NA 🤓 El podado se hace calculando la diferencia del score de la etiqueta asignada a partir del score de la mediana dentro de cada célula y entonces podando las células con un valor pequeño de esta diferencia plotScoreDistribution(pred) 👉 Distribución de las diferencias del score de la etiqueta asignada a partir del score de la mediana dentro de cada célula 11.5.5 Identificando los genes con anotación dirigida 🤔 ¿Por qué las células en este clúster se etiquetan como el tipo celular X? 👉 Examina la expresión de los genes marcadores para cada etiqueta en el dataset de prueba 👉 Si una célula en el dataset de prueba está asignado con confianza a una etiqueta en particular, uno esperaría que tenga una fuerte expresión de los marcadores de esa etiqueta (al menos sobreexpresión con respecto a las células asignadas a otras etiquetas) # install gmp, ClusterR, mbkmeans dependencies if needed library(clusterExperiment) sce.pbmc$labels &lt;- pred$labels all.markers &lt;- metadata(pred)$de.genes lab &lt;- &quot;B-cells&quot; # Get top-10 marker genes for B-cells compared to each other cell # type top.markers &lt;- Reduce(union, sapply(all.markers[[lab]], head, 10)) # plotHeatmap(sce.pbmc, order_columns_by=&quot;labels&quot;, # features=top.markers, center=TRUE, zlim=c(-3, 3), main=lab) ❓ Toma otro tipo celular e identifica los genes que dirigen la anotación 11.5.6 Comparando las etiquetas con los clústeres tab &lt;- table(Assigned = pred$pruned.labels, Cluster = sce.pbmc$cluster) library(pheatmap) # Proportion of cells in each cluster assigned to each label pheatmap(prop.table(tab, margin = 2), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) # (log-)number of cells in each cluster assigned to each label # Adding a pseudo-count of 10 to avoid strong color jumps with just # 1 cell. pheatmap(log2(tab + 10), color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(101) ) 11.5.7 Voilà plotTSNE(sce.pbmc, colour_by = &quot;labels&quot;, text_by = &quot;labels&quot;) 11.6 Resumen de la anotación basada en una referencia (e.g., SingleR) ➕ Se centra en aspectos de los datos que se sabe son interesantes, simplifica el proceso de la interpretación biológica ➖ Está restringido por la diversidad y la resolución de las etiquetas disponibles en el dataset de referencia 👉 Se pueden suplir referencias personalizadas a SingleR 11.7 Asignando las etiquetas de tipos celulares a partir de marcadores 🤔 ¿Cómo podemos hacer uso de nuestros genes marcadores agrupados? 🥉 Revisarlos en hojas de cálculo 🥈 Observar heatmaps 🥇 Realizar un gene set enrichment analysis 11.7.1 Gene set enrichment analysis 👉 Identifica las rutas y procesos que están (relativamente) activos en cada clúster basado en la sobreexpresión de los genes asociados en comparación con otros clústeres ➕ Un método confiable para determinar si las rutas están sobre- o sub- expresadas entre clúesteres ➕ Existen un montón de herramientas para gene set enrichment analysis ➖ Todas las conclusiones son relativas a otros clústeres, haciéndolo más difícil para determinar la identidad celular si alguno no está presente en el mismo estudio más info 11.7.2 Calculando las actividades de los conjuntos de genes 👉 Calcular el promedio de la expresión en log en todos los genes, en un conjunto de genes para cada célula y examinar los clústeres con valores altos (gene set activities) 👉 Se necesita proveer de conjuntos de genes ➖ No todos los genes en el conjunto pueden exhibir el mismo patrón de diferencia y los genes no-DE añadirán ruido, “diluyendo” la fuerza de cualquiera de las diferencias comparadas a un análisis que se centra directamente en genes DE 👉 Es más una visualización útil que la base para cualquier análisis estadístico real más info 11.8 Resumen y recomendaciones 👉 La anotación de tipos celulares “automática”, como SingleR, es mejor cuando funciona (i.e. cuando hay un dataset de referencia apropiado) 👉 Usualmente necesitaremos usar un método manual, como aquellos basados en agrupar los genes marcadores (e.g., gene set enrichment analysis) 👉 La anotación del tipo celular ofrecerá una reconsideración inmediata de los parámetros del agrupamiento y/o algunos retoques manuales a los clústeres 11.9 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:34:27 UTC&quot; proc.time() ## user system elapsed ## 179.279 4.329 182.671 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## ade4 1.7-17 2021-06-17 [1] RSPM (R 4.1.0) ## annotate 1.70.0 2021-05-19 [1] Bioconductor ## AnnotationDbi * 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter * 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## ape 5.5 2021-04-25 [1] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## Biobase * 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics * 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## celldex * 1.2.0 2021-05-20 [1] Bioconductor ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## clusterExperiment * 2.12.0 2021-05-19 [1] Bioconductor ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.2 2021-08-08 [1] Bioconductor ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils * 1.12.2 2021-07-22 [1] Bioconductor ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 * 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb * 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## genefilter 1.74.0 2021-05-19 [1] Bioconductor ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb * 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures * 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges * 1.44.0 2021-05-19 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 * 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## gridBase 0.4-7 2014-02-24 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## howmany 0.3-1 2012-06-01 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges * 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## kernlab 0.9-29 2019-11-12 [1] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## locfdr 1.1-8 2015-07-15 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix * 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics * 1.4.2 2021-08-08 [1] Bioconductor ## matrixStats * 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## NMF 0.23.0 2020-08-01 [1] RSPM (R 4.1.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## phylobase 0.8.10 2020-03-01 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## pkgmaker 0.32.2 2020-10-20 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## registry 0.5-1 2019-03-05 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## rncl 0.8.4 2020-02-10 [1] RSPM (R 4.1.0) ## RNeXML 2.4.5 2020-06-18 [1] RSPM (R 4.1.0) ## rngtools 1.5 2020-01-23 [1] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## S4Vectors * 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater * 1.20.1 2021-06-15 [1] Bioconductor ## scran * 1.20.1 2021-05-24 [1] Bioconductor ## scuttle * 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## SingleCellExperiment * 1.14.1 2021-05-21 [1] Bioconductor ## SingleR * 1.6.1 2021-05-20 [1] Bioconductor ## softImpute 1.4-1 2021-05-09 [1] RSPM (R 4.1.0) ## sparseMatrixStats 1.4.2 2021-08-08 [1] Bioconductor ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment * 1.22.0 2021-05-19 [1] Bioconductor ## survival 3.2-11 2021-04-26 [3] CRAN (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uuid 0.1-4 2020-02-26 [1] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zinbwave 1.14.1 2021-05-25 [1] Bioconductor ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).↩︎ "],["análisis-de-expresión-diferencial.html", "12 Análisis de expresión diferencial 12.1 Detalles de la sesión de R Patrocinadores", " 12 Análisis de expresión diferencial TODO 12.1 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:34:28 UTC&quot; proc.time() ## user system elapsed ## 0.37 0.16 0.40 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducción-a-seurat.html", "13 Introducción a Seurat 13.1 Diapositivas 13.2 Una perspectiva diferente 13.3 Kick-start 13.4 Quality Control 13.5 Normalización 13.6 Detección de genes (caractersticas) altamente variables 13.7 Escalar los datos 13.8 Reducción dimensional lineal 13.9 Determinar la dimensionalidad del conjunto de datos 13.10 Clustering 13.11 Reducción dimensional no lineal (UMAP/tSNE) 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) 13.13 Assigning cell type identity to clusters 13.14 Guardar Resultados 13.15 Detalles de la sesión de R Patrocinadores", " 13 Introducción a Seurat Instructor: Kevin E. Meza-Landeros 13.1 Diapositivas Presentación: aquí 13.2 Una perspectiva diferente Seurat es un paquete R diseñado para control de calidad, análisis y exploración de datos de secuencia de ARN de una sola célula. Seurat tiene como objetivo permitir a los usuarios identificar e interpretar fuentes de heterogeneidad a partir de mediciones transcriptómicas unicelulares e integrar diversos tipos de datos unicelulares. Seurat es desarrollado y mantenido por el laboratorio de Satija y se publica bajo la Licencia Pública GNU (GPL 3.0). En este tutorial se ve como procesar los datos de scRNAseq con un nuevo paquete. Los pasos a realizar son en esencia los mismos que ya revisamos con el tutorial de la OSCA de RStudio. No olvides nunca que el paquete mas adecuado y que deberás utilizar dependerá mayoritariamente de tus datos y el procesamiento que se adecúe a estos. Además… siempre es bueno diversos puntos de vista sobre las cosas, ¿no es así? Aprende mas sobre Seurat: aquí 13.3 Kick-start En este tutorial partimos a partir de que ya se tienen los archivos FASTQ resultados de secuenciación. ¿Con qué datos estoy trabajando? Peripheral Blood Mononuclear Cells (PBMC) disponibles gratuitamente de 10X Genomics. Son en total 2,700 céluas únicas secuenciadas con Illumina NextSeq 500. Puedes descargar los datos de aquí (7.3MB). Descarga el archivo comprimido y procede a descomprimirlo. Se creara el siguiente directorio filtered_gene_bc_matrices/hg19/, aquí estarán los archivos que necesitaremos. A continuación lo haremos con código de R. Este tutorial solo es la punta del iceberg de lo que se puede hacer con la paquetera de Seurat. Para comenzar a sumergirte en este mundo no dudes en visitar la página oficial mantenida por Satija Lab Vignettes A continuación estableceremos nuestros directorio de trabajo y leeremos los datos anteriores. La función Read10X() lee en la salida de cellranger de 10X (de donde se obtuvieron los FASTQs), devolviendo una matriz de recuento única identificada molecularmente (UMI). Los valores en esta matriz representan el número de moléculas para cada característica (es decir, gen; fila) que se detectan en cada celda (columna). ## Cargar paquetes de R library(&quot;BiocFileCache&quot;) ## para descargar datos library(&quot;dplyr&quot;) ## para filtar datos library(&quot;Seurat&quot;) ## paquete principal de este capítulo library(&quot;patchwork&quot;) ## para graficar imágenes juntas # Usemos datos de pbmc3k tal y como lo hacen en # https://satijalab.org/seurat/articles/pbmc3k_tutorial.html # pero con nuestro propio código bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&quot; )) ## adding rname &#39;http://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz&#39; untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc3k&quot;)) fname &lt;- file.path(tempdir(), &quot;pbmc3k/filtered_gene_bc_matrices/hg19&quot;) # Load the PBMC dataset pbmc.data &lt;- Read10X(data.dir = fname) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) Veamos la estructura del Objeto de Seurat str(pbmc) ## Formal class &#39;Seurat&#39; [package &quot;SeuratObject&quot;] with 13 slots ## ..@ assays :List of 1 ## .. ..$ RNA:Formal class &#39;Assay&#39; [package &quot;SeuratObject&quot;] with 8 slots ## .. .. .. ..@ counts :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ data :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2282976] 29 73 80 148 163 184 186 227 229 230 ... ## .. .. .. .. .. ..@ p : int [1:2701] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13714 2700 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13714] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## .. .. .. .. .. ..@ x : num [1:2282976] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ scale.data : num[0 , 0 ] ## .. .. .. ..@ key : chr &quot;rna_&quot; ## .. .. .. ..@ assay.orig : NULL ## .. .. .. ..@ var.features : logi(0) ## .. .. .. ..@ meta.features:&#39;data.frame&#39;: 13714 obs. of 0 variables ## .. .. .. ..@ misc : list() ## ..@ meta.data :&#39;data.frame&#39;: 2700 obs. of 3 variables: ## .. ..$ orig.ident : Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ nCount_RNA : num [1:2700] 2419 4903 3147 2639 980 ... ## .. ..$ nFeature_RNA: int [1:2700] 779 1352 1129 960 521 781 782 790 532 550 ... ## ..@ active.assay: chr &quot;RNA&quot; ## ..@ active.ident: Factor w/ 1 level &quot;pbmc3k&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:2700] &quot;AAACATACAACCAC-1&quot; &quot;AAACATTGAGCTAC-1&quot; &quot;AAACATTGATCAGC-1&quot; &quot;AAACCGTGCTTCCG-1&quot; ... ## ..@ graphs : list() ## ..@ neighbors : list() ## ..@ reductions : list() ## ..@ images : list() ## ..@ project.name: chr &quot;pbmc3k&quot; ## ..@ misc : list() ## ..@ version :Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. ..$ : int [1:3] 4 0 2 ## ..@ commands : list() ## ..@ tools : list() ¿Cómo se ven los datos en una matriz de recuento? Examinemos algunos genes en las primeras treinta células. Los valores en la matriz representan ceros (no se detectan moléculas). Dado que la mayoría de los valores en una matriz scRNA-seq son 0, Seurat utiliza una representación de matriz dispersa (sparse matrix) siempre que sea posible. Esto da como resultado un ahorro significativo de memoria y velocidad. pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . dense.size &lt;- object.size(as.matrix(pbmc.data)) dense.size ## 709591472 bytes sparse.size &lt;- object.size(pbmc.data) sparse.size ## 29905192 bytes dense.size / sparse.size ## 23.7 bytes ¡EN ESTE CASO UNA MATRIZ NO DISPERSA OCUPA ~ 24 VECES MAS ESPACIO! 13.4 Quality Control Algunas métricas de control de calidad comúnmente utilizadas por la comunidad incluyen: El número de genes únicos detectados en cada célula. Las células de baja calidad o las gotitas vacías suelen tener muy pocos genes. Los dobletes o multipletes celulares pueden exhibir un recuento de genes aberrantemente alto De manera similar, el número total de moléculas detectadas dentro de una célula (se correlaciona fuertemente con genes únicos) El porcentaje de lecturas que se asignan al genoma mitocondrial Las células de baja calidad / moribundas a menudo exhiben una extensa contaminación mitocondrial Calculamos métricas de control de calidad mitocondrial con la función PercentageFeatureSet(), que calcula el porcentaje de recuentos que se originan a partir de un conjunto de características. El operador [[ puede agregar columnas a los metadatos del objeto. Este es un gran lugar para almacenar estadísticas de control de calidad. Entonces calculamos y añadimos la cantidad de lecturas que corresponden al genoma mitocondrial. pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) Visualizamos las métricas de control de calidad mencionadas anteriormente como un diagrama de violín. Ademas vemos la correlación entre el numero de moléculas de RNA detectadas en cada célula con el número de genes únicos y con el porcentaje de lecturas que corresponden a mtADN. VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 Finalmente filtramos aquellas células que se salen de los estándares de cada uno de los parámetros. # Filter pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) ¿Dónde se almacenan la métricas de QC en Seurat? Están almacenadas en la seccion de meta-data del objeto Seurat. head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 13.5 Normalización De forma predeterminada, se emplea un método de normalización de escala global “LogNormalize” que normaliza las medidas de expresión de características para cada celda por la expresión total, multiplica esto por un factor de escala (10.000 por defecto) y transforma el resultado en logaritmos. Los valores normalizados se almacenan en pbmc [[\"RNA\"]]@data. pbmc &lt;- NormalizeData(pbmc, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) 13.6 Detección de genes (caractersticas) altamente variables A continuación, calculamos un subconjunto de características que exhiben una alta variación de célula a célula en el conjunto de datos (es decir, están altamente expresadas en algunas células y poco expresadas en otras). El equipo de Seurat y otros equipos han descubierto que centrarse en estos genes en el análisis posterior ayuda a resaltar la señal biológica en conjuntos de datos unicelulares. Nuestro procedimiento en Seurat se describe en detalle aquí y mejora las versiones anteriores al modelar directamente la relación de varianza media inherente a los datos de una sola celda, y se implementa en la función FindVariableFeatures(). De forma predeterminada, devolvemos 2000 características por conjunto de datos (aunque se puede modificar). Estos se utilizarán en análisis posteriores, como PCA. pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) top10 ## [1] &quot;PPBP&quot; &quot;LYZ&quot; &quot;S100A9&quot; &quot;IGLL5&quot; &quot;GNLY&quot; &quot;FTL&quot; &quot;PF4&quot; &quot;FTH1&quot; ## [9] &quot;GNG11&quot; &quot;S100A8&quot; # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results plot1 + plot2 ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Removed 1 rows containing missing values (geom_point). 13.7 Escalar los datos A continuación, aplicamos una transformación lineal (“escalado”) que es un paso de preprocesamiento estándar antes de las técnicas de reducción dimensional como PCA. La función ScaleData(): Cambia la expresión de cada gen, de modo que la expresión media en las células sea 0 Escala la expresión de cada gen, de modo que la varianza entre las células sea 1 Este paso otorga el mismo peso en los análisis posteriores, de modo que los genes altamente expresados no dominen Los resultados de esto se almacenan en pbmc [[\"RNA\"]]@scale.data. all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes) ## Centering and scaling data matrix 13.8 Reducción dimensional lineal A continuación, realizamos PCA sobre los datos escalados. De forma predeterminada, solo las características variables determinadas previamente se utilizan como entrada, pero se pueden definir mediante el argumento de características si desea elegir un subconjunto diferente. pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL, FTH1, LYZ, FCN1, S100A9, TYMP ## FCER1G, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, IFITM3, SPI1, CFP ## PSAP, IFI30, SAT1, COTL1, S100A11, NPC2, GRN, LGALS3, GSTP1, PYCARD ## Negative: MALAT1, LTB, IL32, IL7R, CD2, B2M, ACAP1, CD27, STK17A, CTSW ## CD247, GIMAP5, AQP3, CCL5, SELL, TRAF3IP3, GZMA, MAL, CST7, ITM2A ## MYC, GIMAP7, HOPX, BEX2, LDLRAP1, GZMK, ETS1, ZAP70, TNFAIP8, RIC3 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1, HLA-DRA, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DMA, HLA-DPB1, HLA-DQA2, CD37, HLA-DRB5, HLA-DMB, HLA-DPA1, FCRLA, HVCN1, LTB ## BLNK, P2RX5, IGLL5, IRF8, SWAP70, ARHGAP24, FCGR2B, SMIM14, PPP1R14A, C16orf74 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA, FGFBP2, CTSW, GNLY, B2M, SPON2 ## CCL4, GZMH, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX ## TTC38, APMAP, CTSC, S100A4, IGFBP7, ANXA1, ID2, IL32, XCL1, RHOC ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, HLA-DPA1, CD74, MS4A1, HLA-DRB1, HLA-DRA ## HLA-DRB5, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, CD37, HVCN1, FCRLA, IRF8 ## PLAC8, BLNK, MALAT1, SMIM14, PLD4, P2RX5, IGLL5, LAT2, SWAP70, FCGR2B ## Negative: PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU ## HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, PTCRA, CA2, ACRBP, MMD, TREML1 ## NGFRAP1, F13A1, SEPT5, RUFY1, TSC22D1, MPP1, CMTM5, RP11-367G6.3, MYL9, GP1BA ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1, CD74, HIST1H2AC, HLA-DPB1, PF4, SDPR ## TCL1A, HLA-DRB1, HLA-DPA1, HLA-DQA2, PPBP, HLA-DRA, LINC00926, GNG11, SPARC, HLA-DRB5 ## GP9, AP001189.4, CA2, PTCRA, CD9, NRGN, RGS18, CLU, TUBB1, GZMB ## Negative: VIM, IL7R, S100A6, IL32, S100A8, S100A4, GIMAP7, S100A10, S100A9, MAL ## AQP3, CD2, CD14, FYB, LGALS2, GIMAP4, ANXA1, CD27, FCN1, RBP7 ## LYZ, S100A11, GIMAP5, MS4A6A, S100A12, FOLR3, TRABD2A, AIF1, IL8, IFI6 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY, CCL4, CST7, PRF1, GZMA, SPON2 ## GZMH, S100A9, LGALS2, CCL3, CTSW, XCL2, CD14, CLIC3, S100A12, RBP7 ## CCL5, MS4A6A, GSTP1, FOLR3, IGFBP7, TYROBP, TTC38, AKR1C3, XCL1, HOPX ## Negative: LTB, IL7R, CKB, VIM, MS4A7, AQP3, CYTIP, RP11-290F20.3, SIGLEC10, HMOX1 ## LILRB2, PTGES3, MAL, CD27, HN1, CD2, GDI2, CORO1B, ANXA5, TUBA1B ## FAM110A, ATP1A1, TRADD, PPA1, CCDC109B, ABRACL, CTD-2006K23.1, WARS, VMO1, FYB Seurat proporciona varias formas útiles de visualizar tanto las celdas como las características que definen el PCA, incluidas VizDimReduction(), DimPlot() y DimHeatmap(). Puedes examinar y visualizar los resultados de PCA de diferentes formas. print(pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) En particular, DimHeatmap() permite una fácil exploración de las fuentes primarias de heterogeneidad en un conjunto de datos y puede ser útil cuando se intenta decidir qué PC incluir para análisis posteriores posteriores. Tanto las celdas como las características se ordenan de acuerdo con sus puntajes de PCA. Establecer celdas en un número traza las celdas “extremas” en ambos extremos del espectro, lo que acelera drásticamente el trazado de grandes conjuntos de datos. Aunque claramente es un análisis supervisado, consideramos que esta es una herramienta valiosa para explorar conjuntos de características correlacionadas. DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) 13.9 Determinar la dimensionalidad del conjunto de datos Para superar el extenso ruido técnico en cualquier característica única para los datos de scRNA-seq, Seurat agrupa las células en función de sus puntuaciones de PCA, y cada PC representa esencialmente una “metafunción” que combina información en un conjunto de características correlacionadas. Por lo tanto, los componentes principales principales representan una compresión sólida del conjunto de datos. Sin embargo, ¿cuántos componentes deberíamos elegir incluir? 10? 20? 100? En Macosko et al, implementamos una prueba de remuestreo inspirada en el procedimiento JackStraw. Permutamos aleatoriamente un subconjunto de los datos (1% por defecto) y volvemos a ejecutar PCA, construyendo una “distribución nula” de puntuaciones de características, y repetimos este procedimiento. Identificamos PC “importantes” como aquellas que tienen un gran enriquecimiento de características de bajo valor p.  # NOTE: This process can take a long time for big datasets, comment out for expediency. More # approximate techniques such as those implemented in ElbowPlot() can be used to reduce # computation time pbmc &lt;- JackStraw(pbmc, num.replicate = 100) pbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20) La función JackStrawPlot() proporciona una herramienta de visualización para comparar la distribución de los valores p para cada PC con una distribución uniforme (línea discontinua). Las PC “significativas” mostrarán un gran enriquecimiento de funciones con valores p bajos (curva sólida por encima de la línea discontinua). En este caso, parece que hay una fuerte caída en la importancia después de los primeros 10-12 PCs. JackStrawPlot(pbmc, dims = 1:15) ## Warning: Removed 23510 rows containing missing values (geom_point). Un método heurístico alternativo genera un “diagrama de codo (Elbow Plot)”: una clasificación de componentes principales basada en el porcentaje de varianza explicada por cada uno (función ElbowPlot()). En este ejemplo, podemos observar un “codo” alrededor de PC9-10, lo que sugiere que la mayor parte de la señal verdadera se captura en las primeras 10 PC. ElbowPlot(pbmc) 13.10 Clustering pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) ## Computing nearest neighbor graph ## Computing SNN pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds 13.11 Reducción dimensional no lineal (UMAP/tSNE) Seurat ofrece varias técnicas de reducción dimensional no lineal, como tSNE y UMAP, para visualizar y explorar estos conjuntos de datos. El objetivo de estos algoritmos es aprender la variedad subyacente de los datos para colocar celdas similares juntas en un espacio de baja dimensión. Las celdas dentro de los grupos basados en gráficos determinados anteriormente deben ubicarse conjuntamente en estos gráficos de reducción de dimensión. Como entrada para UMAP y tSNE, sugerimos usar las mismas PC como entrada para el análisis de agrupamiento. # If you haven&#39;t installed UMAP, you can do so via reticulate::py_install(packages = &#39;umap-learn&#39;) pbmc &lt;- RunUMAP(pbmc, dims = 1:10) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 22:35:53 UMAP embedding parameters a = 0.9922 b = 1.112 ## 22:35:53 Read 2638 rows and found 10 numeric columns ## 22:35:53 Using Annoy for neighbor search, n_neighbors = 30 ## 22:35:53 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 22:35:53 Writing NN index file to temp file /tmp/Rtmp3QGO76/file7555c5a6153 ## 22:35:53 Searching Annoy index using 1 thread, search_k = 3000 ## 22:35:54 Annoy recall = 100% ## 22:35:54 Commencing smooth kNN distance calibration using 1 thread ## 22:35:55 Initializing from normalized Laplacian + noise ## 22:35:55 Commencing optimization for 500 epochs, with 105140 positive edges ## 22:35:59 Optimization finished # Note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(pbmc, reduction = &quot;umap&quot;) Puede guardar el objeto en este punto para que se pueda volver a cargar fácilmente sin tener que volver a ejecutar los pasos computacionalmente intensivos realizados anteriormente o compartir fácilmente con los colaboradores. if (interactive()) { saveRDS(pbmc, file = &quot;pbmc_tutorial.rds&quot;) } 13.12 Caracteristicas diferencialmente expresadas (biomarcadores de los clusters) Seurat puede ayudarlo a encontrar marcadores que definan clústeres mediante expresión diferencial. De forma predeterminada, identifica marcadores positivos y negativos de un solo grupo (especificado en ident.1), en comparación con todas las demás células. FindAllMarkers() automatiza este proceso para todos los clústeres, pero también se pueden comparar grupos de clústeres entre sí o contra todas las celdas. El argumento min.pct requiere que se detecte una característica en un porcentaje mínimo en cualquiera de los dos grupos de celdas, y el argumento thresh.test requiere que una característica se exprese diferencialmente (en promedio) en alguna cantidad entre los dos grupos. Puede establecer ambos en 0, pero con un aumento dramático en el tiempo, ya que esto probará una gran cantidad de características que probablemente no sean altamente discriminatorias. Como otra opción para acelerar estos cálculos, se puede configurar el número máximo de celdas por identificador. Esto reducirá la resolución de cada clase de identidad para que no tenga más celdas que las que se establezcan. Si bien generalmente habrá una pérdida de potencia, los aumentos de velocidad pueden ser significativos y es probable que las características expresadas de manera más diferencial aún se eleven a la cima. # find all markers of cluster 2 cluster2.markers &lt;- FindMarkers(pbmc, ident.1 = 2, min.pct = 0.25) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.892340e-90 1.2013522 0.947 0.465 3.966555e-86 ## LTB 1.060121e-86 1.2695776 0.981 0.643 1.453850e-82 ## CD3D 8.794641e-71 0.9389621 0.922 0.432 1.206097e-66 ## IL7R 3.516098e-68 1.1873213 0.750 0.326 4.821977e-64 ## LDHB 1.642480e-67 0.8969774 0.954 0.614 2.252497e-63 # find all markers distinguishing cluster 5 from clusters 0 and 3 cluster5.markers &lt;- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 8.246578e-205 4.261495 0.975 0.040 1.130936e-200 ## IFITM3 1.677613e-195 3.879339 0.975 0.049 2.300678e-191 ## CFD 2.401156e-193 3.405492 0.938 0.038 3.292945e-189 ## CD68 2.900384e-191 3.020484 0.926 0.035 3.977587e-187 ## RP11-290F20.3 2.513244e-186 2.720057 0.840 0.017 3.446663e-182 # find markers for every cluster compared to all remaining cells, report only the positive # ones pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) ## Registered S3 method overwritten by &#39;cli&#39;: ## method from ## print.boxx spatstat.geom ## # A tibble: 18 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.09 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 1.36 0.447 0.108 1.31e- 83 0 CCR7 ## 3 0 5.57 0.996 0.215 0 1 S100A9 ## 4 0 5.48 0.975 0.121 0 1 S100A8 ## 5 1.06e- 86 1.27 0.981 0.643 1.45e- 82 2 LTB ## 6 2.97e- 58 1.23 0.42 0.111 4.07e- 54 2 AQP3 ## 7 0 4.31 0.936 0.041 0 3 CD79A ## 8 9.48e-271 3.59 0.622 0.022 1.30e-266 3 TCL1A ## 9 5.61e-202 3.10 0.983 0.234 7.70e-198 4 CCL5 ## 10 7.25e-165 3.00 0.577 0.055 9.95e-161 4 GZMK ## 11 3.51e-184 3.31 0.975 0.134 4.82e-180 5 FCGR3A ## 12 2.03e-125 3.09 1 0.315 2.78e-121 5 LST1 ## 13 7.95e-269 4.83 0.961 0.068 1.09e-264 6 GZMB ## 14 3.13e-191 5.32 0.961 0.131 4.30e-187 6 GNLY ## 15 1.48e-220 3.87 0.812 0.011 2.03e-216 7 FCER1A ## 16 1.67e- 21 2.87 1 0.513 2.28e- 17 7 HLA-DPB1 ## 17 9.25e-186 7.29 1 0.011 1.27e-181 8 PF4 ## 18 1.92e-102 8.59 1 0.024 2.63e- 98 8 PPBP Seurat tiene varias pruebas de expresión diferencial que se pueden configurar con el parámetro test.use (consulte nuestra viñeta DE para obtener más detalles). Por ejemplo, la prueba ROC devuelve el “poder de clasificación” para cualquier marcador individual (que varía de 0 - aleatorio a 1 - perfecto) . cluster0.markers &lt;- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) Se incluyen varias herramientas para visualizar la expresión de los marcadores. VlnPlot() (muestra distribuciones de probabilidad de expresión entre clústeres) y FeaturePlot() (visualiza la expresión de características en un gráfico tSNE o PCA) son nuestras visualizaciones más utilizadas. También sugerimos explorar RidgePlot(), CellScatter() y DotPlot() como métodos adicionales para ver su conjunto de datos. VlnPlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) ## you can plot raw counts as well VlnPlot(pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) FeaturePlot(pbmc, features = c( &quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot; )) # DoHeatmap() generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster. pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) -&gt; top10 DoHeatmap(pbmc, features = top10$gene) + NoLegend() 13.13 Assigning cell type identity to clusters Podemos usar marcadores canónicos para hacer coincidir fácilmente la agrupación imparcial con los tipos de células conocidos. new.cluster.ids &lt;- c( &quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot; ) names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() 13.14 Guardar Resultados if (interactive()) { saveRDS(pbmc, file = &quot;pbmc3k_final.rds&quot;) } 13.15 Detalles de la sesión de R ## Información de la sesión de R Sys.time() ## [1] &quot;2021-08-09 22:36:37 UTC&quot; proc.time() ## user system elapsed ## 181.969 11.268 129.370 options(width = 120) sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-09 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## BiocFileCache * 2.0.0 2021-05-19 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr * 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## dplyr * 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.7.0 2021-01-04 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.2 2021-08-08 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork * 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.10 2021-08-06 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat * 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject * 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## survival 3.2-11 2021-04-26 [3] CRAN (R 4.1.0) ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.25 2021-08-06 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Patrocinadores Agradecemos a nuestros patrocinadores: "]]
