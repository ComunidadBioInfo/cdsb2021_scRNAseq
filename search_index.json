[["index.html", "Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Información del taller Formato del curso: en línea ¿Quién es nuestra audiencia? Formulario de registro Instructores Ponentes e instructores invitados Ayudantes Temario Código de Conducta Pre-requisitos Horario Materiales Zoom Organizadores Patrocinadores Información sesión de R Licencia", " Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor Leonardo Collado-Torres Lieber Institute for Brain Development, Johns Hopkins Medical Campus Información del taller 9-13 de agosto de 2021 ¡Bienvenidxs al taller Análisis de datos transcriptómicos de célula única (scRNA-seq) con R y Bioconductor! En los últimos años, la generación y análisis de transcriptomas de célula única ha cobrado gran importancia para resolver preguntas biológicas. En este taller revisaremos los métodos más recientes para analizar datos de single cell RNA-seq (transcriptómica en células únicas), usando paquetes de R especializados que están disponibles libremente vía Bioconductor. Este taller estará basado en el libro Orchestrating Single Cell Analysis with Bioconductor que fue publicado en Nature Methods y es de los artículos con mayor publicidad en 2020 y 2021. Durante este taller aprenderás las herramientas estadísticas para analizar datos de transcriptómica en células únicas usando Bioconductor. Revisaremos qué es un análisis de datos de célula única, cuáles son las principales diferencias entre el análisis de transcriptomas de célula única y en bulk, cómo documentar tu análisis y algunas herramientas para interpretar tus resultados. Formato del curso: en línea Este es un curso digital. Las sesiones y material del curso serán presentados en línea. Esta modalidad incluirá grabaciones de video o audio del material, intercambio de archivos y sesiones de discusión temáticos, ejercicios de auto-evaluación y acceso a los instructores para comentarios durante el curso. ¿Quién es nuestra audiencia? Este curso está dirigido a personas que desean aprender cómo analizar datos transcriptómicos de célula única usando paquetes de R/Bioconductor. Revisa los videos de CDSB2020 en YouTube o la página web de cdsb2020, que es similar al taller de este año. Formulario de registro http://congresos.nnb.unam.mx/EBM2021/ Do you want to learn how to analyze #scRNAseq with @Bioconductor?Learn with @lcolladotor@yalbi_ibm @AnaBetty2304 @argininaa @naielisha @lawrah20 @roramirezf94 @jvelezmagic @KevsGenomic @mpadilla905Material adapted from OSCA @PeteHaitch et al#rstatshttps://t.co/MIfFmKt3Fq pic.twitter.com/nSPCmVEPAC — ComunidadBioInfo (@CDSBMexico) July 2, 2021 Instructores Leonardo Collado-Torres Yalbi Balderas Ponentes e instructores invitados Ana Beatriz Villaseñor Altamirano Citlali Gil Aguillon Elisa Márquez Zavala Laura Lucila Gómez Romero Ricardo Ramirez Flores Ayudantes Jesús Vélez Santiago Kevin Emmanuel Meza Landeros Mónica Padilla Gálvez Temario Día 1 Introducción a R y RStudio Ejercicio usando usethis, here y postcards Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Día 2 Estructura e importe de datos Comunidades RLadies Control de calidad Día 3 Normalización de datos Foto y actividades de la comunidad Selección de genes Día 4 Reducción de dimensiones Clustering Identificación de genes marcadores Día 5 Anotación de clusters de células Análisis de expresión diferencial Plática científica del ponente invitadx Código de Conducta Seguiremos el código de conducta de la CDSB México comunidadbioinfo.github.io/es/codigo-de-conducta/ además del código de conducta de Bioconductor bioconductor.org/about/code-of-conduct/. Pre-requisitos De forma general, Computadora con al menos 8Gb de memoria y permisos de administrador para instalar paqueterías de R. Tener instalado R y RStudio en su última versión. Conocimientos básicos de secuenciación de transcriptomas. Conocimientos básicos de RStudio (Creación de Rscripts, manejo de la consola de RStudio, manejo del espacio de visualización). Conocimiento intermedio de R (Manejo de variables, lectura de archivos, creación y manejo de data frames y listas, generación de gráficas básicas, conocimiento sobre cómo instalar paqueterías desde CRAN y Bioconductor). Más específicamente, computadora con al menos 8 GB de memoria RAM, aplicación Zoom https://zoom.us/download, R versión 4.1 instalada de CRAN https://cran.r-project.org/ (ver video de https://youtu.be/6knyHlUe1cM sobre como instalar R en macOS o winOS), RStudio versión 1.4 https://www.rstudio.com/products/rstudio/download/#download, y los siguientes paquetes de R y Bioconductor: ## Para instalar paquetes if (!requireNamespace(&quot;remotes&quot;, quietly = TRUE)) { install.packages(&quot;remotes&quot;) } ## Para instalar paquetes de Bioconductor remotes::install_cran(&quot;BiocManager&quot;) BiocManager::version() # El anterior comando debe mostrar que estás usando la versión 3.13 ## Instala los paquetes de R que necesitamos ## BiocManager::install(&quot;AnnotationHub&quot;, &quot;batchelor&quot;, &quot;BiocFileCache&quot;, &quot;BiocSingular&quot;, &quot;bluster&quot;, &quot;cowplot&quot;, &quot;dplyr&quot;, &quot;DropletUtils&quot;, &quot;EnsDb.Hsapiens.v86&quot;, &quot;ExperimentHub&quot;, &quot;fossil&quot;, &quot;here&quot;, &quot;iSEE&quot;, &quot;org.Mm.eg.db&quot;, &quot;patchwork&quot;, &quot;PCAtools&quot;, &quot;pheatmap&quot;, &quot;plotly&quot;, &quot;pryr&quot;, &quot;RColorBrewer&quot;, &quot;Rtsne&quot;, &quot;scater&quot;, &quot;scPipe&quot;, &quot;scran&quot;, &quot;scRNAseq&quot;, &quot;sessioninfo&quot;, &quot;Seurat&quot;, &quot;SingleCellExperiment&quot;, &quot;TENxPBMCData&quot;, &quot;usethis&quot;, &quot;uwot&quot;) Horario Consulta el calendario de este curso en: http://bit.ly/calendarcdsb2021. Horario Tema Instructores Día 1: Agosto 9, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-09:30 Inauguración EBM2021 Julio Collado Vides, Christian Sohlenkamp, Irma Martínez Flores, Shirley Alquicira Hernández 09:30-10:00 Bienvenida a la CDSB y revisión del código de conducta Leonardo Collado-Torres 10:00-11:00 Introducción a R y RStudio Leonardo Collado-Torres 11:00-11:30 Descanso 11:30-14:00 Ejercicio usando usethis, here y postcards Citlali Gil Aguillon y Elisa Márquez Zavala 14:00-15:30 Descanso: comida 15:30-17:00 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Citlali Gil Aguillon y Elisa Márquez Zavala 17:00-18:00 (Invitada) Principios FAIR para software de investigación Paula Andrea Día 2: Agosto 10, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Estructura e importe de datos Citlali Gil Aguillon y Elisa Márquez Zavala 11:00-11:30 Descanso 11:30-12:00 Keynote: La comunidad R-Ladies Ana Beatriz Villaseñor Altamirano 12:00-14:00 Control de calidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Control de calidad Leonardo Collado-Torres 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 3: Agosto 11, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Normalización de datos Ana Beatriz Villaseñor Altamirano 10:30-11:00 Foto 11:00-11:30 Descanso 11:30-12:30 Selección de genes Yalbi Balderas 12:30-14:00 Actividades para construir la comunidad Leonardo Collado-Torres 14:00-15:30 Descanso: comida 15:30-17:30 Selección de genes Laura Lucila Gómez Romero 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Día 4: Agosto 12, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-11:00 Reducción de dimensiones Laura Lucila Gómez Romero 11:00-11:30 Descanso 11:30-14:00 Clustering Laura Lucila Gómez Romero 14:00-15:30 Descanso: comida 15:30-17:30 Identificación de genes marcadores Yalbi Balderas 17:30-18:30 CDSB 2021: Evento social remoto Día 5: Agosto 13, 2021 08:00-09:00 (opcional) Ayuda con instalación de paquetes de R 09:00-10:30 Anotación de clusters de células Yalbi Balderas 10:30-11:00 Evaluación del taller Irma Martínez Flores y Shirley Alquicira Hernández 11:00-11:30 Descanso 11:30-12:30 Análisis de expresión diferencial Leonardo Collado-Torres 12:30-14:00 Introducción a Seurat Kevin Emmanuel Meza Landeros 14:00-15:30 Descanso: comida 15:30-17:00 Plática científica y sesión de preguntas Ricardo Ramirez Flores 17:00-17:30 Clausura y recordatorio de la CDSB 17:30-18:00 (opcional) Interactúa con lxs instructores y ayudantes Materiales Descarga los materiales con usethis::use_course('comunidadbioinfo/cdsb2021_scRNAseq') o revisalos en línea vía comunidadbioinfo.github.io/cdsb2021_scRNAseq. Zoom Las ligas de Zoom están disponibles exclusivamente para lxs participantes de CDSB2021 vía Slack. Te enviaremos una invitación al correo electrónico que usaste para registrate. Organizadores Comunidad de Desarrolladores de Software en Bioinformática CDSB Red Mexicana de Bioinformática RMB Nodo Nacional de Bioinformática en la UNAM NNB-CCG Patrocinadores Agradecemos a nuestros patrocinadores: Información sesión de R Detalles de la sesión de R usada para crear este libro. El código fuente está disponible vía ComunidadBioInfo/cdsb2021_scRNAseq. options(width = 120) pkgs &lt;- installed.packages()[, &quot;Package&quot;] sessioninfo::session_info(pkgs, include_base = TRUE) ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.0 (2021-05-18) ## os Ubuntu 20.04.2 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2021-08-08 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.1.0) ## AnnotationDbi 1.54.1 2021-06-08 [1] Bioconductor ## AnnotationFilter 1.16.0 2021-05-19 [1] Bioconductor ## AnnotationHub 3.0.1 2021-06-20 [1] Bioconductor ## AnVIL 1.4.1 2021-06-22 [2] Bioconductor ## askpass 1.1 2019-01-13 [2] RSPM (R 4.1.0) ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.1.0) ## base * 4.1.0 2021-07-29 [3] local ## base64enc 0.1-3 2015-07-28 [1] RSPM (R 4.1.0) ## batchelor 1.8.0 2021-05-19 [1] Bioconductor ## beachmat 2.8.0 2021-05-19 [1] Bioconductor ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.1.0) ## BH 1.75.0-0 2021-01-11 [1] RSPM (R 4.1.0) ## Biobase 2.52.0 2021-05-19 [1] Bioconductor ## BiocFileCache 2.0.0 2021-05-19 [1] Bioconductor ## BiocGenerics 0.38.0 2021-05-19 [1] Bioconductor ## BiocIO 1.2.0 2021-05-19 [1] Bioconductor ## BiocManager 1.30.16 2021-06-15 [1] RSPM (R 4.1.0) ## BiocNeighbors 1.10.0 2021-05-19 [1] Bioconductor ## BiocParallel 1.26.1 2021-07-04 [1] Bioconductor ## BiocSingular 1.8.1 2021-06-08 [1] Bioconductor ## BiocStyle 2.20.2 2021-06-17 [1] Bioconductor ## BiocVersion 3.13.1 2021-03-19 [2] Bioconductor ## biomaRt 2.48.2 2021-07-01 [1] Bioconductor ## Biostrings 2.60.2 2021-08-05 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] RSPM (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.1.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.1.0) ## blob 1.2.2 2021-07-23 [1] RSPM (R 4.1.0) ## bluster 1.2.1 2021-05-27 [1] Bioconductor ## bookdown 0.22 2021-04-22 [1] RSPM (R 4.1.0) ## boot 1.3-28 2021-05-03 [3] CRAN (R 4.1.0) ## brew 1.0-6 2011-04-13 [2] RSPM (R 4.1.0) ## brio 1.1.2 2021-04-23 [2] RSPM (R 4.1.0) ## bslib 0.2.5.1 2021-05-18 [1] RSPM (R 4.1.0) ## cachem 1.0.5 2021-05-15 [2] RSPM (R 4.1.0) ## Cairo 1.5-12.2 2020-07-07 [1] RSPM (R 4.1.0) ## callr 3.7.0 2021-04-20 [2] RSPM (R 4.1.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.1.0) ## cdsb2021scRNAseq 0.99.0 2021-08-08 [1] local ## circlize 0.4.13 2021-06-09 [1] RSPM (R 4.1.0) ## class 7.3-19 2021-05-03 [3] CRAN (R 4.1.0) ## cli 3.0.1 2021-07-17 [2] RSPM (R 4.1.0) ## clipr 0.7.1 2020-10-08 [2] RSPM (R 4.1.0) ## clue 0.3-59 2021-04-16 [1] RSPM (R 4.1.0) ## cluster 2.1.2 2021-04-17 [3] CRAN (R 4.1.0) ## codetools 0.2-18 2020-11-04 [3] CRAN (R 4.1.0) ## colorspace 2.0-2 2021-06-24 [1] RSPM (R 4.1.0) ## colourpicker 1.1.0 2020-09-14 [1] RSPM (R 4.1.0) ## commonmark 1.7 2018-12-01 [2] RSPM (R 4.1.0) ## compiler 4.1.0 2021-07-29 [3] local ## ComplexHeatmap 2.8.0 2021-05-19 [1] Bioconductor ## cowplot 1.1.1 2020-12-30 [1] RSPM (R 4.1.0) ## cpp11 0.3.1 2021-06-25 [1] RSPM (R 4.1.0) ## crayon 1.4.1 2021-02-08 [2] RSPM (R 4.1.0) ## credentials 1.3.1 2021-07-25 [2] RSPM (R 4.1.0) ## crosstalk 1.1.1 2021-01-12 [1] RSPM (R 4.1.0) ## curl 4.3.2 2021-06-23 [2] RSPM (R 4.1.0) ## data.table 1.14.0 2021-02-21 [1] RSPM (R 4.1.0) ## datasets * 4.1.0 2021-07-29 [3] local ## DBI 1.1.1 2021-01-15 [1] RSPM (R 4.1.0) ## dbplyr 2.1.1 2021-04-06 [1] RSPM (R 4.1.0) ## DelayedArray 0.18.0 2021-05-19 [1] Bioconductor ## DelayedMatrixStats 1.14.1 2021-08-05 [1] Bioconductor ## deldir 0.2-10 2021-02-16 [1] RSPM (R 4.1.0) ## DEoptimR 1.0-9 2021-05-24 [1] RSPM (R 4.1.0) ## desc 1.3.0 2021-03-05 [2] RSPM (R 4.1.0) ## devtools 2.4.2 2021-06-07 [2] RSPM (R 4.1.0) ## diffobj 0.3.4 2021-03-22 [2] RSPM (R 4.1.0) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.1.0) ## docopt 0.7.1 2020-06-24 [2] RSPM (R 4.1.0) ## doParallel 1.0.16 2020-10-16 [1] RSPM (R 4.1.0) ## dplyr 1.0.7 2021-06-18 [1] RSPM (R 4.1.0) ## dqrng 0.3.0 2021-05-01 [1] RSPM (R 4.1.0) ## DropletUtils 1.12.2 2021-07-22 [1] Bioconductor ## DT 0.18 2021-04-14 [1] RSPM (R 4.1.0) ## edgeR 3.34.0 2021-05-19 [1] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] RSPM (R 4.1.0) ## EnsDb.Hsapiens.v86 2.99.0 2021-07-29 [1] Bioconductor ## ensembldb 2.16.4 2021-08-05 [1] Bioconductor ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.1.0) ## ExperimentHub 2.0.0 2021-05-19 [1] Bioconductor ## fansi 0.5.0 2021-05-25 [2] RSPM (R 4.1.0) ## farver 2.1.0 2021-02-28 [1] RSPM (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [2] RSPM (R 4.1.0) ## filelock 1.0.2 2018-10-05 [1] RSPM (R 4.1.0) ## fitdistrplus 1.1-5 2021-05-28 [1] RSPM (R 4.1.0) ## FNN 1.1.3 2019-02-15 [1] RSPM (R 4.1.0) ## forcats 0.5.1 2021-01-27 [1] RSPM (R 4.1.0) ## foreach 1.5.1 2020-10-15 [1] RSPM (R 4.1.0) ## foreign 0.8-81 2020-12-22 [3] CRAN (R 4.1.0) ## formatR 1.11 2021-06-01 [1] RSPM (R 4.1.0) ## fossil 0.4.0 2020-03-23 [1] RSPM (R 4.1.0) ## fs 1.5.0 2020-07-31 [2] RSPM (R 4.1.0) ## futile.logger 1.4.3 2016-07-10 [1] RSPM (R 4.1.0) ## futile.options 1.0.1 2018-04-20 [1] RSPM (R 4.1.0) ## future 1.21.0 2020-12-10 [1] RSPM (R 4.1.0) ## future.apply 1.7.0 2021-01-04 [1] RSPM (R 4.1.0) ## generics 0.1.0 2020-10-31 [1] RSPM (R 4.1.0) ## GenomeInfoDb 1.28.1 2021-07-01 [1] Bioconductor ## GenomeInfoDbData 1.2.6 2021-07-29 [1] Bioconductor ## GenomicAlignments 1.28.0 2021-05-19 [1] Bioconductor ## GenomicFeatures 1.44.0 2021-05-19 [1] Bioconductor ## GenomicRanges 1.44.0 2021-05-19 [1] Bioconductor ## gert 1.3.1 2021-06-23 [2] RSPM (R 4.1.0) ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.1.0) ## GGally 2.1.2 2021-06-21 [1] RSPM (R 4.1.0) ## ggbeeswarm 0.6.0 2017-08-07 [1] RSPM (R 4.1.0) ## ggplot2 3.3.5 2021-06-25 [1] RSPM (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] RSPM (R 4.1.0) ## ggridges 0.5.3 2021-01-08 [1] RSPM (R 4.1.0) ## gh 1.3.0 2021-04-30 [2] RSPM (R 4.1.0) ## gitcreds 0.1.1 2020-12-04 [2] RSPM (R 4.1.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.1.0) ## globals 0.14.0 2020-11-22 [1] RSPM (R 4.1.0) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.1.0) ## goftest 1.2-2 2019-12-02 [1] RSPM (R 4.1.0) ## gplots 3.1.1 2020-11-28 [1] RSPM (R 4.1.0) ## graphics * 4.1.0 2021-07-29 [3] local ## grDevices * 4.1.0 2021-07-29 [3] local ## grid 4.1.0 2021-07-29 [3] local ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.1.0) ## gtable 0.3.0 2019-03-25 [1] RSPM (R 4.1.0) ## gtools 3.9.2 2021-06-06 [1] RSPM (R 4.1.0) ## hash 2.2.6.1 2019-03-04 [1] RSPM (R 4.1.0) ## HDF5Array 1.20.0 2021-05-19 [1] Bioconductor ## here 1.0.1 2020-12-13 [1] RSPM (R 4.1.0) ## highr 0.9 2021-04-16 [2] RSPM (R 4.1.0) ## hms 1.1.0 2021-05-17 [1] RSPM (R 4.1.0) ## htmltools 0.5.1.1 2021-01-22 [1] RSPM (R 4.1.0) ## htmlwidgets 1.5.3 2020-12-10 [1] RSPM (R 4.1.0) ## httpuv 1.6.1 2021-05-07 [1] RSPM (R 4.1.0) ## httr 1.4.2 2020-07-20 [2] RSPM (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] RSPM (R 4.1.0) ## igraph 1.2.6 2020-10-06 [1] RSPM (R 4.1.0) ## ini 0.3.1 2018-05-20 [2] RSPM (R 4.1.0) ## interactiveDisplayBase 1.30.0 2021-05-19 [1] Bioconductor ## IRanges 2.26.0 2021-05-19 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] RSPM (R 4.1.0) ## iSEE 2.4.0 2021-05-19 [1] Bioconductor ## isoband 0.2.5 2021-07-13 [1] RSPM (R 4.1.0) ## iterators 1.0.13 2020-10-15 [1] RSPM (R 4.1.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.1.0) ## jsonlite 1.7.2 2020-12-09 [2] RSPM (R 4.1.0) ## KEGGREST 1.32.0 2021-05-19 [1] Bioconductor ## KernSmooth 2.23-20 2021-05-03 [3] CRAN (R 4.1.0) ## knitr 1.33 2021-04-24 [2] RSPM (R 4.1.0) ## labeling 0.4.2 2020-10-20 [1] RSPM (R 4.1.0) ## lambda.r 1.2.4 2019-09-18 [1] RSPM (R 4.1.0) ## later 1.2.0 2021-04-23 [1] RSPM (R 4.1.0) ## lattice 0.20-44 2021-05-02 [3] CRAN (R 4.1.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] RSPM (R 4.1.0) ## lifecycle 1.0.0 2021-02-15 [2] RSPM (R 4.1.0) ## limma 3.48.1 2021-06-24 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] RSPM (R 4.1.0) ## littler 0.3.13 2021-07-24 [2] RSPM (R 4.1.0) ## lmtest 0.9-38 2020-09-09 [1] RSPM (R 4.1.0) ## lobstr 1.1.1 2019-07-02 [1] RSPM (R 4.1.0) ## locfit 1.5-9.4 2020-03-25 [1] RSPM (R 4.1.0) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.1.0) ## maps 3.3.0 2018-04-03 [1] RSPM (R 4.1.0) ## markdown 1.1 2019-08-07 [2] RSPM (R 4.1.0) ## MASS 7.3-54 2021-05-03 [3] CRAN (R 4.1.0) ## Matrix 1.3-4 2021-06-01 [3] RSPM (R 4.1.0) ## MatrixGenerics 1.4.1 2021-08-03 [1] Bioconductor ## matrixStats 0.60.0 2021-07-26 [1] RSPM (R 4.1.0) ## mclust 5.4.7 2020-11-20 [1] RSPM (R 4.1.0) ## memoise 2.0.0 2021-01-26 [2] RSPM (R 4.1.0) ## metapod 1.0.0 2021-05-19 [1] Bioconductor ## methods * 4.1.0 2021-07-29 [3] local ## mgcv 1.8-36 2021-06-01 [3] RSPM (R 4.1.0) ## mime 0.11 2021-06-23 [2] RSPM (R 4.1.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.1.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.1.0) ## nlme 3.1-152 2021-02-04 [3] CRAN (R 4.1.0) ## nnet 7.3-16 2021-05-03 [3] CRAN (R 4.1.0) ## openssl 1.4.4 2021-04-30 [2] RSPM (R 4.1.0) ## org.Hs.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## org.Mm.eg.db 3.13.0 2021-07-29 [1] Bioconductor ## parallel 4.1.0 2021-07-29 [3] local ## parallelly 1.27.0 2021-07-19 [1] RSPM (R 4.1.0) ## patchwork 1.1.1 2020-12-17 [1] RSPM (R 4.1.0) ## pbapply 1.4-3 2020-08-18 [1] RSPM (R 4.1.0) ## PCAtools 2.4.0 2021-05-19 [1] Bioconductor ## pheatmap 1.0.12 2019-01-04 [1] RSPM (R 4.1.0) ## pillar 1.6.2 2021-07-29 [2] RSPM (R 4.1.0) ## pkgbuild 1.2.0 2020-12-15 [2] RSPM (R 4.1.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.1.0) ## pkgload 1.2.1 2021-04-06 [2] RSPM (R 4.1.0) ## plogr 0.2.0 2018-03-25 [1] RSPM (R 4.1.0) ## plotly 4.9.4.1 2021-06-18 [1] RSPM (R 4.1.0) ## plyr 1.8.6 2020-03-03 [1] RSPM (R 4.1.0) ## png 0.1-7 2013-12-03 [1] RSPM (R 4.1.0) ## polyclip 1.10-0 2019-03-14 [1] RSPM (R 4.1.0) ## praise 1.0.0 2015-08-11 [2] RSPM (R 4.1.0) ## prettyunits 1.1.1 2020-01-24 [2] RSPM (R 4.1.0) ## processx 3.5.2 2021-04-30 [2] RSPM (R 4.1.0) ## progress 1.2.2 2019-05-16 [1] RSPM (R 4.1.0) ## promises 1.2.0.1 2021-02-11 [1] RSPM (R 4.1.0) ## ProtGenerics 1.24.0 2021-05-19 [1] Bioconductor ## pryr 0.1.5 2021-07-26 [1] RSPM (R 4.1.0) ## ps 1.6.0 2021-02-28 [2] RSPM (R 4.1.0) ## purrr 0.3.4 2020-04-17 [2] RSPM (R 4.1.0) ## R.methodsS3 1.8.1 2020-08-26 [1] RSPM (R 4.1.0) ## R.oo 1.24.0 2020-08-26 [1] RSPM (R 4.1.0) ## R.utils 2.10.1 2020-08-26 [1] RSPM (R 4.1.0) ## R6 2.5.0 2020-10-28 [2] RSPM (R 4.1.0) ## RANN 2.6.1 2019-01-08 [1] RSPM (R 4.1.0) ## rapiclient 0.1.3 2020-01-17 [2] RSPM (R 4.1.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.1.0) ## rcmdcheck 1.3.3 2019-05-07 [2] RSPM (R 4.1.0) ## RColorBrewer 1.1-2 2014-12-07 [1] RSPM (R 4.1.0) ## Rcpp 1.0.7 2021-07-07 [2] RSPM (R 4.1.0) ## RcppAnnoy 0.0.19 2021-07-30 [1] RSPM (R 4.1.0) ## RcppArmadillo 0.10.6.0.0 2021-07-16 [1] RSPM (R 4.1.0) ## RcppEigen 0.3.3.9.1 2020-12-17 [1] RSPM (R 4.1.0) ## RcppHNSW 0.3.0 2020-09-06 [1] RSPM (R 4.1.0) ## RcppProgress 0.4.2 2020-02-06 [1] RSPM (R 4.1.0) ## RCurl 1.98-1.3 2021-03-16 [1] RSPM (R 4.1.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.1.0) ## remotes 2.4.0 2021-06-02 [1] RSPM (R 4.1.0) ## reshape 0.8.8 2018-10-23 [1] RSPM (R 4.1.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.1.0) ## ResidualMatrix 1.2.0 2021-05-19 [1] Bioconductor ## restfulr 0.0.13 2017-08-06 [1] RSPM (R 4.1.0) ## reticulate 1.20 2021-05-03 [1] RSPM (R 4.1.0) ## rhdf5 2.36.0 2021-05-19 [1] Bioconductor ## rhdf5filters 1.4.0 2021-05-19 [1] Bioconductor ## Rhdf5lib 1.14.2 2021-07-06 [1] Bioconductor ## Rhtslib 1.24.0 2021-05-19 [1] Bioconductor ## rintrojs 0.3.0 2021-06-06 [1] RSPM (R 4.1.0) ## rjson 0.2.20 2018-06-08 [1] RSPM (R 4.1.0) ## rlang 0.4.11 2021-04-30 [2] RSPM (R 4.1.0) ## rmarkdown 2.9 2021-06-15 [1] RSPM (R 4.1.0) ## robustbase 0.93-8 2021-06-02 [1] RSPM (R 4.1.0) ## ROCR 1.0-11 2020-05-02 [1] RSPM (R 4.1.0) ## roxygen2 7.1.1 2020-06-27 [2] RSPM (R 4.1.0) ## rpart 4.1-15 2019-04-12 [3] CRAN (R 4.1.0) ## rprojroot 2.0.2 2020-11-15 [2] RSPM (R 4.1.0) ## Rsamtools 2.8.0 2021-05-19 [1] Bioconductor ## RSpectra 0.16-0 2019-12-01 [1] RSPM (R 4.1.0) ## RSQLite 2.2.7 2021-04-22 [1] RSPM (R 4.1.0) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.1.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.1.0) ## rtracklayer 1.52.0 2021-05-19 [1] Bioconductor ## Rtsne 0.15 2018-11-10 [1] RSPM (R 4.1.0) ## rversions 2.1.1 2021-05-31 [2] RSPM (R 4.1.0) ## S4Vectors 0.30.0 2021-05-19 [1] Bioconductor ## sass 0.4.0 2021-05-12 [1] RSPM (R 4.1.0) ## ScaledMatrix 1.0.0 2021-05-19 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] RSPM (R 4.1.0) ## scater 1.20.1 2021-06-15 [1] Bioconductor ## scattermore 0.7 2020-11-24 [1] RSPM (R 4.1.0) ## scPipe 1.14.0 2021-05-19 [1] Bioconductor ## scran 1.20.1 2021-05-24 [1] Bioconductor ## scRNAseq 2.6.1 2021-05-25 [1] Bioconductor ## sctransform 0.3.2 2020-12-16 [1] RSPM (R 4.1.0) ## scuttle 1.2.1 2021-08-05 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [2] RSPM (R 4.1.0) ## Seurat 4.0.3 2021-06-10 [1] RSPM (R 4.1.0) ## SeuratObject 4.0.2 2021-06-09 [1] RSPM (R 4.1.0) ## shape 1.4.6 2021-05-19 [1] RSPM (R 4.1.0) ## shapefiles 0.7 2013-01-26 [1] RSPM (R 4.1.0) ## shiny 1.6.0 2021-01-25 [1] RSPM (R 4.1.0) ## shinyAce 0.4.1 2019-09-24 [1] RSPM (R 4.1.0) ## shinydashboard 0.7.1 2018-10-17 [1] RSPM (R 4.1.0) ## shinyjs 2.0.0 2020-09-09 [1] RSPM (R 4.1.0) ## shinyWidgets 0.6.0 2021-03-15 [1] RSPM (R 4.1.0) ## SingleCellExperiment 1.14.1 2021-05-21 [1] Bioconductor ## sitmo 2.0.1 2019-01-07 [1] RSPM (R 4.1.0) ## snow 0.4-3 2018-09-14 [1] RSPM (R 4.1.0) ## sourcetools 0.1.7 2018-04-25 [1] RSPM (R 4.1.0) ## sp 1.4-5 2021-01-10 [1] RSPM (R 4.1.0) ## sparseMatrixStats 1.4.0 2021-05-19 [1] Bioconductor ## spatial 7.3-14 2021-05-03 [3] CRAN (R 4.1.0) ## spatstat.core 2.3-0 2021-07-16 [1] RSPM (R 4.1.0) ## spatstat.data 2.1-0 2021-03-21 [1] RSPM (R 4.1.0) ## spatstat.geom 2.2-2 2021-07-12 [1] RSPM (R 4.1.0) ## spatstat.sparse 2.0-0 2021-03-16 [1] RSPM (R 4.1.0) ## spatstat.utils 2.2-0 2021-06-14 [1] RSPM (R 4.1.0) ## splines 4.1.0 2021-07-29 [3] local ## statmod 1.4.36 2021-05-10 [1] RSPM (R 4.1.0) ## stats * 4.1.0 2021-07-29 [3] local ## stats4 4.1.0 2021-07-29 [3] local ## stringi 1.7.3 2021-07-16 [2] RSPM (R 4.1.0) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.1.0) ## SummarizedExperiment 1.22.0 2021-05-19 [1] Bioconductor ## survival 3.2-11 2021-04-26 [3] CRAN (R 4.1.0) ## sys 3.4 2020-07-23 [2] RSPM (R 4.1.0) ## tcltk 4.1.0 2021-07-29 [3] local ## tensor 1.5 2012-05-05 [1] RSPM (R 4.1.0) ## TENxPBMCData 1.10.0 2021-05-20 [1] Bioconductor ## testthat 3.0.4 2021-07-01 [2] RSPM (R 4.1.0) ## tibble 3.1.3 2021-07-23 [2] RSPM (R 4.1.0) ## tidyr 1.1.3 2021-03-03 [1] RSPM (R 4.1.0) ## tidyselect 1.1.1 2021-04-30 [1] RSPM (R 4.1.0) ## tinytex 0.33 2021-08-05 [1] RSPM (R 4.1.0) ## tools 4.1.0 2021-07-29 [3] local ## usethis 2.0.1 2021-02-10 [2] RSPM (R 4.1.0) ## utf8 1.2.2 2021-07-24 [2] RSPM (R 4.1.0) ## utils * 4.1.0 2021-07-29 [3] local ## uwot 0.1.10 2020-12-15 [1] RSPM (R 4.1.0) ## vctrs 0.3.8 2021-04-29 [2] RSPM (R 4.1.0) ## vipor 0.4.5 2017-03-22 [1] RSPM (R 4.1.0) ## viridis 0.6.1 2021-05-11 [1] RSPM (R 4.1.0) ## viridisLite 0.4.0 2021-04-13 [1] RSPM (R 4.1.0) ## waldo 0.2.5 2021-03-08 [2] RSPM (R 4.1.0) ## whisker 0.4 2019-08-28 [2] RSPM (R 4.1.0) ## withr 2.4.2 2021-04-18 [2] RSPM (R 4.1.0) ## xfun 0.24 2021-06-15 [2] RSPM (R 4.1.0) ## XML 3.99-0.6 2021-03-16 [1] RSPM (R 4.1.0) ## xml2 1.3.2 2020-04-23 [2] RSPM (R 4.1.0) ## xopen 1.0.0 2018-09-17 [2] RSPM (R 4.1.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.1.0) ## XVector 0.32.0 2021-05-19 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.1.0) ## zip 2.2.0 2021-05-31 [2] RSPM (R 4.1.0) ## zlibbioc 1.38.0 2021-05-19 [1] Bioconductor ## zoo 1.8-9 2021-03-09 [1] RSPM (R 4.1.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library Fecha de la última actualización de esta página: 2021-08-08 00:49:54. Licencia This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["introducción-a-r-y-rstudio.html", "1 Introducción a R y RStudio Patrocinadores", " 1 Introducción a R y RStudio TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["ejercicio-usando-usethis-here-y-postcards.html", "2 Ejercicio usando usethis, here y postcards Patrocinadores", " 2 Ejercicio usando usethis, here y postcards TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducción-a-rna-seq-de-célula-única-scrna-seq-con-bioconductor-y-al-libro-de-osca.html", "3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA Patrocinadores", " 3 Introducción a RNA-seq de célula única (scRNA-seq) con Bioconductor y al libro de OSCA TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["estructura-e-importe-de-datos.html", "4 Estructura e importe de datos Patrocinadores", " 4 Estructura e importe de datos TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["control-de-calidad.html", "5 Control de calidad Patrocinadores", " 5 Control de calidad TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["normalización-de-datos.html", "6 Normalización de datos Patrocinadores", " 6 Normalización de datos TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["selección-de-genes.html", "7 Selección de genes Patrocinadores", " 7 Selección de genes TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["reducción-de-dimensiones.html", "8 Reducción de dimensiones 8.1 Diapositivas de Peter Hickey 8.2 Motivación 8.3 Reducción de dimensionalidad 8.4 Dataset ilustrativo: Zeisel 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas 8.6 Análisis de Componentes Principales 8.7 Reducción de dimensionalidad para visualización 8.8 Donde estamos Patrocinadores", " 8 Reducción de dimensiones Instructora: Laura Gómez-Romero 8.1 Diapositivas de Peter Hickey Contenido adaptado de: aquí 8.2 Motivación El siguiente paso en el análisis de scRNA-seq usualmente consiste en identificar grupos de células “similares” Por ejemplo: un análisis de clustering busca identificar células con un perfil transcriptómico similar al calcular distancias entre ellas Si tuviéramos un dataset con dos genes podríamos hacer una gráfica de dos dimensiones para identificar clusters de células Pero… tenemos decenas de miles de genes : Reducción de dimensionalidad 8.3 Reducción de dimensionalidad Es poible porque la expresión de diferentes genes estará correlacionada si estos genes son afectados por el mismo proceso biológico. Por lo tanto, no necesitamos almacenar información independiente para genes individuales. Podemos comprimir móltiples “features” (genes) en una ónica dimensión. Ventajas: Reduce trabajo computacional en análisis posteriores Reduce el ruido al “promediar” mútiples genes obteniendo una representación mós precisa de los patrones en los datos Permite una graficación efectiva en dos dimensiones 8.4 Dataset ilustrativo: Zeisel library(scRNAseq) sce.zeisel &lt;- ZeiselBrainData(ensembl = TRUE) Estudio de tipos celulares en el cerebro de ratón (oligodendrocitos, microglia, neuronas, etc) procesados con el sistema STRT-seq (similar a CEL-Seq) Descripción aquí Zeisel, A. et al. Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq. Science 347, 1138-1142 (2015) # Quality control library(scater) is.mito &lt;- which(rowData(sce.zeisel)$featureType == &quot;mito&quot;) stats &lt;- perCellQCMetrics(sce.zeisel, subsets = list(Mt = is.mito) ) qc &lt;- quickPerCellQC(stats, percent_subsets = c(&quot;altexps_ERCC_percent&quot;, &quot;subsets_Mt_percent&quot;) ) sce.zeisel &lt;- sce.zeisel[, !qc$discard] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.zeisel) sce.zeisel &lt;- computeSumFactors(sce.zeisel, cluster = clusters ) sce.zeisel &lt;- logNormCounts(sce.zeisel) # variance-modelling dec.zeisel &lt;- modelGeneVarWithSpikes( sce.zeisel, &quot;ERCC&quot; ) 8.5 Dataset ilustrativo: 10x PBMC4k no filtradas library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset “Células mononucleares humanas de sangre periférica” de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) 8.6 Análisis de Componentes Principales PCA es el arma principal de la reducción de dimensionalidad PCA descubre las combinaciones (lineales) de “features” que capturan la cantidad más grande de variación In PCA, la primer combinación lineal (componente principal) se elige tal que permite capturar la mayor varianza a través de las células. El siguiente PC se elige tal que es “ortogonal” al primero y captura la cantidad más grande de la variación restante, y así sucesivamente… 8.6.1 PCA aplicado a datos de scRNA-seq Podemos realizar reducción de dimensionalidad al aplicar PCA en la matriz de cuentas transformadas (log-counts matrix) y restringiendo los análisis posteriores a los primeros PCs (top PCs) Esto puede reducir nuestro dataset de 20,000 dimensiones a, digamos, 10, sin perder demasiada información La técnica de PCA tiene muchas propiedades teóricas bien estudiadas. Hay varias formas rápidas de realizar PCA en datasets grandes. 8.6.2 Suposiciones de PCA aplicadas a los datos de scRNA-seq Los procesos biológicos afectan múltiples genes en una manera coordinada Los primeros PCs probablemente representan la estructura biológica dado que más variación puede ser capturada considerando el comportamiento correlacionado de muchos genes Se espera que el ruido técnico azaroso afecte cada gen independientemente Consideración: Los primeros PCs capturarán “batch effects” (efectos de lote) que afectan muchos genes en una manera coordinada library(scran) top.zeisel &lt;- getTopHVGs(dec.zeisel, n = 2000) library(scater) set.seed(100) sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel ) Por default, runPCA() usa un método rápido aproximado que realiza simulaciones, por lo tanto, es necesario ‘configurar la semilla’ para obtener resultados reproducibles 8.6.3 Eligiendo el número de PCs Esta elección en análoga a la elección del numero de HVGs. Elegir más PCs evitará descartar señal biológica a expensas de retener más ruido Es común seleccionar un número de PCs “razonable” pero arbitrario (10-50), continuar con el análisis y regresar para checar la robustez de los resultados en cierto rango de valores Ahora exploraremos algunas estrategias guiadas por los datos (data-driven) para hacer esta selección 8.6.3.1 Usando el punto del codo library(PCAtools) percent.var &lt;- attr(reducedDim(sce.zeisel), &quot;percentVar&quot;) chosen.elbow &lt;- PCAtools::findElbowPoint(percent.var) plot(percent.var, xlab = &quot;PC&quot;, ylab = &quot;Variance explained (%)&quot;) abline(v = chosen.elbow, col = &quot;red&quot;) Una heurística simple es elegir el número de PCs basado en el porcentaje de varianza explicado por PCs sucesivos 8.6.3.2 Basados en la estructura de la población choices &lt;- getClusteredPCs(reducedDim(sce.zeisel)) chosen.clusters &lt;- metadata(choices)$chosen Esta es una aproximación heurística más sofisticada que usa el número de clusters como un proxy del número de subpoblaciones Supongamos que esperamos d subpoblaciones de células, en ese caso, necesitamos d-1 dimensiones para garantizar la separación de todas las subpoblaciones Pero… en un escenario real realmente no sabes cuántas poblaciones hay… Intenta con un rango para d y únicamente considera valores que produzcan a lo más d+1 clusters Cuando se seleccionan más clusters con menos dimensiones se produce ‘overclustering’ Elige una d que maximice el número de clusters sin caer en ‘overclustering’ Ventaja: Es una solución pragmática que soluciona el equilibrio sesgo-varianza en los análisis posteriores (especialmente clustering) Desventaja: Hace suposiciones fuertes sobre la naturaleza de las diferencias biológicas entre los clusters, y de hecho supone la existencia de clusters, los cuales podrían no existir en procesos biológicos como la diferenciación 8.6.4 Juntando todo set.seed(100) # Compute and store the &#39;full&#39; set of PCs sce.zeisel &lt;- runPCA(sce.zeisel, subset_row = top.zeisel) # Can also select d and store the reduced set of PCs # e.g., using the elbow point reducedDim(sce.zeisel, &quot;PCA_elbow&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.elbow] # e.g., based on population structure reducedDim(sce.zeisel, &quot;PCA_clusters&quot;) &lt;- reducedDim( sce.zeisel, &quot;PCA&quot; )[, 1:chosen.clusters] 8.6.5 Usando el ruido técnico library(scran) set.seed(111001001) denoised.pbmc &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc, subset.row = top.pbmc ) Conserva todos los PCs hasta que el % de variación explicado alcance algun límite (por ejemplo, basado en la estimación de la variación técnica) denoisePCA() automáticamente selecciona el número de PCs Por default, denoisePCA() realiza algunas simulaciones, por lo tanto necesitamos ‘configurar la semilla’ para obtener resultados reproducibles dim(reducedDim(denoised.pbmc, &quot;PCA&quot;)) ## [1] 3985 9 La dimensionalidad del output es el límite inferior para el número de PCs requeridos para explicar toda la variación biológica. Lo que significa que cualquier número menor de PCs definitivamente descartaría algún aspecto de la señal biológica Esto no grantiza que los PCs retenidos capturen toda la señal biológica Esta técnica usualmente retiene más PCs que el método del punto del codo set.seed(001001001) denoised.zeisel &lt;- denoisePCA(sce.zeisel, technical = dec.zeisel, subset.row = top.zeisel ) dim(reducedDim(denoised.zeisel)) ## [1] 2815 50 scran::denoisePCA() internamente limita el numero de PCs, por default 5-50, para evitar la selección de excesivamente pocos PCs (cuando el ruido técnico es alto relativo al ruido biológico) o excesivamente muchos PCs (cuando el ruido técnico es demasiado bajo) Los datos de cerebro de Zeisel están cerca de este límite superior dec.pbmc2 &lt;- modelGeneVar(sce.pbmc) denoised.pbmc2 &lt;- denoisePCA(sce.pbmc, technical = dec.pbmc2, subset.row = top.pbmc ) dim(reducedDim(denoised.pbmc2)) ## [1] 3985 5 scran::denoisePCA() tiende a funcionar mejor cuando la relación media-varianza refleja el ruiudo técnico verdadero, i.e estimado por scran::modelGeneVarByPoisson() o scran::modelGeneVarWithSpikes() en vez de scran::modelGeneVar() El dataset PBMC está cerca de este límite inferior 8.7 Reducción de dimensionalidad para visualización 8.7.1 Motivación Clustering y otros algoritmos operaran fácilmente sobre 10-50 (a lo más) PCs, pero ese número es aún demasiado para la visualización Por lo tanto, necesitamos estrategias adicionales para la reducción de dimensionalidad si queremos visualizar los datos 8.7.2 Visualizando con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, colour_by = &quot;level1class&quot; ) PCA es una técnica lineal, por lo tanto, no es eficiente para comprimir diferencias en más de 2 dimensiones en los primeros 2 PCs 8.7.3 Retos y resumen de la visualización con PCA plotReducedDim(sce.zeisel, dimred = &quot;PCA&quot;, ncomponents = 4, colour_by = &quot;level1class&quot; ) Ventajas: PCA es predecible y no introducirá estructura aritficial en los datos Es deterministico y robusto a cambios pequeños en los valores de entrada Desventajas: Usualmente no es satisfactoria paara visualizar la naturaleza compleja de los datos de scRNA-seq 8.7.4 Visualización con t-SNE set.seed(00101001101) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot;) t-stochastic neighbour embedding (t-SNE) es la visualización por excelencia de datos de scRNA-seq. Intenta encontrar una representación (no-lineal) de los datos usando pocas dimensiones que preserve las distancias entre cada punto y sus vecinos en el espacio multi-dimensional 8.7.4.1 Retos de la visualización con t-SNE set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred = &quot;PCA&quot;, perplexity = 30 ) plotReducedDim(sce.zeisel, dimred = &quot;TSNE&quot;, colour_by = &quot;level1class&quot; ) 8.7.4.2 Preguntas ¿Qué pasa si vuelves a correr runTSNE() sin especifica la semilla? ¿Qué pasa si especificas la semilla pero cambas el valor del parámetro perplexity? 8.7.4.3 Continuando Baja perplejidad favorece la resolución de la estrucutura fina, posiblemente al grado de que la visualización parece rudio random. El siguiente foro discute la selección de parámetros para t-SNE con cierta profundidad No sobreinterpretes los resultados de t-SNE como un ‘mapa’ de las identidades de las células individuales Componentes aleatorios y selección de parámetors cambiarán la visualización La interpretación puede ser engañada por el tamaño y posición de los clusters t-SNE infla clusters densos y comprime clusters escasos t-SNE no está obligado a preservar las localizaciones relativas de clusters no-vecinos (no puedes interpretar distancias no locales) Aún así: t-SNE es una herramienta probada para visualización general de datos de scRNA-seq y sigue siendo muy popular 8.7.5 Visualización con UMAP Uniform manifold approximation and project (UMAP) es una alternativa a t-SNE Así como t-SNE, UMAP intenta encontrar una representación (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional t-SNE y UMAP están basados en diferentes teorías matemáticas set.seed(1100101001) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) Comparado con t-SNE: UMAP tiende a tener clusters visualmente más compactos Intenta preservar más de la estructura global que t-SNE Tiende a ser más rápido que t-SNE, lo cual puede ser importante para datasets grandes. La diferencia desaprece cuando se aplican a PCs 8.7.5.1 Retos de la visualización con UMAP set.seed(100) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred = &quot;PCA&quot;, n_neighbors = 15 ) plotReducedDim(sce.zeisel, dimred = &quot;UMAP&quot;, colour_by = &quot;level1class&quot; ) 8.7.5.2 Preguntas ¿Qué pasa si vuelves a correr runUMAP() sin especifica la semilla? ¿Qué pasa si especificas la semilla pero cambas el valor del parámetro n_neighbors? 8.7.5.3 Continuando Igual que para t-SNE, es necesario configurar una semilla y diferentes valores para los parámetros cambiarán la visualización Si el valor para los parámetros n_neighbors o min_dist es demasiado bajo entonces el ruido aleatorio se interpretará como estructura de alta-resolución, si son demasiado altos entonces se perderá la estructura fina TIP: Trata un rango de valores para cada parámetro para asegurarte de que no comprometen ninguna de las conclusiones derivadas de la gráfica UMAP 8.7.6 Interpretando las gráficas Recuerda: Reducción de dimensionalidad para la visualización de los datos necesariamente involucra descartar información y distorsionar las distancias entre las células No sobre interpretes las gráficas bonitas 8.7.7 Resumen y recomendaciones Las gráficas de t-SNE y UMAP son herramientas diagnóstico importantes, por ejemplo: para checar si dos clusters son realmente subclusters vecinos o si un cluster puede ser dividido en más de un cluster Es debatible cual visualización, t-SNE o UMAP, es más útil o estéticamente agradable. Está bien elegir aquélla que funcione mejor para tu análisis (tomando en cuenta que tratarás la gráfica únicamente como una herramienta de visualización/diagnóstico y que no llegarás a ninguna conclusión fuerte basado únicamente en la gráfica ) 8.8 Donde estamos Patrocinadores Agradecemos a nuestros patrocinadores: "],["clustering.html", "9 Clustering 9.1 Diapositivas de Peter Hickey 9.2 Dataset ilustrativo: 10X PBMC4k no filtrado 9.3 Motivación 9.4 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? 9.5 ¿Cuál es el verdadero clustering? 9.6 Clustering basado en grafos 9.7 Implementación 9.8 Clustering basado en grafos 9.9 Otros métodos de clustering 9.10 Evaluando estabilidad de los clusters 9.11 Subclustering 9.12 Resumen y recomendaciones 9.13 Donde estamos Patrocinadores", " 9 Clustering Instructora: Laura Gómez-Romero 9.1 Diapositivas de Peter Hickey Ve las diapositivas aquí 9.2 Dataset ilustrativo: 10X PBMC4k no filtrado library(BiocFileCache) bfc &lt;- BiocFileCache() raw.path &lt;- bfcrpath(bfc, file.path( &quot;http://cf.10xgenomics.com/samples&quot;, &quot;cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz&quot; )) untar(raw.path, exdir = file.path(tempdir(), &quot;pbmc4k&quot;)) library(DropletUtils) library(Matrix) fname &lt;- file.path(tempdir(), &quot;pbmc4k/raw_gene_bc_matrices/GRCh38&quot;) sce.pbmc &lt;- read10xCounts(fname, col.names = TRUE) Dataset de células mononucleares de sangre periférica humana (PBMC) de 10X Genomics Descripción aquí Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017) # gene-annotation library(scater) rownames(sce.pbmc) &lt;- uniquifyFeatureNames( rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol ) library(EnsDb.Hsapiens.v86) location &lt;- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID, column = &quot;SEQNAME&quot;, keytype = &quot;GENEID&quot; ) # cell-detection set.seed(100) e.out &lt;- emptyDrops(counts(sce.pbmc)) sce.pbmc &lt;- sce.pbmc[, which(e.out$FDR &lt;= 0.001)] # quality-control stats &lt;- perCellQCMetrics(sce.pbmc, subsets = list(Mito = which(location == &quot;MT&quot;)) ) high.mito &lt;- isOutlier(stats$subsets_Mito_percent, type = &quot;higher&quot; ) sce.pbmc &lt;- sce.pbmc[, !high.mito] # normalization library(scran) set.seed(1000) clusters &lt;- quickCluster(sce.pbmc) sce.pbmc &lt;- computeSumFactors(sce.pbmc, cluster = clusters) sce.pbmc &lt;- logNormCounts(sce.pbmc) # variance modelling set.seed(1001) dec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc) top.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1) # dimensionality-reduction set.seed(10000) sce.pbmc &lt;- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc ) set.seed(100000) sce.pbmc &lt;- runTSNE(sce.pbmc, dimred = &quot;PCA&quot;) set.seed(1000000) sce.pbmc &lt;- runUMAP(sce.pbmc, dimred = &quot;PCA&quot;) 9.3 Motivación Clustering es un procedimiento no supervisado par definir grupos de células con perfiles de expresión similares Su propósito principal es resumir los datos en un formato digerido susceptible a interpretación humana Nos permite asignar etiquetas (por ejemplo, tipos celulares) a las células 9.4 ¿Por qué no realizamos el clustering sobre las coordenadas de t-SNE/UMAP? Las técnicas de t-SNE/UMAP han comprimido datos altamente multi-dimensionales en dos dimensiones Esta compresión inevitablemente ha provocado la perdida de información Por lo tanto, agrupamos sobre los PCs y después visualizamos las identidades de los clusters en la gráfica t-SNE/UMAP 9.5 ¿Cuál es el verdadero clustering? Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido 9.6 Clustering basado en grafos 9.6.1 Antecedentes El clustering basado en grafos fue popularizado (más no inventado) por su uso en Seurat Objetivo: Construir un grafo en el que cada nodo es una célula que está conectada a sus vecinos más cercanos en el espacio multidimensional 9.6.2 Gráfica de los k vecinos más cercanos (k-nearest neighbour -KNN- graph) Ilustremos como funciona para 20 células 9.6.3 Gráfica de los vecinos más próximos compartidos (SNN) De una gráfica KNN se puede construir una grafica SNN Podemos asignar pesos a cada arista del grafo, basándonos en la similaridad de las células involucradas, dándole pesos más altos a células que están más cercanamente relacionadas 9.6.4 Gráfica SNN con pesos en las aristas 9.6.5 Pasando de una gráfica SNN pesada cluster mediante detección de comunidades A partir de una gráfica SNN pesada podemos aplicar algoritmos para identificar comunidades de células Comunidades son grupos de células que están más conectadas a células en el mismo grupo que lo que están a células de un grupo diferente Cada comunidad representa un cluster 9.6.6 Resumen de clustering basado en grafos La construcción y búsqueda de una red KNN es rápida, por lo tanto, es escalable para datasets grandes Debes evitar obtener conclusiones fuertes acerca de la forma de los clusters o la distribución de células dentro de cada cluster Cada célula es conectada con un número mínimo de células vecinas obligatoriamente, esto reduce el riesgo de cluster no informativos con unos pocos outliers Después de la construcción del grafo, no se almacena información adicional más alla de las células vecinas. Esto puede producir subclusters artificiales en regiones con muchas células 9.7 Implementación ¿Cuántas céulas vecinas debo considerar durante la construcción del grafo? ¿Cómo debo pesar las aristas? ¿Cuál algoritmo de detección de comunidades se debe usar para definir los clusters? 9.8 Clustering basado en grafos library(scran) # Build graph using k = 10 nearest neighbours in PCA-space g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;) # Identify communities using the Walktrap method clust &lt;- igraph::cluster_walktrap(g)$membership # Visualise clusters on t-SNE plot library(scater) sce.pbmc$cluster &lt;- factor(clust) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster&quot;) ¿Qué pasa si utilizas una k más grande o más pequeña? 9.8.1 Detalles adicionales del ejemplo previo KNNs se basan en la distancia Euclideana entre células Las aristas se crean entre todos los pares de células que comparten por lo menos un vecino Usa el esquema de peso de: Xu and Su (2015) 9.8.2 Eligiendo un valor de k El valor de k puede ser toscamente interpretado como el tamaño anticipado de la subpoblación más pequeña Si una subpoblación tiene menos que (k+1) células entonces el método será forzado a construir aristas entre células de esa subpoblación y células de otras subpoblaciones Esto incrementa el riesgo de que la subpoblación en cuestión no forme su propio cluster 9.8.3 Estilo Seurat # Jaccard-based weights followed by Louvain clustering # aka &#39;Seurat-style&#39; clustering g &lt;- buildSNNGraph(sce.pbmc, k = 10, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) clust2 &lt;- igraph::cluster_louvain(g)$membership sce.pbmc$cluster2 &lt;- factor(clust2) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by = &quot;cluster2&quot;) 9.8.4 Clustering basado en un grafo Pipelines basados en Seurat: Pesos basados en Jacard Clustering Louvain Pipelines basados en Scran: Pesos basados en Randos Clustering Walktrap Para detalles sobre la seleccion de parámetros y comparaciones: visitar esta página 9.8.5 Evaluando la separación de los clusters Modularidad es una métrica natural para evaluar la separación entre comunidades/clusters Definido como la diferencia (escalada) entre el peso total observado de las aristas entre los nodos en el mismo cluster y el peso total esperado si los pesos fueran distribuidos aleatoriamente entre todos los pares de nodos Nosotros computaremos un score de modularidad para cada cluster (usando las tasas en vez de las diferencias) library(bluster) ratio &lt;- pairwiseModularity(g, clust, as.ratio = TRUE) dim(ratio) ## [1] 16 16 library(pheatmap) pheatmap(log2(ratio + 1), cluster_rows = FALSE, cluster_cols = FALSE, color = colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(100) ) Un dataset que contiene clusters bien separados debería contener la mayoría del peso total observado en las entradas diagonales, i.e la mayoría de las aristas ocurren entre células del mismo cluster Para más detalles sobre evaluación de la separación entre clusters visite esta página 9.9 Otros métodos de clustering Clustering por k-means Rápido Se debe especificar el número de clusters de antemano Favorece clusters esféricos Clustering jerárquico Produce un dendograma (árbol) representando las células y la similaridad entre subpoblaciones a varias resoluciones Demasiado lento para correrse en algo más grande que los datasets más pequeños de scRNA-seq 9.10 Evaluando estabilidad de los clusters Una propiedad deseable de un cluster dado es que éste sea estable a las perturbaciones en los datos de entrada: Pequeños cambios al procesamiento no cambiarán el resultado Esto incrementa la probabilida de que las conclusiones puedan ser replicadas en un estudio independiente Uno puede hacer un proceso de bootstrap para evaluar la estabilidad de un algoritmo de clustering en un dataset dado myClusterFUN &lt;- function(x) { g &lt;- buildSNNGraph(x, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) igraph::cluster_louvain(g)$membership } originals &lt;- myClusterFUN(sce.pbmc) set.seed(0010010100) coassign &lt;- bootstrapStability(sce.pbmc, FUN = myClusterFUN, clusters = originals ) Coasignación es la probabilidad de que células elegidas al azar del cluster X y Y sean asignadas al mismo cluster en la réplica del proceso de bootstrap pheatmap(coassign, cluster_row = FALSE, cluster_col = FALSE, color = rev(viridis::magma(100)) ) Probabilidad alta de coasignación indica que X no es estable con respecto a su separación de Y. Queremos altas probabilidades de coasignación en la diagonal Bootstraping solo considera el efecto del ruido de muestreo e ignora otros factores que pueden afectar la reproducinilidad (efectos de batch, variación entre los donadores) Pobre separación puede ser altamente estable 9.11 Subclustering Mejora la resolucón al repetir el proceso de feature selection y clustering dentro de un único cluster Se enfoca en los HGVs y PCs que son los más relevantes para un cluster específico g.full &lt;- buildSNNGraph(sce.pbmc, use.dimred = &quot;PCA&quot;) clust.full &lt;- igraph::cluster_walktrap(g.full)$membership sce.pbmc$clust.full &lt;- factor(clust.full) plotExpression(sce.pbmc, features = c(&quot;CD3E&quot;, &quot;CCR7&quot;, &quot;CD69&quot;, &quot;CD44&quot;), x = &quot;clust.full&quot;, colour_by = &quot;clust.full&quot; ) CD3E, CCR7, CD69, y CD44 son marcadores de células T de memoria. Dentro de las células T de memoria, ¿dónde están las subpoblaciones CD4+ y CD8+? # Repeating modelling and PCA on the subset of cells we have # identified as memory T-cells (cluster 6). memory &lt;- 6 sce.memory &lt;- sce.pbmc[, clust.full == memory] dec.memory &lt;- modelGeneVar(sce.memory) sce.memory &lt;- denoisePCA(sce.memory, technical = dec.memory, subset.row = getTopHVGs(dec.memory, prop = 0.1) ) # Repeating clustering on the subset. g.memory &lt;- buildSNNGraph(sce.memory, use.dimred = &quot;PCA&quot;) clust.memory &lt;- igraph::cluster_walktrap(g.memory)$membership sce.memory$clust.memory &lt;- factor(clust.memory) plotExpression(sce.memory, features = c(&quot;CD8A&quot;, &quot;CD4&quot;), x = &quot;clust.memory&quot; ) Expresión de CD4 es bajo, por lo tanto, su cambio es modesto, pero la interpretación es clara scran::quickSubCluster() ciclará sobre los clusters y realizará el proceso de subclustering de acuerdo a una función especificada por el usuario. Esto asume que la misma función es apropiada para todos los clusters Si tipos celulares o estados celulares se extienden sobre las fronteras de los clusters, entonces un subcluster podría representar contaminación de un tipo celular en un cluster separado 9.12 Resumen y recomendaciones Un cluster no implica un tipo celular Nosotros podemos definir tantos clusters como queramos y podemos utilizar el algoritmo que más nos acomode El clustering, como un microscopio, simplemente es una herramienta para explorar los datos Preguntar por el mejor clustering es similar a preguntar cuál es la mejor magnificación en un microscopio sin contenido Clustering basado en grafos es rápido y evita tener que hacer suposiciones fuertes sobre la forma de los clusters o la distribución de las células dentro de cada cluster: scran::buildSNNGraph() igraph::cluster_walktrap() o igraph::cluster_louvain() Modularidad y estabilidad de los clusters son diagnósticos útiles El proceso de subclustering podría mejorar la resolución dentro de clusters grandes 9.13 Donde estamos Patrocinadores Agradecemos a nuestros patrocinadores: "],["identificación-de-genes-marcadores.html", "10 Identificación de genes marcadores Patrocinadores", " 10 Identificación de genes marcadores TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["anotación-de-clusters-de-células.html", "11 Anotación de clusters de células Patrocinadores", " 11 Anotación de clusters de células TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["análisis-de-expresión-diferencial.html", "12 Análisis de expresión diferencial Patrocinadores", " 12 Análisis de expresión diferencial TODO Patrocinadores Agradecemos a nuestros patrocinadores: "],["introducción-a-seurat.html", "13 Introducción a Seurat Patrocinadores", " 13 Introducción a Seurat TODO Patrocinadores Agradecemos a nuestros patrocinadores: "]]
